<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>介绍 on outrun的笔记</title>
    <link>https://example.com/</link>
    <description>Recent content in 介绍 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>整理笔记到github</title>
      <link>https://example.com/posts/note/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/posts/note/</guid>
      <description>记笔记 #  由于从事软件行业，信息量大，所以养成了记笔记的习惯。 笔记可以按自己的格式和思路写自己需要的，也便于查看。网上的东西对自己来说比较杂乱。 自学的都记了下来了，工作上的少些。
笔记变更史 #  一开始用的是linux论坛上推荐的一个工具，现在名字都忘了。 后来一直在用mybase，感觉不错，到现在有5年了。但有几个问题:
 linux下容易打出乱码字符。 删除文档容易出bug。 格式不太好，版本7后用了html做内容，也会有些问题。 是本地数据库，没法在线备份，也不好分享。毕竟东西都放网上比较方便。 软件是收费的。（但开发者很良心，修改下软件配置就可以接着用，这个&amp;quot;bug&amp;quot;他们一直不修复）  一直在考虑有道云笔记，开始时它功能不全，没有用。现在功能不错了，我又不想用了。 因为我想自己做一个，容易满足自己的想法和维护。 除这些之外gitbook也可以考虑
现在 #  这里是用了hugo和它的book主题，多谢它们的作者。 经过一段时间的整理，今天这个笔记可以用了，其它细节用到时再调整。</description>
    </item>
    
    <item>
      <title>博客原则</title>
      <link>https://example.com/posts/first/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/posts/first/</guid>
      <description>博客原则 #   做有意义的分享  </description>
    </item>
    
    <item>
      <title>LinuxTool</title>
      <link>https://example.com/docs/computer/linux/linux_tool/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      
      <guid>https://example.com/docs/computer/linux/linux_tool/</guid>
      <description>包 #  net-tools ifconfig  内核 #  modprobe vboxdrv # 内核 lsmod # 显示当前系统加载的模块，如systemctl中start了的模块 sysdig sysdig -c topprocs_cpu # 进程cpu top evt.cpu=0 # 只统计cpu0 topprocs_net # 进程带宽 top topprocs_file # 进程硬盘i/o top topfiles_bytes # 文件读写 top proc.name=httpd # 指定进程名 topfiles_time # 文件时间 top topprocs_errors # 进程error top topfiles_errors # 文件error top topscalls_time # 系统调用时间 top topscalls &amp;quot;evt.failed=true&amp;quot; # 系统调用出错 top topconns # 网络连接 top fdcount_by proc.name &amp;quot;fd.type=file&amp;quot; # 进程文件描述符 fdbytes_by fd.</description>
    </item>
    
    <item>
      <title>Monitor</title>
      <link>https://example.com/docs/ops/monitor/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      
      <guid>https://example.com/docs/ops/monitor/</guid>
      <description>基础 #  监控的方式 主动、被动、旁路（舆情） 监控类型 服务端监控、客户端监控 目标 全、块、准 指标 请求量、成功率、耗时  统计 #  指标 访问、访客 停留时长 跳出率 退出率 转化率 参与度 显示方式 选时间段 时序数据表 max、min、avg 埋点 通过可视化工具配置，非硬编码 第三方 友盟 百度移动 魔方 App Annie talking data 神策数据  物理机 #  Load Average #  介绍 数字n表示n倍  cpu #  Usage: 100% system user IO wait Saturation: 1.0core Max Core Usage: 1.0core Interrupts and Context Switches: 10k Processes: 10ops create(Forks) Runnable Blocked  mem #  Physical Memory: RAM(Random-Access Memory)存储器 used free buffers Virtual Memory 介绍 映射到RAM或Disk used available Swap Space used free Swap Activity swap in(read) swap out(write)  disk #  space 增长趋势 I/O Activity read(page in) write(page out) File Descriptors: 1Milion limit allocated I/O Latency: 5ms write read I/O Load: 3 write read  network #  traffic: MB/s inbound outbound Utillization Hourly: GB sent received Local Network Errors: 0ops transmit drop receive drop transmit errors TCP Retransmission segments retransmitted: 0ops retransmit ratio: 0%  应用监控 #  Prometheus # 监控, go实现 Grafana # 监控 Zabbix # 分布式监控 Nagios # 监控 Ganglia Zenoss Open-falcon emq # mqtt broker, erlang开发, 管理控制台  APM #  # Application Performance Management SkyWalking CAT Jaeger Pinpoint Zipkin Dapper # C#  Mysql #  总览 Services: 38 Min MySQL Uptime: 20 hours Max MySQL Uptime: 2.</description>
    </item>
    
    <item>
      <title>Eclipse</title>
      <link>https://example.com/docs/computer/tool/eclipse/</link>
      <pubDate>Thu, 11 Oct 2018 18:33:08 +0800</pubDate>
      
      <guid>https://example.com/docs/computer/tool/eclipse/</guid>
      <description>方案 #  user library发布 项目右键 -&amp;gt; properties -&amp;gt; Deployment Assembly -&amp;gt; add -&amp;gt; javaBuild Path Entries中选择发布包 tomcat设置发布到外部 new server -&amp;gt; 直接finish 右键server -&amp;gt; open 修改server location -&amp;gt; use Tomcat installation 修改server location -&amp;gt; deploy path为webapps 修改TimeOuts -&amp;gt;所有时间为1200 java版本 window -&amp;gt; preferences -&amp;gt; java -&amp;gt; compiler window -&amp;gt; preferences -&amp;gt; java -&amp;gt; installed JREs 编码 general -&amp;gt; workspace Text file encoding general -&amp;gt; content types Text -&amp;gt; java source file defalt encoding输入UTF-8并点击update 快捷键 general -&amp;gt; editors -&amp;gt; keys content assist # 代码提示 word comletion # 代码补全  插件 #  market place http://www.</description>
    </item>
    
    <item>
      <title>VIM</title>
      <link>https://example.com/docs/computer/tool/vim/</link>
      <pubDate>Thu, 11 Oct 2018 18:31:16 +0800</pubDate>
      
      <guid>https://example.com/docs/computer/tool/vim/</guid>
      <description>编译 #  --with-features=tiny # 只包含最基本功能。small, normal, big, huge, :h feature-list查看  命令 #  vim -u NONE -N # -u NONE 不加载配置文件和插件，并进入vi兼容模式 -u code/essential.vim # 加载指定配置文件 -N set nocompatible # 不进入vi兼容模式 --version # 可查看特性  mode #  普通模式 插入模式 可视模式 v/V # 面向字/面向行 可视模式 &amp;lt;C - v&amp;gt; # 面向块 可视模式 gv # 重选上次选区 o # 切换到选区的开头, 再按切换回尾端　替换模式 R 命令行模式(Ex命令) : # 可视模式中选定范围，切换到命令行时，自动输入range&#39;&amp;lt;,&#39;&amp;gt;代表选中区 操作符待决模式 # operator 与 motion之间的空闲时期 # 两个字符的operator, 字符间的空闲时期不是该模式，是命名空间，是普通模式的扩充 # 有了这个模式，能创建自定义映射项来激活或终结操作符待决模式，就可以自定义operator和motion 选择模式 # 类似windows中选中 &amp;lt;C - g&amp;gt;在可视和选择模式切换 历史 q: # 命令历史 q/ # 搜索历史  operate #  思想 {operator}{motion} {operator}{text-objects} shortcut key ctrl + c # 同Esc motions .</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://example.com/docs/ops/docker/</link>
      <pubDate>Thu, 11 Oct 2018 18:18:21 +0800</pubDate>
      
      <guid>https://example.com/docs/ops/docker/</guid>
      <description>基础 #  介绍 基于linux LXC，可以实现虚拟化 优点 低成本、高利用率、充分灵活、动态调度 核心网的最终形态 镜象网站 https://hub.docker.com/ 目录 /var/lib/docker 配置 /etc/sysconfig/docker # /etc/init.d/docker.conf OPTIONS=&#39;--selinux-enabled --log-driver=journald --insecure-registry 45.55.56.16:5000 --dns 8.8.8.8&#39; DOCKER_CERT_PATH=/etc/docker  命令 #  docker -h version search mysql # 搜索镜像 pull centos:7 # 下载镜像 centos:latest outrun11/test:nginx1 image ls pull rm images centos # 本地镜象列表 rmi centos:latest # 删除镜象 container run # 新建容器 --name # 显示名 -t # 伪tty, -i 交互的 -rm=true # 执行完后删除 -v /etc/:/opt/etc/ # 挂载本机/etc到容器/opt/etc, /etc/:/opt/etc/:ro 只读挂载, /etc/ 对外共享/etc -p 1234:80 # 端口映射本机1234端口到容器80 --volumes-from etc_share # 使用另一个容器对外共享的磁盘 -d # 后台运行 --link redis_server:redis # 连接容器的redis命令 -w /var/node # 当前工作目录 -e NODE_ENV=&#39;&#39; # 环境变量 --net=bridge # 网络模式，bridge使用虚拟网桥docker0, host共享主机命名空间, container与已存在的一个容器共享命名空间, none关闭网络功能, overlay --name nsqd -p 4150:4150 nsqio/nsq /nsqd # 端口 -it centos /bin/bash # 启动容器, 执行bash b15 /bin/echo &#39;hello&#39; # 启动容器 -it --rm=true --name=ls-volume -v /etc/:/opt/etc/ centos ls /opt/etc # 创建共享 -it -p 1337:1337 --name=etc_share -v /etc/ centos mkdir /etc/my_share &amp;amp;&amp;amp; /bin/sh -c &amp;quot;while true; do echo hello; sleep 1; done&amp;quot; # 持续运行 -it --rm=true --volumes-from etc_share --name=ls_etc centos ls /etc # 使用共享 exec # 已有容器中运行 -i -t ls start 026 # 启动已建立的容器, id可以只输入前几位 cp 026e:/docker/file /local/file stop 026 restart 026e attach 026 # 进入容器运行命令行, 可显示日志 kill 026e ps -a # 容器列表 rm # 移除容器 docker rm docker ps -aq # 移除所有未运行的容器 rm -f 026 login build .</description>
    </item>
    
    <item>
      <title>Mongodb</title>
      <link>https://example.com/docs/db/mongodb/</link>
      <pubDate>Thu, 11 Oct 2018 16:00:15 +0800</pubDate>
      
      <guid>https://example.com/docs/db/mongodb/</guid>
      <description>特点 #   数据结构json(bson) 易写入，易修改 c++编写 分布式 介于关系数据库 和 非关系数据库之间 查询语句强 支持索引 bson格式  注意 #   document不能大于4Mb 可以非安全模式异步马上成功 每个连接用队列存储命令  数据结构定义 #   collection # 表 document # 记录 field(key, value) # 字段(field)与值(value) 与关系型数据库的区别 document中的field不要key俱全或一样 find()命令查询  bson的数据类型 #   ＃bson 是json的扩展 # 增加了数据类型 # 把json数据转换成二进制码存到文件 null boolean undefined 数组 # 如{gps: [20, 56]} 32位和64位整数 # shell中不支持 ## node.js python java等高级语言的驱动中支持 64位浮点 # shell使用的全是这种类型, 如{x:3.14} utf-8 # 字符串类型 ObjectID Date # 如{x:new Date()} 正则 # 如{x:/uspcat/i} javascript块代码 # 如{x:function(){}} ## 相当于存储过程 内嵌文档 # 如{x: {xx: &amp;quot;a&amp;quot;}} 二进制 # shell中不能使用  ObjectId #   大小 12字节 显示为24个十六进制字符 # 空间换时间的思想 细节 前4字节是unix时间戳 后3字节集群machine hash 后2字节pid 后3字节inc自增计数器, 在前面都相等时全局自增  命名 #   数据库与集合名 不能是空字符串 特殊字符 &#39; (空格) , $ / \ \0 应该全小写 小于64字节 数据库名不与保留库名相同，如 admin, local, config 集合名 db-text合法，但不能db.</description>
    </item>
    
    <item>
      <title>Postgre SQL</title>
      <link>https://example.com/docs/db/postgresql/</link>
      <pubDate>Thu, 11 Oct 2018 15:34:29 +0800</pubDate>
      
      <guid>https://example.com/docs/db/postgresql/</guid>
      <description>命令 #  initdb # 初始化数据库 --locale en_US.UTF-8 -D &#39;data&#39; postgres # 启动数据库 -D 目录 -p 6543 pg_ctl start # 控制数据库: start, stop等 -D data -l a.log postmaster -D /data psql -d db1 -h localhost -p 5432 -U 用户名 -W # 强制要求验证密码 -f 导入sql命令文件, 或者在末尾加 &amp;lt; a.sql 来导入 -L 导出日志文件 o-&amp;gt; psql -U outrun -f pg.sql db1 # 导入数据 pg_dump # 导出数据库 -f # 指定文件 -U # 用户 -E UTF8 # 编码 -h localhost -n public # 指定schema -a # 只导数据，没有schema -F t # 压缩成tar o-&amp;gt; pg_dump -U outrun -f pg.</description>
    </item>
    
    <item>
      <title>Java响应式编程</title>
      <link>https://example.com/docs/pl/java/java_reactive/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/java/java_reactive/</guid>
      <description>Reactor #  RxJava #  Vert.x #  </description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://example.com/docs/middleware/nginx/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://example.com/docs/middleware/nginx/</guid>
      <description>基础 #  结构 一个主进程(root权限运行)和多个工作进程(普通权限运行) 优点 异步非阻塞 非常稳定 反向代理 后端服务io能力不高，nginx buffer http请求直到完整，再发送到后端。同样buffer响应 相对apache 轻量 apache阻塞 占资源低 模块化设计 社区活跃, bug少 多进程模型 使用epoll 多worker处理，业务阻塞时切换调度, 结束阻塞时分配 模块 handler filter upstream load-balance 功能 http 可以保持session， 相同的ip分配到同一个服务器上 缓存静态页面到内存，建立索引与自动索引 反向代理 负载均衡 模块化 过滤器 gzipping, byte ranges, chunked responses, SSI-filter 支持SSL与TLS SNI imap/pop3代理 命令 nginx -c /etc/nginx/nginx.conf nginx -s quit nginx -s stop nginx -s reload # 重载设置 ## service nginx reload nginx -v # 查看版本 ## -V nginx -t [-c nginx.</description>
    </item>
    
    <item>
      <title>Nodejs</title>
      <link>https://example.com/docs/middleware/nodejs/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://example.com/docs/middleware/nodejs/</guid>
      <description>基础 #  特点 commonJS规范 javascript书写(v8引擎) js设计之初就可以运行在后端 v8 成熟的事件驱动模式 没有i/o库, 没有历史包袱 v8性能好 单线程 不用在意多线程状态同步(没有死锁, 没有上下文切换) 无法利用多核, 错误时应用退出，计算密集时无法调度 # child_process解决 事件驱动(event-driven), 回调 event loop [while(true)] -&amp;gt; watcher -&amp;gt; handles watcher产生事件后, event loop取到并执行其handle(回调函数) event loop每一周询问多个watcher是否有事件 event loop中没有watcher时进程退出 http模块就是启动了一个watcher,所以执行后进程不结束 其它watcher有 timer, fs, udp/req, process 不同操作系统中event driven的实现: windows: IOCP Linux: epoll Mac:kqueue 非阻塞io(non-blocking i/o model) io与数据处理分离（所以必须异步） 线程池结合event-driven实现 异步io go语言有协程(coroutine)而node.js没有，协程可以同步式编程 # 有第三方协程模块 promise(commonJs的规范, 其实现有whenJs, Q) # 书写难度降低 eventProxy # 朴灵 async/step commonJS 模块 var math = require(&#39;math&#39;) # 缓存优先，核心模块优先。依次找.</description>
    </item>
    
    <item>
      <title>Spring Cloud</title>
      <link>https://example.com/docs/middleware/distributed/spring_cloud/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://example.com/docs/middleware/distributed/spring_cloud/</guid>
      <description>亿级流量 #  流量接入层 #  二级域名 泛域名 A记录 dns解析 udp 向网关请求dns解析 httpDNS 用ip请求http服务, 返回域名解析的ip 因为用ip请求，适合app，不适合网页 lvs + keepalive # 多lvs时用dns负载 nginx openresty kong 动静分离 cdn dns动态域名解析 cdn分发服务 源服务拉取FastDFS CDN节点分发  WEB服务层 #  webflux 不基于重量的servlet标准 基于netty  Eureka #  使用 @EnableEurekaServer application.properties eureka.client.register-with-eureka=false # 是否注册自己 eureka.client.fetch-registry=false # 是否拉取eureka eureka.client.service-url.defaultZone=http://localhost:7900/eureka/ # 设置注册中心的URL eureka.instance.hostname=euk1.com spring.application.name=EurekeServer # eureka集群中各节点要同名 行为 register # 注册 renew # 通过心跳, 默认30s。三次失败删除实例 fetch registry # 拉注册的信息 cancel # 发取消请求，删除实例 time lag # 同步时间延迟 communication mechanism # 通讯机制，默认jersey和jackson 功能 唯一标识 # service id 主机名:application.</description>
    </item>
    
    <item>
      <title>Bootstrap</title>
      <link>https://example.com/docs/middleware/library_frontend/bootstrap/</link>
      <pubDate>Thu, 11 Oct 2018 09:39:11 +0800</pubDate>
      
      <guid>https://example.com/docs/middleware/library_frontend/bootstrap/</guid>
      <description>介绍 #  在jquery基础上的组件框架  移动 #  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt;  css #  全局 container # div, 唯一包裹容器 container-fluid # 占全部视口 栅格 # 必须放在row内 col-xs-1 # 适用于大于等于分界点的屏幕 ## 大于12的最后那个col另起一行排列 # xs &amp;lt; 768px 宽度, container 最大宽度: 自动 # sm &amp;gt;= 768px, 750px # md &amp;gt;= 992px, 970px # lg &amp;gt;= 1200px, 1170px col-md-offset-4 # 向右偏移4 col-md-pull-9 # 向后推9, 改变元素的顺序 col-md-push-3 o-&amp;gt; mixin make-row 如 .wrapper {.</description>
    </item>
    
    <item>
      <title>Threejs</title>
      <link>https://example.com/docs/middleware/library_frontend/threejs/</link>
      <pubDate>Thu, 11 Oct 2018 07:58:16 +0800</pubDate>
      
      <guid>https://example.com/docs/middleware/library_frontend/threejs/</guid>
      <description>介绍 #  协调程序加载项的类库  使用 #  var preload = new createjs.LoadQueue(false, &amp;quot;assets/&amp;quot;); var plugin= { getPreloadHandlers: function(){ return{ types: [&amp;quot;image&amp;quot;], callback: function(src){ var id = src.toLowerCase().split(&amp;quot;/&amp;quot;).pop().split(&amp;quot;.&amp;quot;)[0]; var img = document.getElementById(id); return {tag: img}; } } } } preload.installPlugin(plugin); preload.loadManifest([ &amp;quot;Autumn.png&amp;quot;, &amp;quot;BlueBird.png&amp;quot;, &amp;quot;Nepal.jpg&amp;quot;, &amp;quot;Texas.jpg&amp;quot; ]);  api #  涉及dom #  属性 window.innerWidth window.innerHeight 事件 window.addEventListener(&#39;resize&#39;, onWindowResize, false); function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); controls.</description>
    </item>
    
    <item>
      <title>Angular</title>
      <link>https://example.com/docs/middleware/library_frontend/angular/</link>
      <pubDate>Thu, 11 Oct 2018 07:47:51 +0800</pubDate>
      
      <guid>https://example.com/docs/middleware/library_frontend/angular/</guid>
      <description>介绍 #  google发布 提倡SPA(Single Page Apps), 运行快，一次加载 mvvm  特点 #  前端mvc 双向数据绑定 指令和语义化标签 模块化工具 依赖注入 html模板 常用工具封装，如$http $cookies $location  directive #  内置 ng-app # 声明app名, 在最外层 ng-submit # &amp;lt;form ng-submit=&amp;quot;submit()&amp;quot;&amp;gt; ng-controller ng-repeat # $index返回当前引用的元素序号，$first, $middle, $last 返回布尔值 ng-model # 绑定当前元素的值 ng-click ng-eventhandler=&amp;quot;expression&amp;quot;类的指令可以在所有浏览器中有相同的行为，angular将会屏蔽差异性 不会在全局命名空间中进行操作，指定的表达式只能访问元素控制器作用域范围内的函数和数据 ng-bind ng-change &amp;lt;form ng-submit=&amp;quot;aaFunc()&amp;quot;&amp;gt; # 会阻止浏览器默认的提交操作 ng-dblclick ng-show ng-hide ng-class # 可以是类名字符串，空格分隔，可以是类名数组，可以是类名到布尔值的映射 ng-class=&amp;quot;{true: &#39;active&#39;, false: &#39;inactive&#39;}[isActive]&amp;quot; ng-class=&amp;quot;{&#39;selected&#39;: isSelected, &#39;car&#39;: isCar}&amp;quot; ng-style # templete中写css不好维护 ng-src=&amp;quot;/images/cats/{{favoriteCat}}&amp;quot; # src，href属性中简单使用templete,由于浏览器优先并行加载图片和其它内容,angular没有机会拦截到数据绑定请求，所以无法运行 ng-href ng-options &amp;lt;select ng-model=&amp;quot;x&amp;quot; ng-options=&amp;quot;(m.</description>
    </item>
    
    <item>
      <title>Jquery</title>
      <link>https://example.com/docs/middleware/library_frontend/jquery/</link>
      <pubDate>Thu, 11 Oct 2018 07:34:03 +0800</pubDate>
      
      <guid>https://example.com/docs/middleware/library_frontend/jquery/</guid>
      <description>对象命名方式 #  var $a = $(&amp;quot;#inputID&amp;quot;);  选择器（选择多个时形成数组） #  基本选择器 $(&amp;quot;#inputID&amp;quot;); # id选择 $(&amp;quot;input&amp;quot;); // 标签名,默认获取第一个 # 标签名选择 $(&amp;quot;.className&amp;quot;); // 按样式名定位 # 样式名选择 $(&amp;quot;#div1ID,.myClass,p&amp;quot;); # 选择多个 $(&amp;quot;*&amp;quot;); # 所有元素 层级选择器 $(&amp;quot;form input&amp;quot;) # form所有后代元素中input元素的个数 $(&amp;quot;form&amp;gt;input&amp;quot;) # form子元素中input元素个数，不包括下层元素 $(&amp;quot;form+input&amp;quot;) # form同级并且下面的第一个input元素 $(&amp;quot;form~input&amp;quot;) # form同级并且下面的所有input元素 子元素选择器 # 只选择一个 $(&amp;quot;ul li:first&amp;quot;) # ul中第一个子元素li $(&amp;quot;ul li:last&amp;quot;) # ul中最后一个子元素li $(&amp;quot;input:not(:checked)&amp;quot;) # input标签中所有未选中的元素 $(&amp;quot;table tr:even&amp;quot;) # 表格的奇数行（索引号为偶数） $(&amp;quot;table tr:odd&amp;quot;) # 表格的偶数行（索引号为奇数） $(&amp;quot;table tr:eq(1)&amp;quot;) # table中索引号等于1的行 $(&amp;quot;table tr:gt(0)&amp;quot;) # table中索引号大于0的行（不包括0） $(&amp;quot;table tr:lt(2)&amp;quot;) # table中索引号小于2的行（不包括2） $(&amp;quot;:header&amp;quot;) # 匹配如 h1, h2, h3之类的标题元素 内容选择器 $(&amp;quot;div:contains(&#39;Join&#39;)&amp;quot;) # div 标签的html()中包含&#39;Join&#39;字符串的元素 $(&amp;quot;p:empty&amp;quot;) # p 标签的html()的内容为空的元素 $(&amp;quot;div:has(p)&amp;quot;) # div标签中包含p标签的该div标签 $(&amp;quot;p:parent&amp;quot;); # 非空的p标签元素，即p为父元素 可见性选择器 $(&amp;quot;tr:hidden&amp;quot;) # 查找隐藏的tr元素，如&amp;lt;tr style=&amp;quot;display:none&amp;quot;&amp;gt; &amp;lt;td&amp;gt;Value 1&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; $(&amp;quot;tr:visible&amp;quot;) # 查找可见的tr元素 属性选择器 $(&amp;quot;div[id]&amp;quot;) # 含有id属性的div元素 $(&amp;quot;input[name=&#39;newsletter&#39;]&amp;quot;) # 所有name属性是newsletter的input元素 $(&amp;quot;input[name!</description>
    </item>
    
    <item>
      <title>React</title>
      <link>https://example.com/docs/middleware/library_frontend/react/</link>
      <pubDate>Thu, 11 Oct 2018 07:32:08 +0800</pubDate>
      
      <guid>https://example.com/docs/middleware/library_frontend/react/</guid>
      <description>介绍 #  facebook推出的用于build user interfaces 的类库  使用 #  o-&amp;gt; webpack # webpack.config.js var webpack = require(&#39;webpack&#39;) module.exports = { devtool: &#39;inline-source-map&#39;, entry: [&#39;webpack/hot/dev-server&#39;, __dirname + &#39;/app/main.js&#39;], output: { path: __dirname + &#39;/build&#39;, filename: &#39;bundle.js&#39; }, module: { loaders: [ { test: /\.(js|jsx)$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, } ] }, plugins: [ new webpack.HotModuleReplacementPlugin(), new webpack.DefinePlugin({ &#39;process.env&#39;: { NODE_ENV: JSON.stringify(&#39;production&#39;) } }) ], devServer: { contentBase: __dirname + &#39;/build&#39;, historyApiFallback: true, inline: true, port: 3031, } } # index.</description>
    </item>
    
    <item>
      <title>Infomation</title>
      <link>https://example.com/docs/misc/infomation/</link>
      <pubDate>Wed, 10 Oct 2018 20:56:27 +0800</pubDate>
      
      <guid>https://example.com/docs/misc/infomation/</guid>
      <description>信息公布 #  新资讯 hackernews infoq v2ex freebuf 36氪 http://tech.meituan.com/ # 美团tech http://www.yinwang.org/ https://yinwang0.wordpress.com/ # 王垠 https://softwarefoundations.cis.upenn.edu/ # pl基础 https://bbs.pediy.com/ # 看雪论坛 http://a.haskellcn.org/study # 廖雪峰blog http://calvin1978.blogcn.com/articles/javabookshelf.html # 江南白衣的书架 大前端 http://harttle.com/ # harttle博客 http://www.cnblogs.com/iamzhanglei/ # 当耐特前端 资料 http://www.linuxidc.com # linux资讯、书 java1234.com # pdf书籍资源 https://www.jiumodiary.com/ # 鸠摩搜书 https://z-lib.org/ # 最大eboot库 问答 quora stack overflow 知乎 segmentfault 框架 https://github.com/sindresorhus/awesome 各技术框架 github.com search &#39;stars:&amp;gt;1000&#39; # github星项目 http://a.haskellcn.org/study # haskell书目录 查询 http://www.123cha.com/alexa/ # 网站排名查询 天眼查 乌云网 # 白帽漏洞  做题 #  http://www.</description>
    </item>
    
    <item>
      <title>English</title>
      <link>https://example.com/docs/misc/english/</link>
      <pubDate>Wed, 10 Oct 2018 20:53:25 +0800</pubDate>
      
      <guid>https://example.com/docs/misc/english/</guid>
      <description>发音 #  spelling and numbers Acronym ibM, miT, ph.D mbA lA iQ revP ciA fbI coD soS xyZ Spelling boX cooK wiLsoN sentence stress with descriptive phrases It&#39;s SHORT. It&#39;s a short NAIL It&#39;s CHOCOLATE. It&#39;s a chocolate CAKE. contrasting description and a set phrase It&#39;s a short NAIL. It&#39;s a FINGERnail It&#39;s a chocolate CAKE. It&#39;s a PANcake T,D,S or Z + Y T + Y = CH what&#39;s your name can&#39;t you do it?</description>
    </item>
    
    <item>
      <title>人员</title>
      <link>https://example.com/docs/design/people/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/people/</guid>
      <description>人, 事, 团队 #  人 业内口碑 成分 技能，素质，精神 行动 感性，理性，惯性 发展 上限 下限 成本 低成本召回 事 知原理 是什么，为什么，怎么样，拆解 事与团队 事造就团队，好团队不一定出好成果 团队 存在合理性 有目标，成员能力认可，成员感性认可 小精英团队，才能解决问题 分配事 因特质分配，如稳定，峰值，沟通 成果评价 产出判断 分配利益和荣耀 时间和代码量评价不了程序员的工作, 可以匿名互评(口碑) 团队提升 培训无意义，自觉成长 成员 项目经理 设计 开发 测试人员 运维 系统工程师 设计、实现产品 数据分析师 技术总监 架构师 权衡, 出方案  职工 #  态度 把握分寸 靠谱(事事有交代) 负责(顾全局) 主动 超出预期 负责态度, 提高团队效率，而非自己效率 # 严肃判断 沟通 及早沟通、同步 文档 &amp;gt; 邮件 &amp;gt; im &amp;gt; 电话 # 即时性相反 留响应时间, 同组 -&amp;gt; 跨组 -&amp;gt; 跨部门 -&amp;gt; 跨公司 明确通知人时, 邮件, im特殊指定 文档 周报 文档简单有计划，为节省向别人解释的时间 建设性意见(提选择题) 只交“产品”: 背景清晰, 扼要, 完整, 引入独有经验  工程师 #  本质 解决问题 普遍问题 技能: 工具使用(写工具), 表面学习, 笨办法, 不会读文档, 只会知识迁移 设计: 不知经典设计, 不知设计哲学, 不知目的, 无法反应需求, 没有品位, 读不懂设计 知识更新: 学不动, 基础差(用二手资料), 无认知体系(认为都是新东西), 重复学习无用知识 沟通: 不专业(不用专业名词), 不主动, 不沟通对方, 不抓重点, 思路不连贯, 阅历不足(不会写文档), 不问为什么 能力 特点 知识、经验、技能、协作 # (1+天赋)x知识x工程习惯 犯错(多做多错) 方法 抽象 # 设计就是从升维中拆分和简化 沉淀 # 没有沉淀的学习不好回顾修改, 像没有测试的代码 品位 优点，缺点 # 找潜质, 并非此长彼短，是两个维度,有一定抑制作用 创造力，纪律 勤奋，聪明 稳定，峰值 深度，速度 细节，大局 开发 考虑工作的复用性 加入项目，需要可对所有代码修改 善用工具 自己的事主动跟进 owner 自我负责, 自我驱动, 持续改进 能部署, 能手工排查问题，手工修复数据, 开发调试工具, 数据修复工具 模块职责单一, 明白当前负责和极限性能 能降级, 知道下游调用和降级影响。了解上游依赖和上游降级影响 配好log、监控、告警, 告警及时响应  架构师 #  场景/用例/问题 -&amp;gt; 方案/方案权衡 -&amp;gt; 落地路径 分级 初级 代码 命名：精确性、简单性、一致性、区别性、业务性 逻辑: 缩进、换行 代码体积: 行、方法、类 抽象能力 边界 中级 流量、并发等 高级 理解业务核心价值、业务实现方式 业务技术支撑方式 业务趋势  艺术家 #  岗位 #  项目经理(pm, project manager) 技术经理(tm, technical manager) 产品设计经理(pdm, product design manager) 运营经理(pom) 测试经理(qam) 客服经理(csm, customer success manager) 开发组长(tl, team leader) 架构师(pa) 开发工程师(de, development engineer) 数据库管理员(dba, database administrator) 系统管理员(sa) 界面设计师(ui, user interface) 用户体验设计师(ue, user experience) 产品运营师(po, product operator) 产品设计师(pd, product designer) 测试工程师(qa, quality assurance) 配置管理员(pcm) 发布员(pb) 软件过程专员(sqa, software quality assurance) 运维工程师(sre, site reliability engineer)  招聘 #  双向选择 精确率&amp;amp;召回率 方面 沟通 喜欢技术，逻辑能力, 编码能力, 设计能力 基本概念, 边界考虑充足, 进阶答案, 衍生问题的解决 是否有自己思考，对自己负责  </description>
    </item>
    
    <item>
      <title>组织</title>
      <link>https://example.com/docs/design/organize/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/organize/</guid>
      <description>组织 #  系统划分与组织划分 康威定律 系统架构是公司组织架构的反映 按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本 沟通出现问题，考虑调整组织架构 在该拆分时拆分 为了简单 开发和运维分离 业务和基础架构分离 无状态和有状态分离 业务间乘法(正交)而非加法 # 升维的特点, 正交叠加 多层抽象, 不断隐去底层(约定大于配置) # 升维的特点, 抽象观察  管理 #  提供 问题: 定义, 分解, 什么是问题, 前人如何处理 # 工程为解决问题 思考: 方向, 为了解决问题, 找到关键, 找到应学知识 # 创造性工作要思考 体系: 领域的体系, 领域体系形成原因, 为了高效思考和学习, 有体系的做事 参考: 参考书籍, 如何筛选, 如何搜索, 社区 不提供 知识点, 答案, 规定, 代码 分任务 出问题，写相关文档 砸需求，看弹性 任务列表: 难度, 优先级, 排期, 地平线目标, 现状, wishlist nice to have给新人  项目管理 #  目标 完成不动点需求 正交、简单(要求想清楚、灵活) 维护概念完整性、一致性(纯洁) 术语不变、不矛盾、不重叠 考虑上下游 问题 开发碎片化(重复的代码、由于不知道或怕改错) review 持续集成(*lint, CI/CD) 早合并 自动构建、测试 效率 沟通 设计 开发 方案 需求池 优先级、排期、checklist、周update confluence jira: 空间, 优先级, 追踪, assign, 评论 史诗(epic)、故事(story)、任务、子任务、冲刺 敏捷: 周冲刺, hackson 集体review block by 组织 负责人 小组长 owner 产出 评价程序员 时间，代码量不合适, 口碑、解决问题。加班是能力问题，效率第一 总会犯错，多做多错 估期不准，赶期质量不行，不怕delay owner, 鼓励设计、技术自由(开发人员诉求技术，厌倦业务) 良心，内驱力 产品 需求磨砺核心业务资产 事情成就精英团队，而非精英团队成就事  迭代方法 #  极限编程（XP） # eXtreme Programming 4大价值 沟通：鼓励口头沟通，提高效率 简单：够用就好 反馈：及时反馈、通知相关人 勇气：拥抱变化，敢于重构 5个原则 快速反馈 简单性假设 逐步修改 提倡更改（小步快跑） 优质工作（质量是前提） 5个工作 阶段性冲刺 冲刺计划会议 每日站立会议 冲刺后review 回顾会议 结对编程 PDCA循环质量管理 Plan, Do, Check, Act FMEA 分析潜在的失效模式  工程模型 #  历史 程序设计阶段1946-1955 节省空间 软件设计阶段1956-1970 硬件发展，软件危机 软件工程阶段1970-今 组件化  瀑布模型 #  # 每一次执行工作流的深度不同 可行性分析 实现会不会复杂，尽量简单 需求分析 分类 生存点 痒点 兴奋点 # 不会按时交付（只完成主要，然后延期，用户测试） 客户沟通，同类产品比较，行业标准 功能 正确, 可行, 必要, 有序, 明确, 一致 性能 完善, 简短 设计 先出成果再优化 任务分配(进度条) 命名标准 文档 可移植、可维护易扩展 排期 实现 测试 运维  螺旋模型 #  # 边分析边开发边交付（一环一环向目标实现） 敏捷开发 项目面临的问题 人员流动 代码维护 种类 极限编程(xp) 特点 简易、交流、回馈 方法 解耦低速设备，提高响应速度 迭代 迭代周期 一个迭代周期中不新添加需求 一个迭代周期中包含多次迭代 一个阶段的结束称之为里程碑 初始化阶段增量 项目启动 建立业务模型 定义业务问题域 找出主要风险因素 定义项目需求的外延 创建业务问题域的相关说明文档 细代阶段增量 高层的分析与设计 建立项目的基础框架 监督主要的风险因素 制订达成项目目标的创建计划 构建阶段增量 代码及功能的实现 移交阶段增量 向用户发布产品 beta测试(alpha测试是内部测试， beta测试是用户测试) 执行性能调优，用户培训和接收测试  转型 #  流程 (2-4)周实地调研痛点 确定目标 要求: 领先、高效、高品质 列出实际问题 评估 cmmi(敏捷成熟度模型): 代码、架构、工具 实施变化 战略 试点团队(灰部应用于组织): 完成产品指标  工程工具 #  控制面板 项目 分配给我 活动日志 人员 团队 权限 项目 配置 事务 类型 布局 # 列表项，详细项 时间追踪 配置链接关系 优先级 解决方案 工作流 # 对不同项目和事务类型, 配置状态转换图 页面方案 # 对不同项目和事务类型，不同状态转换时，配置字段布局 自定义字段 # 对不同页面 权限 权限 角色、应用程序、组、用户、项目负责人、当前经办人、自定义字段值等 事务(issue) 状态 todo, 正在进行, done 打开, 已重新打开, 已解决, 已关闭 backlog, in review, selected for development, building, build broken waiting for support, respond to customer, escalate, cancel, canceled, done waiting for approval, work in progress [工作流状态] 类别 待办 正在进行 完成 无类别 名称 长篇故事(史诗) 故事 分类: 需求, 设计 验收条件 任务, 子任务, 缺陷, 新增功能, 改进 服务请求, 服务请求审批, 问题, 事件(系统中断) 订单 全局顺序 属性 经办人，报告人 优先级 highest, hign, medium, low, lowest 链接 clones is cloned by duplicates is duplicated by blocks is blocked by causes is caused by relates to csv导入 筛选器 未清, 我发起, 已完成, 最近 活动 评论, 历史, 工作日志 冲刺(sprint) 状态 待办, 进行, 完成 发布 版本 报告(report) 敏捷 燃耗图, 燃尽图, 版本报告, 长篇故事报告, 控制图，长篇故事燃尽图, 发布燃尽图 冲刺报告, 速率表 累积流程图 事务 饼图, 单次分组, 解决时间, 平均周期, 事务持续时间, 已创建已解决对比, 最新创建 预测 版本工作量, 人员工作量, 时间跟踪 其它 工作负荷 服务台(itsm) 分类 对内 对外 途径 邮件, 帮助中心, 小程序 队列 分类 状态workflow 经办人 客户 报告 系统 审计日志  开发模型 #  TDD(test-driven development) 先单元测试 BDD(behavior-driven development) TDD的变种, 重点描述行为 面向需求 组织上小而全 开发全栈减少沟通 设计上面向领域 </description>
    </item>
    
    <item>
      <title>行业</title>
      <link>https://example.com/docs/design/biz/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/biz/</guid>
      <description>云 #  本质 批发转零售 帮助别人成功而成功 产品型转服务型 优势 轻，方便 全 可计算 现象 外包被淘汰 行业 OS of business 功能 产品功能，样板 开发体验，文档 组件收费，容量收费，节省的成本收费 数据直接做决策 分类 service # 基础服务 plugins # 基础服务组合 app # plugins组合  产业互联网 #  供应链 #  为什么 大厂核心 各节点(库存)周转 是什么 资源 -&amp;gt; 渠道 -&amp;gt; 用户 反馈用户真实需求 上游关注制造业 下游关注erp 批量(精), 个性化(敏) 物流, 资金流(现金流), 信息流 库存管理 应对变化(保质期) 求零库存 供应商 评级 物流, 成本 难点 打通 怎么样 成本、利用率 可靠性, 反应力, 柔性(补错) 感知、预测 赋能 重点 按时制造 难点 协调(协议) 步骤 单品上下游延伸  AI #  优化、预测 拟合函数, 高阶微积分, 梯度下降  媒体 #  场景控制 3CAD character camera control art direction 特效 会场散射光束（博物馆） 雾中焦点的竖光（saber的剑） 画线的光点（最终幻想） 密集的星星，远近缩放，光圈(tree.</description>
    </item>
    
    <item>
      <title>身体</title>
      <link>https://example.com/docs/design/body/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/body/</guid>
      <description>造型期 #  体态 高低肩 骨盆前倾 体能 心肺 变速有氧：4、6、8各2min， 30min以上 力量 核心训练  健身计划 #  目标 指导 FITT Frequency: 一周3-5次 Intensity: 有氧 心率: 123-142 无氧 动作 间歇 个数 重量 Time: 60min力量 + 30min有氧 Type: 热身 抗阻力训练 拉伸 阶段 适应期(1-2月) 心肺功能: 功率 核心力量 保护腰：呼吸 + 静态 内脂 力量训练 动作规范 蹲、推、拉、举、旋转 进阶期(2-3月) 消耗 &amp;gt; 摄入 七大肌肉群：胸、肩、背、腹、腿、臀、手臂 三分化、四分化 爆发力  </description>
    </item>
    
    <item>
      <title>驱动</title>
      <link>https://example.com/docs/design/drive/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/drive/</guid>
      <description>学习 #  计划 为什么 有全局, 有方向 平时活动与目标联系起来 轻重有序 磨炼意志(适应变化, 抗干扰) 养成习惯(抗干扰不费意志) 怎么样 全面(考虑娱乐和休息) 简单明确、具体、适当、突出重点 时间科学, 遵守作息时间 及时调整 预习 为什么 上课时：扫除知识障碍、针对性解决问题、笔记有针对性 提高自学能力 改变被动局面，成为良性循环 是什么 初步理解 关联旧知识 找不理解 做笔记和习题 怎么样 先粗读, 再反复细读 先读最困惑点 问为什么 请教别人 实践 笔记 重点、结构、摘要 分类 问题 查阅资料 理解思路 逐步提高 由点到面，由浅入深 学习 怎么样 集中注意 获取知识主动权 作者思路，比较思维方法 方法 分析综合法、归纳演绎法、比较分类法 规律 同一律、矛盾律、排中律 # 形式逻辑学 对立统一、量变到质变、否定之否定 # 辩证逻辑学 学科特点 理科: 逻辑性，抽象思维 文科: 知识有独立性，形象思维 教师特点 保持连续性，不中断钻牛角尖 笔记 思维方法、过程、结果 完整简洁 当堂掌握 领会、巩固、运用 重点是认知过程而非结论 复习 贵在及时 怎么样 尝试回忆 读原文 整理笔记 参考资料 系统复习 为什么 牢固、完整 系统、实用 怎么样 之前之后回忆 有重点阅读 熟记 整理笔记 练习 记忆能力 有记忆意识 理解后记忆 艾宾浩斯曲线 过度学习来记忆 分散记忆好于集中记忆 先整体理解, 后分段记忆, 最后综合复习 多感官 思维能力 积极思维状态 基本思维方法 分类、抽象概括 系统化, 使用时具体化 思维形式 整体思维 相似思维 逆向思维 创造思维  读源码 #  目标 了解思路 难点 理解非自己的思路 了解数据结构、设计模式 原则 跑不起来不读 带目的性读，解决问题就好 一条线索到底 无关细节略过 画类图、类调用泳道图  高效模型 #  人 #  组织 简单，分离 管理 无为 沟通 在线文档 &amp;gt; 邮件 &amp;gt; im &amp;gt; 口头/电话 多方口头时，要维护自有重点 谈判 抛回对方问题，使其思考，后做到已方稍强  事 #  计划 把握纲领，不能变 先核心再扩展 # 稳定隔离 第一性原理 做重要不紧急 边界分割 # 正交 拆分并只安排步骤 思考框架：现状、目标、实现路径 意义(目标导向)。通常是解决问题  拆分到最细节的方案, 分配到人、工作量、联调提测时间 迷雾即瓶颈 曼陀罗思考法 实行 原型 风险点 # 技术 只输出产品，电梯演讲(简单, 清晰, 轻松, 主线, 一套) 输入时保持输出 把控变化，提供适应方案 内部有 &amp;gt; 外部有 &amp;gt; 半成品 &amp;gt; 自实现 解耦低速设备 update全员参与, 或文档 灰度替换 总结 向流程和工具找问题</description>
    </item>
    
    <item>
      <title>代码</title>
      <link>https://example.com/docs/design/code/</link>
      <pubDate>Wed, 10 Oct 2018 17:40:53 +0800</pubDate>
      
      <guid>https://example.com/docs/design/code/</guid>
      <description>认知 #  原理 模拟执行 负担 概念量 封装粒度大 多态、运行时多态、静态多态 临时状态 用工作流, 而非队列 日志(event)搜索/集中/回放 抽出权限层 非轻量级 胶水层厚 无稳定方案, 复用困难 流程长度 最好 单线程 # 不插入行为 上下文集中 this.scene.commit()集中状态转移时间线 单一方式  原则 #  观念 KISS(keep it simple stupid) YAGNI(You Ain’t Gonna Need It) 取好名字占设计一半 约定大于配置 并发的世界，并发的软件 分布式的世界，分布式的软件 不可预测的世界，容错性强的软件 复杂的世界，简单的软件 代码即数据 物体上绑定行为数据 传递代码数据(函数一等公民) 防御性编程 接口前validator 启动时自检断言 异常处理 不可过度 设计 solid原则 单一职则(single responsibility) 一个类负责一个功能 开闭(open/closed) 对扩展开放，对修改关闭，如接口, 如数组扩展结构体状态 里氏替换原则(liskov substitution) 子类继承超类的所有 接口分离(interface segregation) 最小功能隔离 依赖反转(dependency inversion) 低层依赖高层, 具体依赖抽象 非侵入 # non-intrusion 将功能推入代码，而非代码拿到功能 代码实现接口，而非继承类 拆分 边界 正交 unix rules 模块化(modularity) # 模块由精心设计的接口连接 清晰化(clarity) # 可读性、可维护性 组合(composition) 分离(separation) 简单(simplicity) 节俭(parsimony) # 越小越好 透明(transparency) # log, tracing 鲁棒(robustness) 可展示(representation) # 逻辑简单，数据复杂 最小惊吓(least surprise) # 少打破用户预期 安静(silence) 修复(repair) # 产生足够报错 经济(economy) # 减少开发时间 生成(generation) # 避免手写, 用高阶抽象生成代码 优化(optimization) # 优化和收益平衡 分化(diversity) # 一开始设计不限制、优雅开放灵活 扩展(extensibility) # 协议可扩展 优化 需要时再优化，设计时考虑扩展性 dry(don&#39;t repeat yourself), 不可过度 找瓶颈 产出 设计清晰 选型简单 代码精炼 抽象优雅  设计 #  创建 factory, abstract factory # 工厂 builder # 构建者 prototype # 原型复制来产生对象 singleton # 单例 结构 adapter # 适配器 bridge # 抽象与实现分离 composite # 抽取公共行为 decorator # 装饰 facade # 外观。提供子类的默认视图 flyweight # 享元 proxy # 代理 行为 interpreter # 解释器 template method # 模板方法、泛型 chain of responsibility # 责任链 command # 命令 iterator # 迭代器 mediator # 消息传递中介 memento # 保存、恢复状态 observer # 观察者 state # 不同状态定义不同行为 strategy # 同行为的不同算法、替换算法 visitor # 访问者。抽象行为本身，不同访问对象不同行为 元素模式 抽象各模式成元素，简化表示 actor # 消息通信 reactor # 事件轮循，注册回调，如libevent proactor # 注册事件回调，os通知触发回调 惰性求值 链式定义(配方)，后自动触发(js tick调度)终止操作 dsl测试(如jasmine.</description>
    </item>
    
    <item>
      <title>工程</title>
      <link>https://example.com/docs/design/project/ddd/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      
      <guid>https://example.com/docs/design/project/ddd/</guid>
      <description>介绍 #  介绍 Domain-driven Design 针对传统软件开发流程（分析-设计-编码）各阶段业务割裂问题，一开始定义好领域 目标 维护概念完整性(纯洁)，避免语义泄露和腐化  概念 #  领域（Domain） 界限上下文（Bounded Context） 领域模型（Domain Model） 领域通用语言 分层架构 展示层、应用层、领域层、基础设施层 最佳实践 关联尽量少、尽量单项、尽量降低整体复杂度 实体（Entity） 领域中的唯一标识，属性尽量少 值对象（Value Object） 没有唯一标识，属性值不变 领域服务（Domain Service） 协调多个领域对象，只有方法没有状态 应用层服务、领域层服务、基础层服务 聚合、聚合根（Aggregate, Aggregate Root） 聚合定义了一组有内聚关系的对象集合，聚合根是对聚合引用的唯一元素 修改聚合必须在事务级别 70%的聚合只有一个实体, 30%有2到3个实体。 只有一个实体时，实体就是聚合根。多实体时思考哪个对象有独立存在的意义，且可与外部直接交互 工厂（Factory） 工厂模式 仓储（Repository） 持久化到DB，管理对象 只对聚合设计仓储  建模 #  重点 #  简单、容易、清晰 使用不动点 领域专注 聚合内强一致，跨聚合最终一致 内部概念完整一致(unification) 术语不变、不矛盾、不重叠  数据模型（DO） #  失血 DO和DAO无业务逻辑，纯数据 贫血 持久化逻辑在DAO中 充血 service很薄，持久化的逻辑在DO中，无DAO或与DO双向依赖 肿胀 无service，全部逻辑放DO  过程 #  分析模型 # 业务领域分析, 不考虑代码 问题 含意不完整，不可图形或文字表达，错误假设 会深入某细节 忽略某细节直到设计或实现, 如持久化、性能 目标 领域模型 架构设计 事件风暴 # 是开发建模，不是用户需求故事 准备 功能确认: 近期milestone 找正确的人: 领域专家, 前后端，架构师 引导者: 准备资料, 排程, 时间, 2/3时间预警 事件风暴 领域事件: 用户可感知状态 分支小组 -&amp;gt; 个人发散 -&amp;gt; 小组一致 -&amp;gt; 整体一致 # 不能一致表示准备不足 逻辑顺序 -&amp;gt; 最终流程 命令风暴 # 为什么, 分色 事件触发原因、方式 用户角色 读模型: 用户前置需求 写模型: 动词 描述 聚合 取名, 分职责 持续探索 领域模型一开始就结合编码设计 # 设计围绕模型, 模型受设计反馈改善 开发时意识到模型变更, 会保持完整性 每个开发在修改前需要了解模型 面向对象更易于建模, 过程化易于流程，如数学 重构 要求 设计灵活 使用经过验证的构造 目标 领域理解更深、更清晰 深刻(incisive)、深层(deep)的模型 技术的动机的代码转换 实现 小幅可控 基于测试 突破 新的概念或抽象 隐含的概念被凸显 倾听领域语言 过分复杂是因为关键点被替代 领域文献 # 深层视图 约束 # 表达不变量 过程(process) # 面向对象中的面向过程, 多个过程时用策略 规约 # 测试对象返回布尔值, 重构成对象而非写在application  战略建模 #  # 形成上下文映射图 问题空间 领域 # 与公司组织关联 子域 # 最好对应一个限界上下文 核心域(core domain) # 项目动机, 公司核心竞争力, 尽量小, 最高优先级 通用子域(generic subdomain) # 作用于整个系统的支撑子域 支撑子域 # 重要非核心 集成 合作关系(partnership) # 同时成功失败 共享内核(shared kernel) # 小型内核, 持续集成功能 客户/供应(customer-supplier development) # 上下游 遵从(conformist) # 下游遵从上游 防腐层(anticorruption layer) # 翻译转换领域服务 开放主机服务(open host service) # 公开协议，子系统访问 发布语言(published language) # dsl, 通常与开放主机服务一起 分隔(separate way) # 声明无关联 大泥球(big ball of mud) # 已有纠缠的系统，隔离出来 解决方案空间 通用语言 一个限界上下文一个通用语言 清晰(概念无二义性), 简洁 # 如卖家和买家都叫用户，就是不清晰。如用type标记用户是卖家或买家，就是不简洁。所以直接用两个对象 限界上下文 # 条件的集合 目的 确保术语含义明确 切分规模, 易于保持领域纯洁 设定进化框架而非模块，包含模块 考虑因素 团队组织结构 应用特定部分惯例、物理表现 挑战 团队开发碎片化 # 写重复的代码，由于不知道或怕改错 持续集成 早合并 自动构建测试 # 检测不一致 模块 作用 降低模型规模复杂度 代码高内聚低耦合 设计 通信性内聚(communicational cohesion) 功能性内聚(functional cohesion) 每模块统一接口 名称反映深层理解 灵活性，进化性 上下文映射 # 领域间集成关系 模式 共享内核(shared kernel) # 为减少重复, 共享领域子集，多方测试 客户-供应商(customer-supplier) # 做反馈的需求, 需求测试, 自动化验收 顺从者 # 供应商不做需求, 客户用适配器对接组件 防腐层(anticorruption layer) # 双向领域模型转换器, 保持内部模型纯洁 从前 原始数据(api, db)无模型无语义的处理 实现 对外多门面(facade) 每个门面一个适配器(adapter) 适配器间用转换器(translator) 隔离通道(separate way) 开放主机服务(open host service) # 实现开放服务协议 提炼 # 多次重构后还很大 实现 分离基本概念和普通概念, 提炼核心域和子域 子域 使用第三方服务 外包 修改已有模型 六边形架构 领域模型简洁自治 对外适配器防腐, 保护限界上下文 # 如面向接口 消息, 内存, 数据库 soap, rest CQRS(command query responsibility segregationg) # 修改只记事件(日志), 查询时计算 查询方式 单数据库/读写分离，查询时计算事件 读写分离, 读库异步计算事件保存冗余, 读库负载均衡  战术建模 #  # 组成限界上下文 领域 实体(entity) # 标识和延续性, 有id, 持续变化。 值对象(value object) # 无id, 只有属性, 最好不可变(可共享)。尽量建模值对象。可包含实体引用或值对象。 生命周期 聚合(aggregate) # 定义对象所有权和边界 简化 关联 # 可导航到的关联 1对1 # 对象引用 1对n # 包含集合 n对n # 删除关联，关系加约束或转换 目的 一致性 强化不变量 实现 聚合根(root) # 聚合根间是最终一致性 是个实体,有id 外部访问的唯一对象 向外传递副本 工厂(factory) # 在领域中没有定义, 但程序需要 目的 并非对象创建对象 对象创建存在自有知识 创建过程原子性 对已有持久化对象重建并修复 问题 外部访问根内对象，需关联不必要的根实体 实现 不用工厂 构造不复杂 不涉及其它对象 客户希望用策略创建 类是具体类型, 无层级 聚合根提供方法 单独工厂 # 违反了封装原则, 但保持了简单 资源库(repository) # 内存假象 目的 不关联根获取对象引用 不暴露细节, 会减少领域专注 防止代码扩散 减少变更修改 维护聚合封装性 容易的基础设施被滥用, 产生除聚合根外导航 实现 封装所有获取对象逻辑 基础设施, 全局可访问 不同对象不同策略访问、存储 # 领域与基础设施解耦 接口是领域模型, 实现像基础设施 参数筛选或规约(specification)筛选(筛选器) entity 介绍 entity即状态 应用开发即处理entity的表现 主从 主存储(可变) # 关键是选择主存储 多派生一致性好保障 派生表达业务的难易成度 只读派生(representation, 不可变) 多份存储, 一致性 派生, 合并, 转化 类型 东西(可变) # 单据叠加成东西, 东西叠加成东西 单据(可变) # 事件叠加成单据 事件(event, 不可变) 命令(command, 不可变) 视图(view model, 不可变) 子集(subset, 不可变) 视图(aggregation, 不可变) 表单(可变) # 是主存储 物理介质 OLTP(mysql) # 点查询 OLAP(clickHouse) # 范围查询 queue(kafka) # 顺序读, 低延迟 业务服务 # 业务逻辑, 像虚拟的表 分组entity主存储(BC, bounded context) 目的 分解 管理复杂度 系统 组织部门 实现内部一致性 概念, 数据 对主存储进行受控的修改 边界entity # 用于集成，不一定是主存储 形式 授权、binlog、工作流、视图数据、租户作为其它租户user 东西、单据、event 介质 queue, 带权限db, rpc虚拟表 触发 queue, ui, api 触发由worker托管, 输入是queue或rpc socket 粒度 分entity 分步骤 分entity字段 原则 BC尽可能少而大 关系 时间错开 外键关系 # BC挂载到BC, 如后台系统与计费系统的定价, 运营人员与服务系统的配置, 流程节点系统对流程的依赖 rpc, 数据库, 数据复制 报表关系 时效性高 一般做复制 # 所以边界entity是数据变更event 触发关系 # fire and forget 交棒关系 下游给上游command/event, 上游触发 上游实现降级 # 下游不可用时，安慰语 时间同时 accountable/responsible关系 # 负责人与实现人 原则 accountable尽量小 只调度 与responsible的边界entity是rpc虚拟表, 请求command, 返回event 补偿实现一致 # 如超卖 responsible提供自己界面 # accountable不控制 抢资源关系 锁服务 服务(service) # 无法划分对象的动作, 无状态。按功能分组, 多对象的连接点 可在application, domain, infrastructure  最终一致性建模 #  In-Memory #  聚合根在内存，同步最新状态  事件溯源（Event Sourcing） #   没有CRUD，只有Append Event。数据不可变 对象最新状态通过事件溯源获得  Actor #  通过Mailbox取代调用，保证消息线性处理  EDA(Event-driven Architecture) #  节点只处理逻辑，节点间Event通信 是最终一致性的架构  CQRS #  介绍 Command Query Responsibility Seperation CQ接口分离、代码分离，分别设计 概念  分层 #  用户接口(user interface) 应用(application) # 尽可能小。数据验证，事务。故事, 表达出操作的事情 application service unit work presentation model 领域(domain) # 专注领域。准确定义业务对象 aggregate, entity, value object domain service, domain event 基础设施(infrastructure) # 辅助层 repository global support 项目文件 [ui] mall # 商城api [saleDomain] [application] mall.</description>
    </item>
    
    <item>
      <title>架构-方案</title>
      <link>https://example.com/docs/function/solution/</link>
      <pubDate>Wed, 10 Oct 2018 16:49:27 +0800</pubDate>
      
      <guid>https://example.com/docs/function/solution/</guid>
      <description>功能实现 #  重复提交 #  直接redirect csrf令牌  权限 #  过滤器 页面权限 拦截器aop 数据权限  seo #  静态化  web状态 #  cookie url中sessionId  加密 #  base64 sha  复杂业务 #  关注/信箱 #  要求 user人数10w, 活跃1w。 大部分user关注1k人, 一部分大v被关注100w人。 每人每天发100条博文 user新博文数量提醒，消息标记已读 表 user user_followers user_followed user_posts(u_id, created_ts) user_messages(u_id, p_id, is_read) # 10w * 100条数据 / 天 定时任务拉取 user_followed拉u_id, user_posts表按时段拉id, 更新user_messages 优点 平均, 少次, 增量。 缺点 及时性中 每次对所有用户操作 数据 10w*1k*100条数据 / 天 发布时推送 有p_id, user_followers, 更新user_messages 优点 及时性高 缺点 计算集中, 可能高峰 数据 最高 100w*100条数据 / 次 10w*100次 / 天 messages处理 存部分messages 不活跃user不存message 在登录状态，定时拉取 优点 减少message 缺点 计算集中 数据 1k * N(N&amp;lt;100)条 / 次 1w * 1k * 100条数据 / 天 messages结构变化 u_id: [{p_id: uint, is_read: bool}] # 条数稳定为10w 用mongodb或redis 消息队列?</description>
    </item>
    
    <item>
      <title>支撑-原理</title>
      <link>https://example.com/docs/computer/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:25:12 +0800</pubDate>
      
      <guid>https://example.com/docs/computer/principle/</guid>
      <description>主机 #  cpu #  介绍 单cpu串行工作，前任务完成，后任务才开始 # 串行不适合图形处理(多点，线，面要同时乘投影矩阵) cpu把大量空间和电量分配给控制器和缓存，不能集成太多计算单元 cpu内存通过cpu总线连接, cpu总线与pci总线通过主桥(北桥)连接 gpu在pci总线上 控制逻辑在cpu中运行, 生成渲染数据, 到内存, 再到显存显卡计算。 内存到显存数据传输最花费时间。 原理 处理单元(processing unit) 算术逻辑单元(arithmetic logic unit) 处理寄存器(processor register) 控制单元(control unit) 指令寄存器(instruction register) 程序计数器(program counter) 指令集架构(ISA, instruction set architecture) # 机器码易兼容, 软件易编程, 易升级cpu 精简指令集RISC(reduced instruction set computing) 复杂指令集CISC(complex instruction set computer) 时钟频率(clock speed) 生产 生产线散热决定生存率，决定cpu型号 多级缓存 L1, L2, L3, L4 虚拟化 虚拟机监视器(VMM, virtual machine monitors) 分类 指令流的重数分类 SI(single instruction stream)单指令流 MI(multiple instruction stream)多指令流 操作数流的重数分类 SD(single data stream)单数据流 MD(multiple data stream)多数据流 SISD 串行计算机 SIMD 阵列机(多处理单元) MISD 很少 MIMD 多处理机 多计算机 硬件并行 位级(bit-level): 32位, 64位计算机 指令级(instruction-level) # 处理器内部并行度很高 流水线 指令分步骤(指令流), 每步专门部件处理 多指令流并行, 部件不空闲等待单指令流结束 六级流水线步骤 取指(FI), 译码(DI), 计算操作数地址(CO), 取操作数(FO), 执行指令(EI), 写操作数(WO) 多发射(超标量) 一时钟周期处理多指令 超线程 模拟多个逻辑线程 乱序执行 猜测执行 数据级 向量体系结构、图形处理器 单指令多数据(SIMD)架构 线程级 # 紧耦合硬件模型中开发数据级或任务级并行，线程间有交互 请求级 # OS或程序耦合任务间并行 程序并行 数据级(DLP, data-level parallel) 任务级(TLP, task-level parallel) # 多处理器, 超线程, 虽只有4个核，但可用核返回8 内存 共享内存模型 分布式内存模型 进程: 独有内存 线程: 共享进程内存(地址空间、文件描述符) 一个进程下的轻量进程 POSIX线程api是对已有unix进程模型扩展, 与进程多方面类似 自己的信号掩码 cpu affinity(倾向在某cpu尽量长时间运行) cgroups  进程调度 #  等级 高级调度(High-Level Scheduling) 作业调度, 后备作业调入内存运行 低级调度(Low-Level Scheduling) 进程调度, 就绪队列中某进程获得cpu 中级调度(Intermediate-Level Scheduling) 虚拟存储器引入, 内外存对换区进行进程对换 方式 非剥夺方式 处理机分配给某进程后一直运行下去,直到阻塞时,才分配处理机到另一个进程 剥夺方式 进程运行时,系统基于某种原则,剥夺分配给它的处理机.</description>
    </item>
    
    <item>
      <title>媒体</title>
      <link>https://example.com/docs/misc/media/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      
      <guid>https://example.com/docs/misc/media/</guid>
      <description>原理 #  硬件 #  CRT cathode ray tube 阴极射线管显示器 随机扫描方式 光栅扫描方式 DPU distributed processing unit 分散处理单元  标准 #  Core Graphics System CGI(computer graphics interface) # 与设备无关的方法，方便的直接控制图形设备 CGM(computer graphics metafile) # 设备无关的主义定义图形文件格式 GKS(graphics kernal system) # 应用程序与图形输入输出设备之间的功能接口 PHIGS(programmer&#39;s hierarchical interactive graphics system) # 为3d设计的工具库 GL(graphics library) # 广泛应用的标准图形程序库  算法 #  基元的显示 直线扫描转换 DDA 中点画线法 Bresenham画线 圆的扫描转换 中点画圆 Bresenham 区域填充 种子填充 多边形扫描转换 图形变换 二维图形变换 二维视见变换 三维图形变换 投影 平行正交 平行斜交 透视投影 裁剪 直线段裁剪算法 Cohen-Sutherland算法 中点分割算法 梁友栋-Barsky算法 多边形裁剪Sutherland-Hodgman算法 三维图形裁剪 梁友栋-Barsky算法 曲线和曲面 概念 插值 逼近 参数连续性 几何连续性 光顺(smoothness) Hermite插值曲线多项式 Coons曲面 Bezier曲线和曲面 B样条曲线和曲面 图形运算 交点计算 多边形表面交线计算 平面中的凸壳算法 Graham扫描 Jarvis行进 包含与重叠 凸多边形 多边形的三角剖分 形体的表示 概念 图形信息 几何信息 拓扑信息 非图形信息 颜色 亮度 质量 体积 二维 边界 拆线逼近曲线 选点 共线性 三点转角阈值 带树法 图形的四叉树表示法 三维 几何元素 点 边 环(有序有向边) 面 体 体素 一组单元实体: 长方体、圆柱体、圆锥体、球体 扫描体 代数半空间定义的形体 线框图 顶点表、边表、面表 边界表示法 实体 CSG(constructive solid geometry), 指任意复杂形体都可用的体素组合 特征表示 Brep表示 八叉树(四叉树的推广) 分形 规则分形 # 严格自相似性的分形 Von Koch算法 Julia集和Mandelbrot集 消除隐藏线和隐藏面 线面比较法消除隐藏线 浮动水平线消除曲面隐藏线 深度排序算法(优先级算法) 画家算法(深度优先级表法) z一缓冲算法(深度缓冲算法) 扫描线算法消除隐藏面 区域分割算法消除隐藏面 BSP(binary space partitioning)树算法判别物体可见性 八叉树算法消除隐藏面 光线投射算法找到可见面 # 对包含曲面(特别球面的场景效率高) 真实感 漫反射及光源照明 照明效应 漫射照明 具体光源照明的照射效应、透射效应 漫反射、镜面反射 环境光 漫反射 镜面反射与Phong模型 光的衰减 多边形网的明暗处理 常数明暗法 亮度插值明暗法(Gouraund着色) 法向量插值明暗法(Phong着色) 阴影 纹理(texture) 整体光 透射光亮度模拟 Whitted光照模型(以Phong为基础) 光线跟踪 # 适用光滑表面 包围盒 空间分割成网格单元 辐射度方法 # 描述封闭环境中的能量交换 # 可模拟彩色渗透现象 色彩模型 颜色 色彩(Hue) 色饱和度(Saturation) 明度(Brightness) CIE(国际照明委员会)色度图(红绿蓝) 混合系统 面向硬件 RGB 红绿蓝加色系统 CMY 青、品红、黄着色系统 彩色印刷、胶卷等非发光显示体中采用 面向用户 HSV(Hue, saturation, value) # 六棱锥模型 # 可与RGB空间互相转化 HLS(Hue, lightness, saturation)双六棱锥模型  2d #  分形 #  介绍 Fractal 具有自相似性质的多个形状 大的部分由小的部分组成，小的部分像大的部分 用递归算法模拟 Mandelbrot Set 介绍 分形领域最著名的科学家 本华.</description>
    </item>
    
    <item>
      <title>程序语言原理</title>
      <link>https://example.com/docs/pl/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/principle/</guid>
      <description>基础 #  注意 比较语言，共通处(抽象的元知识)是要点 在历史上判断设计者意图 # 利于了解知道的根基 不同规则，只在特点语言中合理 # 如0在ruby为真 历史 EDSAC # 1949，纸带 FORTRAN # 1954, 中缀表达式, 运算符优先级、结合性 FORTH # 1958, 没有语法，后缀表达式，语法树 LISP # 1958, 括号，前缀表达式，语法树 语法 引入优先级和左右结合 规则不冲突是困难的 vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; # c++的语法缺陷, &amp;gt;&amp;gt;是位运算，必须加空格 结构化 # 60年代 if # 汇编是判断再向后跳代码, if使可读性好 while # 可读了反复执行的if for # 可读了数值渐增的while foreach # 可读了集合遍历 函数 作用 便于理解 # 组织划分部门 便于再利用 # 再利用无代码成本 用了跳转命令和返回命令 # 从记录函数前后地址到函数记录返回地址 栈记录多级调用 # 解决多级调用返回地址被覆盖问题 递归 # 处理嵌套数据结构时，代码的嵌套结构 错误处理 历史 UNIVACI # 1950, 溢出时中断(interrupt)跳转到000 COBOL # 1959, 两种类型错误，用两关键字处理 PL/I # 1964 先定义出错处理代码。编程时引入on语句goto到处理代码, 不检查返回值 可定义新错误类型, 可用signal condition主动出错 john goodenough # 1975，论文 程序员可能忘处理异常、在不正确位置处理、处理不正确类型异常 应该声明可能抛出的异常、将可能出错结构括起来的语句结构 CLU # 1975, begin .</description>
    </item>
    
    <item>
      <title>Haskell</title>
      <link>https://example.com/docs/pl/haskell/</link>
      <pubDate>Tue, 09 Oct 2018 16:54:16 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/haskell/</guid>
      <description>介绍 #  源于ML 标准化的、纯函数式编程语言 非限定性语义和强静态类型 作为其他语言设计新功能时的样板，如Python的lambda标记语句  工具 #  检索函数用http://www.Haskell.org/hoogle  单词 #  polymorphism # 多态 monomorphic # 单态  风格 #  point free style sum&#39; xs = foldl (+) 0 xs sum&#39; = foldl (+) 0  注意 #  使用缩进代替括号，但也可用括号  文件扩展名 #  # 文件中不用let定义变量, # 变量赋值两次会报错, 这意味着代码顺序不重要 hs  内置变量 #  pi  模块 #  :m Data.Char Data.Map # 加载模块 chr # chr :: Int -&amp;gt; Char ord # ord :: Char -&amp;gt; Int toUpper toLower import Data.</description>
    </item>
    
    <item>
      <title>Html</title>
      <link>https://example.com/docs/pl/markup_language/html/</link>
      <pubDate>Tue, 09 Oct 2018 16:42:05 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/markup_language/html/</guid>
      <description>事件 #  blur change click dblclick focus keydown keypress keyup load mousedown mousemove mouseout mouseover mouseup reset select submit unload Abort # 中断图片下载时激发 AfterPrint # 打印文档后激发 AfterUpdate # 传送完数据 BeforeCopy # 复制到剪贴板前 BeforeCut # 剪切到剪贴板前 BeforeEditFocus BeforePaste BeforePrint BeforeUnload BeforeUpdate Bounce CellChange CtextMenu Copy Cut DataAvailable DatasetChanged DatasetComplete Drag DragDrop DragEnd DragEnter DragLeave DragOver DragStart Drop Error ErrorUpdate FilterChange Finish Help LoseCapture Move Paste PropertyChange ReadyStateChange Resize RowEnter RowExit RowsDelete RowsInserted Scroll SelectStart Start Stop  标签 #  &amp;lt;var&amp;gt; # 标识常量 &amp;lt;samp&amp;gt; # 标识输出内容的样式 &amp;lt;pre&amp;gt; # 代码块 &amp;lt;code&amp;gt; # 一段代码  属性 #  全局属性 # 配置所有元素共有行为 accesskey # 快捷键 ## 需要按alt + 指定的键 class contenteditable # 内容是否可修改, 如p标签 contextmenu # 定义右键菜单，未实现 dir # 文字对齐方式 draggable dropzone hidden id lang spellcheck style tabindex # tab键切换元素的顺序 title  浏览器特性 #  视频播放 支持vaapi, chrome 加上--enable-vaapi参数可以开启硬件加速解码  方案 #  标签 &amp;lt;input&amp;gt;表单 单选框 &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; checked value=&amp;quot;1&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; value=&amp;quot;1&amp;quot;&amp;gt; 下拉框 &amp;lt;select id=&amp;quot;mySelect&amp;quot; size=10 multiple&amp;gt; # 长度等于10 ，多选 &amp;lt;option selected=&amp;quot;selected&amp;quot;&amp;gt;Apple&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;Orange&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; 勾选框 &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;&amp;quot; /&amp;gt; 按钮 &amp;lt;input type=&amp;quot;button&amp;quot;/&amp;gt; &amp;lt;button&amp;gt; # &amp;lt;button&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;搜索&amp;lt;/button&amp;gt; button之间可以加图片 &amp;lt;table&amp;gt;表格 &amp;lt;caption&amp;gt; # 标题 &amp;lt;thead&amp;gt; &amp;lt;th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;td&amp;gt; &amp;lt;/th&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tfoot&amp;gt; 属性 &amp;lt;tr style=&amp;quot;display: none;&amp;quot;&amp;gt; # 设置属性为隐藏 &amp;lt;form&amp;gt;表单 enctype属性 application/x-www-form-urlencoded(默认) # 在发送编码所有字符（空格转换为 &amp;quot;+&amp;quot; 加号，特殊符号转换为 ASCII HEX 值） multipart/form-data # 不对字符进行编码，在上传文件时使用 text/plain # 空格转换为+，但是不对特殊字符进行编码 &amp;lt;hr&amp;gt;分割线 字体 &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; .</description>
    </item>
    
    <item>
      <title>Css</title>
      <link>https://example.com/docs/pl/markup_language/css/</link>
      <pubDate>Tue, 09 Oct 2018 16:27:24 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/markup_language/css/</guid>
      <description>基础 #  # cascading style sheet 层级匹配 不同级 1. style属性 2. style标签 3. link标签 4. 浏览器中用户自定义样式表 5. 浏览器默认样式 # 浏览器对每个元素定义了默认的样式表 !important color: black !important 同级 # 评估得出最特殊的样式, 评分相同时，使用最后的 1. id值的数目 2. 其它属性和伪类的数目 3. 元素名和伪元素的数目 继承 部分元素继承父元素样式 外观继承 布局不继承 inherit # 指明使用父元素样式 border: inherit 三种引入方式 内联式 &amp;lt;div style=&amp;quot;color:#000;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 嵌入式 &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt; div {color:#000;} &amp;lt;/style&amp;gt; 引用式 &amp;lt;link href=&amp;quot;css.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt; @ @charset &amp;quot;UTF-8&amp;quot; # 默认UTF-8, 在import前 @import &amp;quot;styles.css&amp;quot; # 静态引用, 效率比&amp;lt;link&amp;gt;标签慢  单位 #  颜色 名称, 如silver, gray 0xffffff rgb(112, 128, 144) rgb(112, 128, 114, 0.</description>
    </item>
    
    <item>
      <title>Elixir</title>
      <link>https://example.com/docs/pl/elixir/</link>
      <pubDate>Tue, 09 Oct 2018 16:24:04 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/elixir/</guid>
      <description>介绍 #  跑在erlang虚拟机上 与erlang相同，actor称作进程, 是比线程更轻量的概念  使用 #  o-&amp;gt; 元组 {:foo, &amp;quot;this&amp;quot;, 42} # 三元组 o-&amp;gt; actor defmodule Talker do def loop do receive do {:greet, name, age} -&amp;gt; IO.puts(&amp;quot;Hello #{name}&amp;quot;) {:shutdown} -&amp;gt; exit(:normal) end loop end end pid = spawn(&amp;amp;Talker.loop/0) send(pid, {:greet, &amp;quot;Huey&amp;quot;, 16}) sleep(1000) Process.flag(:trap_exit, true) pid = spawn_link(&amp;amp;Takler.loop/0) send(pid, {:shutdown}) receive do {:EXIT, ^pid, reason} -&amp;gt; IO.puts(&amp;quot;Talker has exited (#{reason})&amp;quot;) end o-&amp;gt; 有状态的actor # 递归 defmodule Counter do def start(count) do spawn(__MODULE__, :loop, [count]) # 伪变量__MODULE__, 是当前模块的名字 end def next(counter) do send(counter, {:next}) end def loop(count) do receive do {:next} -&amp;gt; IO.</description>
    </item>
    
    <item>
      <title>Go</title>
      <link>https://example.com/docs/pl/go/</link>
      <pubDate>Tue, 09 Oct 2018 16:10:44 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/go/</guid>
      <description>基础 #  特点 易工程化 简单性而不方便性，避免工程复杂性乘法增长 # 某部分变复杂，增加其他部分的复杂性(功能、选项、配置) 没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储 类型系统，无类型风格 自然方式工作 不显式初始化和隐式构造函数 集合直接持有元素 标准库避免配置和解释 # 自带电池 项目结构简单 编译检查代码格式 csp(communicating sequential process)并发，变长栈运行轻量线程 编译为本地机器码 # 像c一样，所以又叫类c语言 编译快 引用包名在头 包依赖有向无环，可独立和并行编译 目标文件包含依赖包信息 强静态类型 有gc 变长栈，最小2kb, 最大1GB 大厂支持 历史 2007年设计，受影响于Alef(CSP系列), Oberon-2(ALGOL60, Modula-2系列), C # 目的解决google许多复杂性激增的软件系统 2009年发布, 作者是Robert Griesemer, Rob Pike, Ken Thompson 2012年1.0 并发编程特点 语言层面关键字 例程 流程控制: csp # channel为一等公民 通信方式: promise-future, channel, event 高效调度模型(调度器，资源占用小) O(1)的调度 一进程可支撑上百万例程,5kib/goroutine的开销, 变长栈存goroutine 编译 CGO_ENABLED=0 # 静态链接，不跨平台 初始化 包级别初始化在main前 局部变量在函数执行时 配置 GOROOT # go安装目录 GOPATH # 包目录, 默认要有go的bin目录 GOBIN # 当前bin目录 GO15VENDOREXPERIMENT # 依赖目录 GOOS # 指定操作系统, 如android, linux, darwin, windows GOARCH # 处理器架构，如amd64, 386, arm  命令 #  go help importpath # 说明 指定代码托管网站版本协议 gopath # vendor怎么使用 list # go list 说明 version env # 打印go环境信息 run # 编译并运行 -race # 检查运行中的竞态冲突并报告 build # 库被舍弃，main包编译成二进制执行文件 go build gopl.</description>
    </item>
    
    <item>
      <title>Python</title>
      <link>https://example.com/docs/pl/python/</link>
      <pubDate>Tue, 09 Oct 2018 16:05:05 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/python/</guid>
      <description>介绍 #  虚拟机语言 虽然是脚本语言，可以预编译成pyc文件来执行  shell #  #! /usr/bin/python # -*- coding: utf8 -*-  语法 #  规范 pep8  内置函数 #  o-&amp;gt; input(&amp;quot;&amp;quot;) # x = int(input(&amp;quot;Please enter an integer:&amp;quot;)) print(&amp;quot;%s&amp;quot;, % s1) ## %.3s % (&amp;quot;abcdef&amp;quot;)取3字符 ## %.* s % (2, &amp;quot;abcd&amp;quot;)取2字符) # %r repr()显示字符串 # %c 单个字符 # %b 二进制整数 # %x 十六进制整数 # %d 十进制整数 # %i 十进制整数 # %o 八进制整数 # %e %E 指数(基底分别为e E) # %-10.</description>
    </item>
    
    <item>
      <title>Clojure</title>
      <link>https://example.com/docs/pl/clojure/</link>
      <pubDate>Tue, 09 Oct 2018 16:00:21 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/clojure/</guid>
      <description>介绍 #   是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程 操作符知道自己的特征值(identity value), 如+是0, *是1 数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃 集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能 # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的 没有尾递归优化，不常用递归，要用loop.recur  语法 #   s-expressions (max 3 5) (+ 1 (* 2 3)) (def meaning-of-life 42) (if (&amp;lt; meaning-of-life 0) &amp;quot;negative&amp;quot; &amp;quot;non-negative&amp;quot;) (def droids [&amp;quot;Huey&amp;quot; &amp;quot;Dewey&amp;quot; &amp;quot;Louie&amp;quot;]) (count droids) (droids 0) (def me {:name &amp;quot;Paul&amp;quot; :age 45 :sex :male}) (:age me) (defn percentage [x p] (* x (/ p 100.0))) (percentage 200 10)  并发 #  o-&amp;gt; 原子变量 # 对一个值进行同步更新 (def my-atom (atom 42)) (deref my-atom) @my-atom (swap!</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>https://example.com/docs/pl/js/</link>
      <pubDate>Tue, 09 Oct 2018 10:31:30 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/js/</guid>
      <description>基础 #  特性 原型链, 面向对象, 动态语言(已超出脚本语言的范畴) 弱类型，变量都是var 解释器有自己的内存管理机制(garbage collection) 自由数据类型转换 # 产生了==, ===的判断相等的不同定义 v8引擎 直接生成机器码 分代式GC java jvm工程师参数了优化 历史 Netscape(现Mozilla)创建JavaScript, 但JavaScript是Sun(现Oracle)的注册商标 作为标准提交给ECMA(欧洲计算机制造协会), 改名为ECMAScript ECMAScript 3(ES3) 作为标准广泛使用 ECMAScript 5(ES5) 定义了新的语言标准 JavaScript1.5是Mozilla的版本号, 相当于ES3,包含一些非标准语言扩展 JavaScript1.8 在实现es7 JavaScript解释器或引擎(engine)也有版本号 Google的叫做V8(现在是4.0) 微软改动并取名Jscript  标准 #  ECMAScript 6 #  介绍 目标是js可写 复杂的应用程序 函数库 代码自动自成器(code generator) mozilla基于ECMAScript6 发布 JavaScript2.0 V8, node.js使用 let # 块级作用域中声明变量 const # 声明常量 Set对象 # 同java Set, 是一个数组 属性 size 方法 add(value) delete(value) has(value) clear() Map对象 # 键值对，键可以是对象 使用 var m = new Map(); o = {p: &amp;quot;Helllo&amp;quot;}; m.</description>
    </item>
    
    <item>
      <title>JavaWeb</title>
      <link>https://example.com/docs/function/javaweb/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/function/javaweb/</guid>
      <description>基础 #  分层 视图层 jsp 控制层 servlet 业务层 过滤数据 manager层 封装第三方，service能力下沉，dao中间件 数据访问层对象 封装对象 数据库 java web 13种技术 JDBC Java Database Connectivty JNDI Java Name and Directory Interface EJB Enterprise JavaBean RMI Remote Method Invoke Java IDL/CORBA JSP Java Server Pages Java Servlet XML Extensible Markup Language JMS Java Message Service JTS Java Transaction Service JTA Java Transaction Architecture JavaMail JAF JavaBeans Activation Framework  jsp #  基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层 域对象 pageContext # 当前页面有效 request # 一次请求范围 session # 会话 application context # 同一服务器 内置对象 Request Response Session Out # 输出流 PageContext # context Page # jsp的this Exception # &amp;lt;%@ page isErrorPage=&amp;quot;true&amp;quot;%&amp;gt; 时使用，显示异常信息 Application # 服务器 Config # 服务器配置  jsp-el表达式 #  ${ } 11个内置对象 pageContext // pageContext page // map （相当于pageScope，不过写法上省略了Scope） requestScope // map sessionScope // map applicationScope // map param // map ,用${param.</description>
    </item>
    
    <item>
      <title>Java并发</title>
      <link>https://example.com/docs/pl/java/juc/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/java/juc/</guid>
      <description>基础 #  并发编程三大特性 可见性(visibility) synchronized会刷新线程栈 有序性(ordering) 原子性(atomicity)  CPU #  PC寄存器(Program Counter Register, 存下一指令) 优化 乱序读 合并写 乱序执行(流水线) ALU 访问速度 Registers: &amp;lt; 1ns L1 cache(核内): 1ns WC(Writer Comblining) Buffer # 合并写, 一般4个字节 L2 cache(核内): 3ns L3 cache(CPU内): 15ns memory: 80ns 局部性原理 空间 按块读取(cache line) 一次读64Bytes # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知 Java1.8注解@Contended # 保证不在同一行，需要JVM参数-XX:-RestrictContended 时间 批量读指令 内存屏障 # 不同CPU不一样 Intel sfence # save, 之前写操作必须完成 lfence # load, 之前读操作必须完成 mfence # mix(save + load) lock指令 # 指令执行完之前，锁内存 lock_add  CPU缓存一致性协议 #  # 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁 状态 MESI Cache一致性协议 # Intel CPU，实现方式为主动监听 Modified # 一行数据在CPU Modified, 其它CPU为Invalid Exclusive # 独享，其它CPU没有 Shared # 别人也在读 Invalid # 别人改过了 MSI MOSI 缓存行 # 多数64字节 伪共享 # 缓存行内无关数据也要同步  OS #  进程 # 资源分配 线程 # 调度执行 切换(Context Switch) CPU导出原线程指令和data到cache, 再导入新线程数据 线程数 N(threads) = N(CPU) * U(CPU) * (1 + W/C) # N(CPU): CPU数 # U(CPU): 期望CPU利用率, 0到1 # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析 压测决定 CPU性能压榨 单进程 批处理 多进程切换 多线程进程内切换 I/O复用 协程(纤程、绿色线程)用户空间切换  JVM #  内存屏障 #  LoadLoad StoreStore LoadStore StoreLoad  乱序执行(指令重排序) #  为什么 CPU快, 指令1阻塞时，指令2先执行 判断 代码不影响单线程最终一致性 例子，多线程  static int x = 0, y = 0; static int a = 0, b = 0; void main(){ for (long i = 0; i &amp;lt; Long.</description>
    </item>
    
    <item>
      <title>Java设计模式</title>
      <link>https://example.com/docs/design/design_mode/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/design/design_mode/</guid>
      <description>六个原则 #  单一职责原则(SRP, Single Responsibility Principle) 一个类只做一件事，应该只有一个引起它修改的原因 开闭原则(OCP, Open-Close Principle) 对修改封闭，对扩展开放 里氏替换原则(LSP, the Liskov Substitution Principle) 子类可以完全替换父类。也就是继承只扩展新功能 依赖倒置原则(DIP, the Dependency Inversion Principle) 细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定 接口隔离原则(ISP, the Interface Segregation Principle) 客户端不依赖它不需要的接口。冗余依赖应该将接口拆分 迪米特法则（最少知道原则）(LoD, Law of Demeter) 一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话  构建型 #  工厂方法(Factory Method) #  # 简单工厂, 根据参数创建不同的类 # 静态工厂，单例工厂 public interface Sender{ public void Send(); } public class MySender implements Sender{ @Override public void Send(){} } public SenderFactory { public static Sender produceStatic() { return new MySender(); } public Sender produce(){ return new MySender(); } public Sender produce(int i){ return new MySender(); } } # 工厂子类继承工厂接口, 不同产品对应不同工厂 public interface AbstractFactory { public MySender produce(); } public class MyFactory implements AbstractFactory { @Override public MySender produce(){ return new MySender(); } }  抽象工厂(Abstract Factory) #  # 生产抽象产品 public interface AbstractFactory { public Sender produce(); } public class MyFactory implements AbstractFactory { @Override public Sender produce(){ return new MySender(); } }  单例(Singleton) #  确保只有一个实例 # 大多有资源管理器的功能 # 反射机制会使所有单例失效：私有构造方法可以被访问 应用 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 o-&amp;gt; 饿汉 public class Singleton { public static Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } o-&amp;gt; 懒汉式 public class Singleton { private static Singleton single=null; private Singleton() {} public synchronized static Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; } } o-&amp;gt; 懒汉，双重检测(DCL) # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。 # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized public class Singleton { private static volatile Singleton singleton = null; # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。 private Singleton(){} public static Singleton getInstance(){ if (singleton == null) { // t1,t2并发进入 synchronized (Singleton.</description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://example.com/docs/pl/java/jvm/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/java/jvm/</guid>
      <description>基础 #  定义 JVM规范说明书, JVMS(Java Virtual Machine Specifications) Java语言规范, JLS(Java Language Specification) 虚拟机 指令集 内存管理 过程 x.java -&amp;gt; javac -&amp;gt; x.class -&amp;gt; ClassLoader -&amp;gt; (字节码解释器、JIT) -&amp;gt; 执行引擎 JVM语言 Scala, Kotlin, Groovy, Clojure, jython, jruby等100多个 JVM实现 HotSpot # Oracle官方, 8之后收费, OpenJDK为开源版本 Jrockit # Oracle收购, 合并入HotSpot J9 # IBM Microsoft VM TaobaoVM # HotSpot深度定制 LiquidVM # 直接匹配专门硬件 azul zing # 收费，快, GC1mm, HotSpot参考写的G1 JRE, JDK JRE = jvm + core lib JDK = JRE + development kit  JVM构造 #  指标 #  吞吐量: 代码时间 / (代码时间 + GC时间) 响应时间: STW越短, 响应时间越好  指令(Instructions) #  分类 基于栈的指令类 # 简单, HotSpot 基于寄存器的指令集 # 复杂但快, HotSpot局部变量表 8大原子操作(JSR-133已放弃这个描述，但指令没变化) lock # 主内存，标识变量线程独占 unlock # 主内存，解锁独占 read # 主内存，读到工作内存 load # 工作内存，read后的值放入线程本地变量副本 use # 工作内存，传值给执行引擎 assign # 工作内存，执行引擎结果赋值给线程本地变量 store # 工作内存，存值到主内存给write备用 write # 主内存，写变量值 方法指令 # 在methods的Code中罗列 aload_0 # 变量表第0项入栈 invokespecial #1 # 调private(无多态)的方法 invokevirtual # 调有多态可能性的方法 invokestatic # 调静态方法 invokeinterface # 调interface方法 invokedynamic # 1.</description>
    </item>
    
    <item>
      <title>算法思想</title>
      <link>https://example.com/docs/algorithm/thought/</link>
      <pubDate>Mon, 08 Oct 2018 22:21:21 +0800</pubDate>
      
      <guid>https://example.com/docs/algorithm/thought/</guid>
      <description>口诀 #  难题首选动归 受阻贪心暴力 考虑分治思想 配合排序哈希  递归(recursion) #  介绍 利用递归，把状态的管理责任推给运行时 递归转迭代 可加上memory做优化  分治(divide and conquer) #  介绍 广义分治法 例子 二分检索 找最大/最小元素 归并分类 快速分类 选择问题 斯特拉森矩阵乘法  贪心(greedy) #  案例 Dijkstra最短路径 最小生成树Prim, Kruskal 背包问题 作业排序 最优归并模式  动态规划(dynamic planning) #  方法 常用滚动数组降低空间复杂度 案例 多段图 结点间最短路径 最优二叉检索树 0/1背包问题 可靠性设计 货郎担问题(旅行商问题) 流水线调度问题  检索与周游(retrieval/travel) #  案例 深度优先检索 广度优先检索 与/或图 对策树  回溯(backtracking) #  案例 8皇后问题 图的着色 哈密顿环 背包问题  暴力(brute force) #  介绍 分支限界条件加快效率 例子 DFS, BFS   分支-限界(branch and bound) 案例 LC检索 0/1背包问题 货郎担问题  并行(parallel) #  时间复杂度(time complexity) #  O()表示上界(&amp;lt;=), Ω() [omega]表示下界(&amp;gt;=), Θ() [Theta] 表示上下界相同, o()表示非Θ()的O() N &amp;gt;= n0时, T(N) &amp;lt;= cf(N), 记为T(N) = O(f(N)) N &amp;gt;= n0时, T(N) &amp;gt;= cg(N), 记为T(N) = Ω(g(N)) T(N) = Θ(h(N)) 当且仅当T(N) = O(h(N)) 和 T(N) = Ω(h(N)) 上界(upper bound) 下界(lower bound) 法则 # 约定, 不存在特定的时间单位 # 约定, 机器模型中, 1.</description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://example.com/docs/algorithm/data_structure/</link>
      <pubDate>Sun, 07 Oct 2018 13:46:46 +0800</pubDate>
      
      <guid>https://example.com/docs/algorithm/data_structure/</guid>
      <description>线性 #  列表(list) 数组(array) # 相同数据类型元素的序列，下标(index)访问 low high 字符串 二进制串(binary string) # 位串(bit string) 链表(linked list) 节点(node) 指针(pointer) 表头(header) 单链表(singly linked list) 双链表(doubly linked list) 栈(stack) # 插入和删除只能在端部进行的列表，应用于递归 栈顶(top) LIFO last-in-first-out 队列(queue) 队头(front) 队尾(rear) 入队(enqueue) FIFO first-in-first-out 优先队列(priority queue) # 数据项多来自于全序域(常整数或实数) 查找最大元素，删除最大元素，插入新元素 堆(heap)实现  散列表 #  介绍 有序输入时，树效率低，如果不要求查找有序结果，可以用散列 概念 hash table hashing(散列) item(项) key(关键字) # 项中某部分 hash function(散列函数) # 映射函数 collsion(冲突) # 多个关键字散列到同项的状况 load factor(装填因子) # λ 元素个数对表长度的比， # 如果散列是均匀的，表示了一个项中关键字的平均长度 # 一次成功查找要遍历约1 + (λ / 2)个链，1表示被匹配的项 rehashing(再散列) 一半时进行 直到插入失败再进行 middle-of-the-road # 到达某load factor时进行 caching the hash code(闪存散列代码) 算法 separate chaining(分离链接法) # 解决冲突 probing hash table(探测散列表) 线性探测法 primary clustering(聚集) # 线性探测法中形成数据区块 平方探测法 secondary clustering(二次聚集) # 模拟结果指出，对每次查找，会引起另外的少于一半的探测 double hashing(双散列) # 模拟表明, 两个散列都mod质数时，探测次数几乎和随机冲突解决方法相同 extendible hashing(可扩散列) D directory(目录) # 一个分区中bit的个数，所以M最多2^D 性质 # 基于位模式(bit patterm)是均匀分布的事实, 是&amp;quot;分支系数(branch factor)&amp;quot;, N 是记录总数(随时间变化) 树叶期望个数为(N/M)log(2)(e) 所以平均树叶满的程度为ln2 = 0.</description>
    </item>
    
    <item>
      <title>数学</title>
      <link>https://example.com/docs/algorithm/math/</link>
      <pubDate>Sun, 07 Oct 2018 12:46:46 +0800</pubDate>
      
      <guid>https://example.com/docs/algorithm/math/</guid>
      <description>指数 #  X^A * X^B = X^(A + B) X^A / X^B = X^(A - B) (X^A)^B = X^(A * B) X^N + X^N = 2X^N &amp;lt;&amp;gt; X^(2N) 2^N + 2^N = 2^(N + 1)  对数 #  约定 计算机科学中, log默认为log(2) X^A = B, log(X)(B) = A log(A)(B) = log(C)(B)/log(C)(A) logAB = logA + logB  级数 #  ∑(i=0)(N)2^i = 2^(N + 1) - 1 ∑(i=0)(N)A^i = (A^(N + 1) - 1) / (A - 1) 如果0 &amp;lt; A &amp;lt; 1, 则 &amp;lt;= 1 / (1 - A) ∑(i=1)(∞)i/2^i = 2 ∑(i=1)(N)i = N(N + 1) / 2 ≈ N^2 / 2 ∑(i=1)(N)i^2 = N(N + 1)(2N + 1) / 6 ≈ N^3 / 3 ∑(i=1)(N)i^k ≈ N^(k + 1) / |k + 1| k &amp;lt;&amp;gt; -1 k = -1时, Hn = ∑(i=1)(N)1 / i ≈ log(e)(N), Hn是调和级数 该近似式误差趋向于 λ ≈ 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/cache/develop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/cache/develop/</guid>
      <description>git #  git clone ssh://git@192.168.0.1:2232/jinancloud/jncloud-one.git  go #  go test -bench=. --cpuprofile=cpu.prof --memprofile=mem.prof -config ../conf/config_lc.toml -test.run TestCreateType go test -cover -args -config config.toml -test.run &amp;quot;TestCreate&amp;quot; go tool pprof service.test cpu.prof go-torch -b cpu.prof go list -m -u all # 列可升级包 go list -u need-upgrade-package # 升级可升级包 go get -u # 升级所有依赖  java #  java -jar xxx.jar java -jar a.jar --spring.config.location=/application.yml # 指定spring config --spring.profiles.active=prod java -Xmx2g  hugo #  go install --tags extended  快捷键 #  独立 &amp;lt;M - s&amp;gt; # 帮助 &amp;lt;M - w&amp;gt; # 菜单 client &amp;lt;M - 回车&amp;gt; # 终端 &amp;lt;M - ctrl - r&amp;gt; # reload &amp;lt;M - c&amp;gt; # 自定义chromium &amp;lt;M - f&amp;gt; # 全屏 &amp;lt;M - shift - c&amp;gt; # 关闭 &amp;lt;M - 数字&amp;gt; # 切换到tag &amp;lt;M - j&amp;gt; &amp;lt;M - k&amp;gt; # 本tag切换client &amp;lt;M - 空格&amp;gt; # 变布局  端口 #  8123 polipo 1080 shadowsocks 1315 blog 7000,7001,7199,9042,9160 cassandra 9092 kafka 2181 kafka zookeeper 9020 kafka-manager 8001 nginx 3306 mysql 5432 postgres 54321 timescaledb 8002 adminer 27017 mongo 8003 mongo-express 6379 redis 7474,7687 neo4j 4369, 5671, 5672, 15671, 15672 rabbitmq 9411 zipkin 9200 es 9100 es-head 5601 kibana 10001 haproxy 5433,8090,8091 confluence 8004 dokuwiki 8005 wordpress 8006 nginx-php-fpm 9090, 1883, 5683 thingsBoard 9000 provider 9001,9002 consumer 9003,9004 discovery 9005,9006 consumer-metadb 9010 monitor 9011 api-gateway 9012 config-server 9013 config-client 9014 zipkin-server 9015 admin-server 9016 auth 9017 auth-client  配置 #  # 同步备份 .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/cache/ops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/cache/ops/</guid>
      <description>环境 #  scp eureka-server-1.0-SNAPSHOT.jar shenwq@36.137.165.51:~  源 #  163: http://mirrors.163.com/ 阿里云mirror: https://developer.aliyun.com/mirror ubuntu sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list 阿里云maven: https://maven.aliyun.com/mvn/view 阿里云个人docker 入口: cr.console.aliyun.com docker login -u 934260428@qq.com registry.cn-qingdao.aliyuncs.com docker tag java/device:1.0 registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0 docker push registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0 docker pull registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0  分析 #  nmon pidstat -p 434 -u 1 # CPU -r 1 # 内存 -d 1 # 磁盘 -w # 上下文切换 iftop -n # 网络流量 iotop p # 显示pid o # 只显示活跃  java #  -Dserver.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/cache/template/script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/cache/template/script/</guid>
      <description>默认声卡 #  pactl list short sources pactl list short sinks pactl set-default-source alsa_input.pci-0000_00_1b.0.analog-stereo pactl set-default-sink alsa_output.pci-0000_00_1b.0.analog-stereo  亮度 #  #!/usr/bin/expect -f spawn sudo vim /sys/class/backlight/intel_backlight/brightness expect &amp;quot;*password*&amp;quot; send -- &amp;quot;asdf\r&amp;quot; interact  电量 #  cat /sys/devices/LNXSYSTM:00/LNXSYBUS:00/PNP0C0A:00/power_supply/BAT0/capacity  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/cache/work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/cache/work/</guid>
      <description>项目结构 #  api: controller biz: 特异业务 manager converter core: 公用业务 model entity bo service repository common dal dataobject do dao mapper service facade dto: facade和controller用 service: 服务间api validate integration service shared dto: 项目内部公用  业务流程 #  积分管理(向门店加积分)
配送流程 物品档案 配送物品关系 配送售价单 物品关系设置 其他入库 门店请购单
订单中心 生成订单 配送订单 生成备货分拣单/审核 备货单 备货完成 分拣单 编辑 提交+校验 审核（关闭开关[配送出库单是否自动审核]）+校验, 批量审核+校验 [反审核]：不反结算 配送出库 出库（关闭开关[备货单和分拣单]） 生成发货单 反审核 发货单 验收单  配送金额 #  unit_price 3.925 purc_unit_num 2 tax_ratio 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/cache/work_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/cache/work_code/</guid>
      <description>框架编写 #  优雅关闭相关的，使用到的是enable** choice-driver-shutdown jwt相关 choice-driver-jwt 通用 choice-driver-common choice-driver-all gray-spring-boot
0 FAT
1 eureka.instance.prefer-ip-address=true eureka.instance.instance-id=fat:jncloud-account eureka.instance.ip-address=192.168.0.9
2 TEST04 dev -&amp;gt; fat
3 0.9
4 fat:
5 36.137.165.51:31019
6 redis
7 删除
命令 #  git update-index &amp;ndash;assume-unchanged a mvn clean deploy -P keruyun -pl alsc-item-solution-kryun-dish-client -DskipTests
搜索词 #  分库 DynamicDataSource determineCurrentLookupKey
snip #  org.apache.ibatis.mapping.MappedStatement#getBoundSql
PageHelper.startPage(Optional.ofNullable(scmDirectSendCheckQueryDTO.getPageNum()).orElse(1), Optional.ofNullable(scmDirectSendCheckQueryDTO.getPageSize()).orElse(10));
com.choice.scm.utils.enums.EnumSalesOrderType 订单类型 com.choice.scm.utils.enums.EnumSalesOrderStatus 订单状态 com.choice.scm.utils.common.ScmConstants.SCM_ORDER_TYPE 汇总类型 com.choice.scm.utils.common.BillTypeEnum 出库类型 com.choice.scm.entity.dispatch.enums.ScmDispatchOutStatusEnum: 配送出库状态
// 设置属性 System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/computer/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/computer/performance/</guid>
      <description>基础 #  性能指标 latency throughput qps = throughput / latency 性能分析 bottle-nect(first-principle) 资源 CPU和GPU 内存 磁盘 网络 能源 逻辑资源 fds(文件描述符) sockets 内核对象: locks inodes(磁盘索引节点) transactions ip addresses ports random numbers(分布式随机数) 容量 2000前 尽量少 200~ 不到机型限制 2017 尽量把机器用满 以后 metrics分离, 单独规划  计算 #  cpu gpu  存储 #     类型 时间 描述     L1 cache 0.5ns    branch mispredict(分支、转移) 5ns    L2 cache 7ns 14x L1 cache   Mutex lock/unlock 25ns    Main memory 100ns 20x L2 cache, 200x L1 cache   1k字节压缩Zippy 3,000ns = 3us    在1Gbps网络上发送1k字节 10,000ns = 10us    SSD随机读4k 150,000ns = 150us 1GB/秒   内存顺序读1MB 250,000ns = 250us    同一数据中心往返 500,000ns = 500us    SSD顺序读1MB 1,000,000ns = 1000us = 1ms 1GB/秒, 4x 内存   磁盘搜索 10,000,000ns = 10,000us = 10ms 20x 数据中心往返   磁盘顺序读1MB 20,000,000ns = 20,000us = 20ms 80x 内存, 20x SSD   发包: 美国 -&amp;gt; 荷兰 -&amp;gt; 加拿大 150,000,000ns = 150,000us = 150ms     传输 #  带宽 热门并发1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/db/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/db/elasticsearch/</guid>
      <description>介绍 #  分布式实时lucene  使用 #  ./bin/elasticsearch curl http://localhost:9200  命令 #  elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name  概念存储 #  index type # document中加_type field实现 # 所以不同type中的field在index要唯一，否则冲突 # 对field排序会载入所有type的document document # 对应lucene中的key value倒排文档 # 对就一个请求的json对象 field mapping # 定义type的field，映射json到document field  设置 #  config/elasticsearch.yml action.auto_create_index: -l*, +z* # 自动创建，以z开头和非l开头的索引 action.destructive_requires_name: true # 允许通配删index http.cors.enables: true http.cors.allow-origin: &amp;quot;*&amp;quot; cluster.name: c1 node.name: n1 node.master: true node.data: true transport.host: localhost transport.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/db/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/db/mysql/</guid>
      <description>基础 #  介绍 c++编写 端口 3306 命令 mysql --max-relay-logs-size=300 # 中继日志大小(sql语句数) --relay-log-purge={0|1} # 中继日志自动清空 --relay-log-space-limit=0 # 限制中继日志大小,0表示无限制 o-&amp;gt; mysql -h 127.0.0.1 -u root -p mysqldump -uroot -p -h127.0.0.1 -P3306 --force --all-databases # 所有库 --databases db1 db2 # 多库 o-&amp;gt; mysqldump -uroot -p db1 tb1&amp;gt; tb1.sql mysqladmin -uroot -p status # 查看当前连接数 组件 mysql enterprise monitor documentation mysql enterprise monitor connector mysql enterprise monitor service manager mysql enterprise monitor agent mysql enterprise backup mysql connector 工具 mysql database mysql cluster # 创建集群，配置复杂 mysql cluster manager # cluster帮助软件，配置简单 mysql workbench # 据库建模工具 mysql utilities # 提供一组命令行工具用于维护和管理 MySQL 服务器 连接参数 root:123456@tcp(abcdefg:3306)/meiqia?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/db/oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/db/oracle/</guid>
      <description>基础 #  安装 运行services.msc 找到OracleServiceORCL 服务 （最后是数据库名）改为手动 sqlplus / as sysdba 运行oracle测试是否安装成功 解锁scott用户 sqlplus / as sysdba alter user scott account unlock; alter user scott identified by tiger; 启动 OracleServiceORCL OracleOraDb11g_home1TNSListener 端口 1521 # 停了以后再开会变 权限 系统权限：创建数据库，创建用户 对象权限：表操作 sys create database权限 system 没有create database权限 scott hr 角色 # 超管以角色进入，普通用户输入用户名密码 dba dbaoperator 服务器的组成 oracle数据库 存储位置 oracle安装位置/oradata/ 每个数据库文件夹中有多个二进制文件（*.dbf） oracle实例(内存概念) 一个数据库进程可以有多个实例 一个实例可以有多个数据库进程和一个内存池(缓存) # 不同于windows进程，每个进程对应一个用户访问 服务名为OracleService数据库名 集群(多实例) 连接失败转移 负载均衡 连接类型 normal sysdba sysoper 分布式 认证 开发技术认证 Java认证 数据库开发语言SQL和PL/SQL认证 数据库技术认证 OCM【大师】 OCP【专家】 OCA【初级】 中间件技术认证 OracleServer认证，WEB服务器认证 专业领域技术认证 ERP CRM HR OA 支持的事务隔离 只支持读提交与序列化两种 版本 8i 9i 10i # i是internet 11g # 基于jdk6, g是grid网格(一个请求多个服务器运行) 12c # c是cloud SQL99标准 # 不区分大小写 PLSQL是Oracle对SQl99标准的扩展 结构代查询语言 DML select,insert,update,delete DDL create table,alter table, drop table DCL grant, revoke TCL(杜撰) commit, rollback,rollback to savepoint 加载过程 启动oracle服务 oradim -startup -sid 数据库名 # 相当于windows服务中启动该服务，会从windows注册表中加载配置 oradim -shutdown -sid orcl -shuttype srvc # 停止oracle 服务 普通登录 sqlplus system/asdf # 从注册表中查找默认的数据库名称进行登录 sqlplus system/asdf@orcl # 指定数据库名登录，必须有监听的时候该命令可以执行，监听的进程是独立于oracle之外的进程 管理员登录 sqlplus / as sysdba # windows管理员的身份进行登录，不需要用户名密码，可以在配置文件中禁用它 无连接登录 sqlplus /nolog #用来设置sql/plus 启动实例 cmd&amp;gt; sqlplus / as sysdba # 连接到数据库的空闲实例 sql&amp;gt; select status from v$instance # 查看实例状态 sql&amp;gt; shutdown abort # 立即终止当前的实例,实例结束后用户仍然登录状态，但没有连接实例 sql&amp;gt; startup nomount # 启动默认实例（不加载数据库） sql&amp;gt; startup open # 启动、装载、打开默认的数据库 cmd&amp;gt; set oracle_sid=orcl # 在windows下设置oracle的默认登录数据库 启动过程 加载参数文件database/init数据库名 分配sga (system global area)到内存空间，用于缓存数据库信息 创建后台进程 挂载数据库 sql&amp;gt; startup mount 挂载过程 装载数据库文件夹中的文件 # sga中有已经初始化了ctl文件的路径，通过ctl文件装载数据库 ctl(从中得到数据库文件名) -&amp;gt; dbf # 3种数据库文件: .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/db/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/db/redis/</guid>
      <description>基础 #  remote dictionary server 特点 no-sql, c编写 内存数据库 # 请求不经过parser和optimizer key-value 单线程 可持久化 与memcache区别 memcache全在内存，不能持久化，redis部分硬盘 memcache类型支持简单 # memcache类型只有字符串，append字符串, blacklist删除麻烦 emecache多线程, redis单线程 底层模型，与客户端通信协议不同，redis自己实现vm机制(冷热数据分离) value, memcache只能存1MB, redis可存1GB redis可设置expire, 支持排行榜, 浮点数 类型 string 整个或一部分操作 整数、浮点数自增自减 list 两边推入或弹出 偏移量trim 读单个多个元素 值查找移除元素 set 增删查单个元素 单个元素是否存在 交集、并集、差集 随机取元素 hash 增删查单个键值对 获取所有键值对 zset # 有序集合, 排序根据score, score为双精度浮点数 增删查单个元素 根据range或成员获取元素 应用 会话缓存(session cache) 全面缓存(FPC) 队列 排行榜/计数器 发布/订阅 命令 文件命令 redis-server # 端口为6379 redis-server /etc/redis.conf 来加载配置文件 redis-cli redis-benchmark # 性能测试工具 redis-cli命令 ping # 成功时返回 PONG shutdown # 关闭redis-server服务 -p 端口号 quit  功能 #  性能高 # 100k次读写/s 数据类型丰富 所有操作有原子性 支持发布/订阅，通知，key过期 发布订阅 subscribe psubscribe # 订阅给定模式匹配的所有频道 unsubscribe punsubscribe publish sort # 列表、集合、有序集合排序，返回结果或生成存储 过期 persist # 移除键过期时间 ttl # 键距离过期时间还有多少秒 pttl # 多少毫秒 expire # 给定键指定数秒后过期 pexpire # 指定的毫秒后过期 expireat # unix时间戳过期 pexpireat # 毫秒unix时间戳 事务 # 事务期其他客户端命令阻塞 multi # 创建事务队列，开始记录命令 exec # 提交事务队列 watch # 对键加锁 unwatch discard # 取消事务 持久化 bgsave # fork线程创建快照, windows不支持 save # 停止响应创建快照 sync # 向主服务器要求复制时，主服务器bgsave，非刚bgsave过 bgrewriteaof # 重写aof文件使它缩小 复制 slaveof 客户端分片 不完全事务  性能 #  内存数据库，需要预估内存，使用key过期节约 完整重同步占资源，可以部分重同步 重启数据加载慢 master内存快照时，save命令调rdbSave阻塞主线程 master AOF持久化，追加文件大时影响master重启恢复速度 用slave AOF master调用BGREWRITEAOF重写AOF文件时，cpu和内存负载高 主从复制最好同局域网  数据 #  set mykey somvalue get mykey del mykey incr decr incrby decrby incrbyfloat append getrange setrange getbit setbit bitcount # 二进制位串位为1的数量 bitop # 二进制位串执行and, or, xor, not rpush list-key item lpush lrange list-key 0 -1 # -1为结束索引 lindex list-key 1 rpop lpop list-key lrange ltrim # 修剪 blpop # timeout秒内阻塞并等待弹出元素 brpop rpoplpush # 一个列表中右弹元素推入另一个列表左端，最后返回这个元素 brpoplpush sadd set-key item smembers set-key sismember set-key item srem set-key item # 删除，返回删除的数量 scard # 元素数 srandmember # 随机返回一个或多个元素。count正数时，返回的元素不重复, 负数时可重复 spop # 随机移除一个元素 smove # 一个集合中移除，并在一个集合中添加。返回移除的数量 sdiff # 差集 sdiffstore # 差集生成集合 sinter # 交集 sinterstore sunion # 并集 sunionstore hset hash-key sub-key value hget hash-key sub-key hdel hash-key sub-key hlen hexists hash-key sub-key hkeys hash-key hvals hgetall hash-key hincrbyfloat hincrby hash-key field -1 hmget hmset hash-key field1 &amp;quot;foo&amp;quot; field2 &amp;quot;bar&amp;quot; zadd zset-key 728 member zrange zset-key 0 -1 withscores zrevrange zset-key 0 -1 withscores zrangebyscore zset-key 0 800 withscores # 根据score范围查找 zrevrangebyscore zrem zset-key member zremrangebyrank zremrangebyscore zincrby zinterstore sum 3 sub1 sub2 sub3 # 生成交集, 重复值score相加, 3 指定可变参数的数量 zunionstore # 并集 zcard # 成员数量 zcount # 分值之间的成员数量 zrank # 返回排名 zrevrank zscore # 返回分值  client #  jedis # java, 支持redis sharding, 即ShardedJedis结合ShardedJedisPool Jedis jedis = new Jedis(&amp;quot;localhost&amp;quot;); # 连接redis数据库 jedis.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/function/small_function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/function/small_function/</guid>
      <description>阻塞 #  阻塞(bio)指cpu等待io 非阻塞(nio)指调用io后立即返回，但要轮询事件状态 # 非阻塞指对cpu不阻塞，但业务线程阻塞 轮询(单线程) read 定时重复调用来检查 select 前后read, 中间select轮询检查文件描述符的事件状态 采用1024长度数组存储状态，只能同时检查1024个文件描述符 poll 前后read, 中间poll 用链表代替数组, 也避免了不必要的检查 epoll # linux 前后read, 中间epoll epoll检查不到事件，休眠epoll线程直到事件将它唤醒 kqueue # freeBSD中，类似epoll aio # async io, linux, 业务线程不阻塞 通过回调(信号)传递数据，不必像epoll线程(业务线程)阻塞等待 仅linux下有, 只O_DIRECT方式读取，不能利用系统缓存 IOCP # windows aio 模拟aio(io线程池) 业务线程的io操作, 起io线程, io线程完成通信到业务线程触发回调 库 glibc(有bug) libeio node.js的libuv封装 linux下自实现 windows下IOCP  事件 #  实现 回调 队列存事件, 单进程检测事件是否回调 库 libevent libev # bug比libevent少 工具 epoll(select, poll) libev(libevent)  并发并行 #  并发 多任务共享时间段, 类比: 任务队列 为什么并发 多任务能力 非阻塞 并行 多任务同时处理, 类比: 多核处理器 为什么并行 提高执行效率 分类 任务并行化 数据并行化 cpu交替任务 # EDSAC串行任务 协作式 # 可能独占，Windows3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/middleware/big_data/hadoop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/middleware/big_data/hadoop/</guid>
      <description>介绍 #  大数据 PB级数据 4V volume(大量) velocity(高速) variety(多样) value(低价值密度) 场景 物流仓储: 精细化运营，命中率 推荐 保险: 风险预测 金融: 用户特征 房产: 精准投策、营销 AI 组织部门 平台: 集群 Hadoop、Flume、Kafka、HBase、Spark等搭建 性能监控、调优 数据仓库: 写SQL ETL, 数据清洗 Hive, 数据分析、建模 数据挖掘 数据支持 算法、推荐、用户画像 报表 JavaEE hadoop Apache开源, 分布式系统基础架构 面临问题 硬盘 1块: 10TB-14TB 1PB: 102块硬盘 算 MySQL5.5: 300w-500w MySQL8: 1亿、1GB Doug Cutting GFS -&amp;gt; HDFS 存储 Map-Reduce -&amp;gt; MapReduce 计算 BigTable -&amp;gt; HBase 表式存储 发展 2003-2004: Google公开部分GFS和MapReduce 2005: Hadoop成为Apache Lucene子项目Nutch了一部分 2006.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/middleware/library/hibernate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/middleware/library/hibernate/</guid>
      <description>基础 #  优点 完全面向对象编程思想，无sql 减少代码 控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率 hibernate具有独立性（访问层随时可以更换） 特性 不写hbm.xml映射文件，而是基于注解的验证 对象、集合、属性的延迟加载 dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常 目录 . # hibernate程序包 documentation # 文档 lib # 所有依赖包 project # 源码文件 加载顺序 后面的覆盖前面的 hibernate.properties中的配置被覆盖 # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置 hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准） 开发流程 加载配置: jdbc参数，数据库方言，hbm映射 创建SessionFactory # 内有连接池 创建session 事务处理 关闭session 关闭连接池 对象状态 𣊬时态 # 没有OID(持久化标识), 没有关联session 持久态 # 有OID, 与session关联, 事务未提交 脱管态 # 有OID, 没有关联session 缓存机制 一级缓存(session) 事务级，事务结束缓存失效 # 请求同一对象，取得同一实例 总是打开 二级缓存 SessionFactory级别，session共享 缓存散装持久化实例, 有不同缓存策略 先设置策略，再设置过期时间与cache提供器 优点 提高速度、减小压力 缓存失效时，不立即查找，而是合并sql查找 查询方式 HQL QBC(命名查询) SQL get与load get立即加载，load延时加载 get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库 # 代理对象只存id get没有时返回null, load抛异常 检索策略 # 取关联对象 立即检索 # 一次全加载, select多 延迟检索 # 访问游离状态代理类，需要在持久化状态时已被初始化 迫切左外连接检索 # 用外连接取代select，全加载  优化 #  数据库设计调整 HQL优化 api正确使用 配置参数 # 日志、查询缓存，fetch_size, batch_size等 映射文件优化 # id生成策略，二级缓存，延迟加载，关联优化 一级缓存管理, 二级缓存策略 事务控制策略  基本概念 #  o-&amp;gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题 o-&amp;gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想) DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准 它们的区别在于 hibernate中不写sql语句 ibatis中写少量sql语句 DBUtils中写sql语句 它们的另一个相同点是 底层全都是jdbc o-&amp;gt; 结构对应 javabean中的 类，对象，属性 数据库中的 表，记录，字段 o-&amp;gt; hql hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用 o-&amp;gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean  使用 #  1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/pl/java/collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/pl/java/collection/</guid>
      <description>基础 #  物理容器 数组 链表 Java容器 Collection List ArrayList Vector # JDK1.0，所有方法加synchronized Stack LinkedList CopyOnWriteList # 写时复制整个list, 写加锁读无锁, 无fail-fast Set HashSet LinkedHashSet SortedSet TreeSet EnumSet CopyOnWriteArraySet ConcurrentSkipListSet Queue # 相比List添加线程友好API Deque # 双端队列 ArrayDeque BlockingDeque LinkedBlockingDeque BlockingQueue # LockSupport实现, channel, 生产者消费者 SynchronousQueue # 锁实现, 无缓冲区channel TransferQueue # CAS, 生产者带队列阻塞 LinkedTransferQueue ArrayBlockingQueue # 有缓冲区channel DelayQueue # 内部维护按时间排序队列 PriorityBlockingQueue LinkedBlockingQueue # 最大数量Integer.MAX_VALUE PriorityQueue # 堆排序实现 ConcurrentLinkedQueue # CAS Map HashMap LinkedHashMap # 双向链表，按插入或访问顺序遍历 Hashtable # JDK1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/pl/java/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/pl/java/spring/</guid>
      <description>基础 #  特点 容器, 也容纳管理了第三方框架 # 目的是解耦框架api 轻量级，模块化，无(少)侵入 IOC(inversion of control) 容器用工厂装配对象并管理, 面向接口编程 优点 降低代码量 容易测试 最小侵入性松耦合 方式 Setter 构造器 静态工厂、实例工厂 DI(dependency injection) 容器向类添加属性 # 反射，用带参构造或set方法 AOP(aspect oriented programming) # 继承是纵向组织，AOP横切入业务 # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用） 动态代理实现切入代码 权限控制 事务管理 记录日志 概念 连接点:普通方法 切入点:名称满足条件的连接点 增强（通知）类:服务对象 # 切入点与增强是多对多的 切面:切入点 + 增强类 # 我们切入的是横切面 目标对象（服务对象）：要注入的对象 通知 before # 执行前 after # 执行后 after-returning # 正常退出 after-throwing # 异常退出 around # 执行前后 代理对象(业务对象)：被注入的对象 模块 dao, orm, aop, jee, web, core 结构 核心容器(core container) Core # 最底层，资源访问，类型转换 Beans # IOC, DI, BeanFactory Context # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播 EL # 表达式语言 AOP, Aspects # Aspects对AspectsJ集成, 功能多于spring asp 数据访问/集成 JDBC ORM OXM # object xml 映射 JMS # 消息与异步通信 事务 Web/Remoting Web # ioc窗口，rmi, hessian,burlap, web service Web-Servlet Web-Struts Web-Porlet # portal认证 Test 设计模式 代理 目标对象实现接口，使用Proxy 未实现接口，使用CGLIB 单例 bean默认单例 模板, 解决代码重复问题 RestTemplate, JmsTemplate, JpaTemplate 控制器 DispatherServlet对请求分发 视图帮助(view helper) 提供jsp标签、高效宏 帮助在视图中写代码 依赖注入 BeanFactory, ApplicationContext核心理念 工厂 BeanFactory 循环依赖问题 构造器, 正在创建在Bean池标记，创建完删除标记，标记冲突报错 # 所以用@Autowired决定注入时机，不写在构造方法里 单例， 三级缓存, 提前暴露使双方都可初始化 setter, 提前暴露bean 版本 2.</description>
    </item>
    
    <item>
      <title>Apple</title>
      <link>https://example.com/docs/computer/tool/apple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/computer/tool/apple/</guid>
      <description>ipad #  操作 下边向上(短)：桌面 下边向上(停): dock dock拖app: 小窗、分屏 小窗向边(短): 隐藏 小窗向边(停): 分屏 小窗向上：分离 下角向内(短): 切app 下角向内(停): app表 右上角向下: 控制中心 左上角向下：通知 桌面向下: 搜索 3指左右: app内切换 4指左右：切app 4指向内(短): 桌面 4指向内(停): app表 home一下：桌面 home两下：app表 siri 问答: 笑话, 常识, 抛硬币 safari: 搜索 设置: 蓝牙,飞行模式 时钟 6点起床 德国时间 倒计时 日历: 9点开会 提醒：提醒和给妈妈打电话 备忘录：记下我花了10块钱 地图：回家路线 打车 打电话, 发信息 照片 体育：比赛消息 音乐 邮件 天气 计算器 股票: xx涨了吗 朋友：xx在哪里 发微博 指定xx: 打开trello发送a 附近店 相机：自拍模式  mac #  操作 四指 向内：启动台 向外：桌面 三指 左右：切桌面 向上：app列表 向下：expose(单程序多窗口) 二指 上下：滚动 左右：前进后退 右边：通知中心 缩放,旋转 点一下：菜单 点二下：小缩放 一指 点一下：选中 点二下：打开 点一段：拖 点二段：查询 快捷键 系统： 锁屏：control + command + q 关屏：shift + control + 关机 注销：shift + command + q 睡眠：option + command + 关机 强退：control + command + 关机 程序坞： option + command + d 调度中心： app列表: control + 上 expose: control + 下 左右桌面：control + 左右 桌面：f11 窗口： 切换：command + tab 程序内切换：command + ` 关闭：command + w 退出：command + q 强制退出：option + command + esc 隐藏：command + h 最大化: control + command + f 最小化：command + m 放大、缩小：command + +和- 新标签：command + t 新建: command + n 打开：command + o 保存：command + s 另存为：shift + command + s 刷新：command + r 打印：command + p 搜索：command + f 文件： 全选、复制、剪切、粘贴、撤销: command + a c x v z 粘贴移到: option + command + v 删除: command + return 访达： 预览：空格 简介：command + i 回收站： 清空：shift + command + return 截屏： 整屏存文件：shift + command + 3 区域存文件：shift + command + 4 窗口区域：shift + command + 4 + 空格 录屏：shift + command + 5 输入法：control + 空格 </description>
    </item>
    
    <item>
      <title>awesome</title>
      <link>https://example.com/docs/cache/template/awesome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/cache/template/awesome/</guid>
      <description>autorun.sh #  #!/usr/bin/env bash # nothing to use function run { if ! pgrep $1 ; then $@&amp;amp; fi } if randr | grep -q &#39;eDP1 connected&#39; ; then run xrandr --output VIRTUAL1 --off --output eDP1 --mode 1920x1080 --pos 0x720 --rotate normal --output DP1 --off --output DP2-1 --mode 2560x1080 --pos 3360x720 --rotate normal --output DP2-2 --off --output DP2-3 --off --output HDMI2 --off --output HDMI1 --primary --mode 2560x1440 --pos 1920x0 --rotate left --output DP2 --off fi  rc.</description>
    </item>
    
    <item>
      <title>Book</title>
      <link>https://example.com/docs/misc/book/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/misc/book/</guid>
      <description>《错误之书：改变你一生的9个秘密》 #  错误之一：活在别人为你设定的剧本里 错误之二：任由他人决定你的价值 错误之三：凡事总爱找借口 每一个借口背后都隐藏着通信成功的大门 错误之四：结交错误的朋友 远离说“不”的人、怀疑论者和负能量的人，多结交鼓励者、激励者和成功人士 错误之五：不愿走出舒适圈 胜利者其实一直在“自找苦吃”。 领袖们会不断地走出舒适圈，寻求突破。 平庸本就是享尽舒适的最终结局。 错误之六：让暂时的挫折变成永久的失败 不要让一时的现状决定 了你未来的命运。 一旦你给自己贴上负面标签，挫折就会变得异样复杂。 成功人士会将一时的失败视作能往成功之路的阶梯。 错误之七：放任自己，随波逐流 独树一帜，也就意味着不断超越自我 独树一帜既是真实的自我 错误之八：认为获得成功的途径是有限的 世上的机会是无限的，人的潜能也是无止境的。 我们唯一要担心的就是思维的限度。 错误之九：挥霍光阴，不加珍惜 每日的忧虑背后隐藏着时间的馈赠。抛开忧虑，珍惜当下。  《七个习惯》 #  一、主动 二、以终为始 三、第一原理 四、双赢 五、共情 六、1+1&amp;gt;2 七、更新 </description>
    </item>
    
    <item>
      <title>docker模板</title>
      <link>https://example.com/docs/cache/template/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/cache/template/docker/</guid>
      <description>registry #  htpasswd -Bbn outrun asdf &amp;gt; auth/htpasswd docker-compose.yml registry: restart: always image: registry:latest # privileged: true ports: - 5000:5000 environment: REGISTRY_AUTH: htpasswd REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm REGISTRY_STORAGE_DELETE_ENABLED: &amp;quot;true&amp;quot; volumes: - ./data:/var/lib/registry - ./auth:/auth docker-compose up -d 客户端 /etc/docker/daemon.json {&amp;quot;insecure-registries&amp;quot;:[&amp;quot;127.0.0.1:5000&amp;quot;]} sudo systemctl daemon-reload sudo systemctl restart docker docker login 127.0.0.1:5000 docker tag java/device:1.0 127.0.0.1:5000/java/device:1.0 docker push 127.0.0.1:5000/java/device:1.0 curl --user outrun:asdf 127.0.0.1:5000/v2/_catalog # v2表示版本 registry:2 docker pull 127.0.0.1:5000/java/device:1.0  jenkins #  docker pull jenins mkdir /var/jenkins_home docker run -d --name myjenkins -p 49001:8080 -u 0 -v /var/jenkins_home:/var/jenkins_home jenkins # -u 0 用root帐户启动  nsenter #  # 不需ssh进入容器shell docker run -v /usr/local/bin:/target jpetazzo/nsenter # 安装 docker ps # 查看要进入的容器id docker inspect --format {{.</description>
    </item>
    
    <item>
      <title>iPad</title>
      <link>https://example.com/docs/computer/tool/ipad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/computer/tool/ipad/</guid>
      <description>alfred #  搜索 指定网站搜索 文件 剪贴板 计算器 自定义脚本 打字 命令 工作流  fantastical #  个人总结 名字 date 9th from 9.30p to 10.32p alert 30min 对象 Account - Calendar Sets - Cals(Subscription+Interesting) + Item(Events + Tasks) nlp 语法 事件 [with 人物] [at 地点] [at 日期时间] [on 日期] [from 日期时间] [to 日期时间] [of every 日期时间] 提醒 URL 日历 日期 特定 日期 11月1日 11/1 11.1 星期 周一 mon/tue/wed/tur/fri/sat/sun 相对 日期 15天后 after 15 days 星期 下周一 next mon 重复 日期 每月2号 every 2 星期 每周二 every tue 每隔两周的周三 on wed every 2 weeks 复合 7月1日到8月1日之间的每个周一周二 on mons tues from 7/1 to 8/1 区间 12月17日到次年1月3日是寒假 寒假 12/17-1/3 12/17~1/3 时间 24小时制 13 12小时制 下午一点 1p 1pm 分钟 下午一点半 13:30 1.</description>
    </item>
    
    <item>
      <title>Jetbrains</title>
      <link>https://example.com/docs/computer/tool/jetbrains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/computer/tool/jetbrains/</guid>
      <description>intellij idea #  注意 Project 相当于workspace, module 相当于工程 注册 服务器 # 发布网站 http://idea.lanyus.com http://idea.qinxi1992.cn http://idea.lianghongbo.com/licens http://im.js.cn:8888 javaagent https://zhile.io/ 快捷键 settings -&amp;gt; Keymap 设置eclipse alt + enter # 改错 shift shift # 搜索跳转 shift + f4 # 新窗口打开文件 类注释 settings -&amp;gt; Editor -&amp;gt; File and Code Templates -&amp;gt; Includes -&amp;gt; File Header /** * * @Description: ${Description} * @author: ShenWenqing * @date: Created on ${DATE} ${TIME} * */ alt + enter 可生成 serialVersionUID settings -&amp;gt; Inspections 勾选 Serializable class without &#39;serialVersionUID&#39; JDK Project Settings -&amp;gt; Project settings -&amp;gt; Build Tools settings -&amp;gt; Compilers 编码 file -&amp;gt; settings -&amp;gt; appearence里use custom font设置中文字体 file -&amp;gt; settings -&amp;gt; editor -&amp;gt; file encodings 三处utf-8 idea安装目录/bin/idea.</description>
    </item>
    
    <item>
      <title>linux模板</title>
      <link>https://example.com/docs/cache/template/linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/cache/template/linux/</guid>
      <description>/etc/fstab #  /dev/nvme0n1p5 /home ext4 defaults 0 2 /dev/nvme0n1p3 /home/outrun/nvme0n1p3 ntfs-3g defaults 0 0 # /dev/nvme0n1p6 UUID=b00fac49-46d7-43ef-aea7-256d82b862b2	/ ext4 rw,relatime,data=ordered	0 1 # /dev/nvme0n1p1 LABEL=ESP UUID=FE8F-730F /boot/EFI vfat rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro	0 2  /etc/resolv.conf #  nameserver 114.114.114.114  /etc/X11/xorg.conf.d/70-synaptics.conf #  Section &amp;quot;InputClass&amp;quot; Identifier &amp;quot;touchpad&amp;quot; Driver &amp;quot;synaptics&amp;quot; MatchIsTouchpad &amp;quot;on&amp;quot; Option &amp;quot;TapButton1&amp;quot; &amp;quot;1&amp;quot; Option &amp;quot;TapButton2&amp;quot; &amp;quot;3&amp;quot; Option &amp;quot;TapButton3&amp;quot; &amp;quot;2&amp;quot; Option &amp;quot;VertEdgeScroll&amp;quot; &amp;quot;on&amp;quot; Option &amp;quot;VertTwoFingerScroll&amp;quot; &amp;quot;on&amp;quot; Option &amp;quot;HorizEdgeScroll&amp;quot; &amp;quot;on&amp;quot; Option &amp;quot;HorizTwoFingerScroll&amp;quot; &amp;quot;on&amp;quot; Option &amp;quot;CircularScrolling&amp;quot; &amp;quot;on&amp;quot; Option &amp;quot;CircScrollTrigger&amp;quot; &amp;quot;2&amp;quot; Option &amp;quot;EmulateTwoFingerMinZ&amp;quot; &amp;quot;40&amp;quot; Option &amp;quot;EmulateTwoFingerMinW&amp;quot; &amp;quot;8&amp;quot; Option &amp;quot;FingerLow&amp;quot; &amp;quot;30&amp;quot; Option &amp;quot;FingerHigh&amp;quot; &amp;quot;50&amp;quot; Option &amp;quot;MaxTapTime&amp;quot; &amp;quot;125&amp;quot; Option &amp;quot;VertScrollDelta&amp;quot; &amp;quot;-50&amp;quot; Option &amp;quot;HorizScrollDelta&amp;quot; &amp;quot;-50&amp;quot; EndSection  /etc/systemd/system/docker.</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://example.com/about_me/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/about_me/</guid>
      <description>介绍 #  outrun，男，1990.4 934260428@qq.com runout.run  </description>
    </item>
    
    <item>
      <title>程序调试</title>
      <link>https://example.com/docs/ops/test/debug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/ops/test/debug/</guid>
      <description>分析方向 #  cpu #  方法调用 调用栈时长比例 录制时间内调用栈时长 火焰图(graph frames) 宽度: 方法耗时 高度: 调用栈深 排序是按字母的，颜色是随机的 subsecond offset heat map x轴: 秒 y轴: 一秒内各阶段 z轴: 颜色深度标记events采样数  内存 #  对象 对象个数、空间比例 调用栈分配比例  线程/协程 #  泄露 I/O阻塞 锁阻塞 channel阻塞  GC问题 #  少建对象  Linux #  time ftrace perf_events eBPF SystemTap LTTng ktap dtrace4linux OEL DTrace sysdig  Java #  VisualVM #  JProfiler #  # 收费, java  perfino #  # 监测jvm  YourKit #  # 收费, java, 有调用链  Spring Insight #  # java spring  Golang #  go命令 go tool pprof Xx.</description>
    </item>
    
    <item>
      <title>采用</title>
      <link>https://example.com/docs/computer/tool/adopt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/computer/tool/adopt/</guid>
      <description>趋向 #  本地(app) -&amp;gt; 线上(browser)  采用 #  工具 #  sidecar 信息: oneNote[oneDrive] 记录: todo, dayOne, 支付宝, moneyPro, 分享: snipaste, flameshot 输入 新 搜索: DEVONagent, wolframAlpha 渠道: pages, 知网, 博客, 知乎, 慕课, 网易公开课, 微信/qq, outlook 发散: 百度指数, DEVONSphere 盘: icloud, oneDrive x 2, 坚果云, 百度网盘 休闲: noizio, relaxMelodiesSeasions, earth3D 会议 notability[iCloud] GTD trello, microsoftToDo, things3 转换 文件 DEVONthink, siteSucker 字 字: wps-word, word, pdfElement, LaTeX, iAWriter, 代码: cacher[github], lepton[github], dash, snippetsLap, textastic misc: shortMenu 图 marginNote[iCloud], liquidText[iCloud] 影音 音频: permute3 图片: touchRetouch, auroraHDR, lensFlare, reflectStudio, superDenoising, Logoist, polarrPhoto, priimeStyles, tonality, QRFactory 视频: quickTime, gifox, gif brewery, gif maker, Hype3 3d: aurora3DMaker 修补 设备同步: synergy, pushbullet, sharemouse 人机: alfred, divvy, unclutter, workspaces, yoink, xscope, hazeOver, microSnitch 监视: istatistica, wifiExplorer 文件: FEFileExplorer 浏览器: tampermonkey 输出 字 大纲: drafts[iCloud], workflowy[workflowy], 幕布[幕布] 代码: jetbrains, vim, spacemacs 表达式: expressions 图 架构: visio, wps-ppt, ppt, OmniGraffle, 建模: plantUML, graphviz, 甘特图: OmniPlan, ganttProject, microsoftProject 表: excel, xmind[oneDrive], mindNode, ithoughts, scapple 数学: mathStudio, pocketCAS 画: procreator 库 结构: blog[github] 书: goodnotes  依赖 #  系统: 文件: tree, unrar, unzip, 7z, diff, du 系统: ntfs-3g, os-prober, network-manager, wireless-tools, systemctl, service 包: yaourt, yay, pkgfile, snap wps-office, ttf-wps-fonts 界面: awesome, i3-wm, arandr, xscreensaver, tmux, synergy, ibus, synaptics, pepper-flash, virtualbox 网络: chromium, firefox, thunderbird ops: shell: ^z, bg, fg, jobs, nohup, expect, 系统: sysdig, sysstat包(sar, sadf, mpstat, iostat, pidstat), ifconfig, top, htop, ps, df 网络: wireshark, netstat, ss, ping, telnet, iptables, wget, git, openssh, nc, nmap, nslookup vpn: openvpn, shadowsocks, polipo, v2ray vm: docker, docker-compose db: mysql, mariadb, postgresql, redis, mongodb, cassandra, neo4j elasticsearch, elasticsearch-head, elasticsearch-analysis-hanlp, elasticsearch-ik, elasticsearch-pinyin mq: nsq, rabbitmq, kafka, 容器: nginx, nginx-php 监控: zipkin, 应用: dokuwiki, tiddlywiki, wordpress, 服务: vsftpd, filezilla 分布式: ansible 程序: 基本: make, cmake, g++, gcc, lua, ruby, java: openjdk8, jdk8, jdk12, maven, tomcat go: go1.</description>
    </item>
    
  </channel>
</rss>
