<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>介绍 on outrun的笔记</title>
    <link>https://runout.run/</link>
    <description>Recent content in 介绍 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://runout.run/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>苹果</title>
      <link>https://runout.run/posts/apple/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/posts/apple/</guid>
      <description>伊甸的苹果、如今的苹果公司 其背后主使相同 其目的相同：创造一个本来不存在的产品，使人放不下 人放得下才得自在，放不下即达到了其它的目的，使人堕落 这个主使一直至力于渗透到人们生活中，在方方面面展示自己的标志、粉饰自己名号的形象 需要警惕 </description>
    </item>
    
    <item>
      <title>科技交互升维</title>
      <link>https://runout.run/posts/tech_dimension/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/posts/tech_dimension/</guid>
      <description> 内容形式 # DOS: 一维，按行做文字输入 Windows：二维，平台窗口 Reality：三维，模拟空间 展示形式 # 纸带：一维 显示器：二维 眼镜：三维 </description>
    </item>
    
    <item>
      <title>信息量</title>
      <link>https://runout.run/posts/information/</link>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/posts/information/</guid>
      <description> 随想 # 通常把认识到的时空称作4维(时间1+空间3)，即认为可观测到世界的所有信息量都在其中。 但世界的信息量不止于此，它的运作不可能是无故运动木偶般的3D动画，高维是必然存在的，是它在干预这个世界。 4维世界只是更高维世界驱动下的投影，所谓的现实世界只是可观测到的投影。 所以人本身就是高维存在的，它显然不是由4维时空驱动的。 我们从时间的维度观测，一个3维的球穿过2维的平面，它的投影是从无到有再从有到无，放大再缩小的圆。 那么递推一下，一个高维的“球”到3维的投影是什么样，可能是一个从无到有再从有到无，放大再缩小的球体。 同时，并不是所有的高维的实体，都会在3维世界产生投影，就像不是所有的3维球体，都要穿过某个2维的平面。 所以： 1 世界不是4维的，因为其背后实体是高维的，投影种类繁多不一定是4维可见，如因果、感受。 1 我们观测到的投影，其背后的实体是复杂的，它透露出的信息是引人深思的。 2 我们观测不到却能莫名感受到的，其实体也存在，只是它把信息量投影到了”感受“这个维度。 3 我们毫无体查的并非不存在，无知的边界远大于已知，”眼见为实“的观点是错误的。 4 不存在偶然现象，所谓的偶然，只是观测到的投影，从无到有出现，又从有到无消失了 </description>
    </item>
    
    <item>
      <title>整理笔记到github</title>
      <link>https://runout.run/posts/note/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/posts/note/</guid>
      <description>记笔记 # 由于从事软件行业，信息量大，所以养成了记笔记的习惯。 笔记可以按自己的格式和思路写自己需要的，也便于查看。网上的东西对自己来说比较杂乱。 自学的都记了下来了，工作上的少些。
笔记变更史 # 一开始用的是linux论坛上推荐的一个工具，现在名字都忘了。 后来一直在用mybase，感觉不错，到现在有5年了。但有几个问题:
linux下容易打出乱码字符。 删除文档容易出bug。 格式不太好，版本7后用了html做内容，也会有些问题。 是本地数据库，没法在线备份，也不好分享。毕竟东西都放网上比较方便。 软件是收费的。（但开发者很良心，修改下软件配置就可以接着用，这个&amp;quot;bug&amp;quot;他们一直不修复） 一直在考虑有道云笔记，开始时它功能不全，没有用。现在功能不错了，我又不想用了。 因为我想自己做一个，容易满足自己的想法和维护。 除这些之外gitbook也可以考虑
Notion的问题： 数据不能备份，数据不一定安全，不能定制化建站
现在 # 这里是用了hugo和它的book主题，多谢它们的作者。 经过一段时间的整理，今天这个笔记可以用了，其它细节用到时再调整。</description>
    </item>
    
    <item>
      <title>博客原则</title>
      <link>https://runout.run/posts/first/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/posts/first/</guid>
      <description> 博客原则 # 做有意义的分享 </description>
    </item>
    
    <item>
      <title>LinuxProgram</title>
      <link>https://runout.run/docs/tool/linux/linux_program/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/linux/linux_program/</guid>
      <description> 系统编程 # 进程通信 # 对象 ipc 种类 消息队列 共享内存 信号量 消息队列 错误处理 # curedump机制, 产生core文件 命令 ulimit 目录 /proc/[pid]/ fork # 介绍 子线程 epoll # 介绍 多路复用io接口，提高大量并发连接中只有少量活跃情况下系统cpu利用率 signals # 介绍 unix系统中出错时显示的错误码（通常是拼在最后） http://people.cs.pitt.edu/~alanjawi/cs449/code/shell/UnixSignals.htm SIGHUP	1	Exit	Hangup SIGINT	2	Exit	Interrupt SIGQUIT	3	Core	Quit SIGILL	4	Core	Illegal Instruction SIGTRAP	5	Core	Trace/Breakpoint Trap SIGABRT	6	Core	Abort SIGEMT	7	Core	Emulation Trap SIGFPE	8	Core	Arithmetic Exception SIGKILL	9	Exit	Killed SIGBUS	10	Core	Bus Error SIGSEGV	11	Core	Segmentation Fault SIGSYS	12	Core	Bad System Call SIGPIPE	13	Exit	Broken Pipe SIGALRM	14	Exit	Alarm Clock SIGTERM	15	Exit	Terminated SIGUSR1	16	Exit	User Signal 1 SIGUSR2	17	Exit	User Signal 2 SIGCHLD	18	Ignore	Child Status SIGPWR	19	Ignore	Power Fail/Restart SIGWINCH	20	Ignore	Window Size Change SIGURG	21	Ignore	Urgent Socket Condition SIGPOLL	22	Ignore	Socket I/O Possible SIGSTOP	23	Stop	Stopped (signal) SIGTSTP	24	Stop	Stopped (user) SIGCONT	25	Ignore	Continued SIGTTIN	26	Stop	Stopped (tty input) SIGTTOU	27	Stop	Stopped (tty output) SIGVTALRM	28	Exit	Virtual Timer Expired SIGPROF	29	Exit	Profiling Timer Expired SIGXCPU	30	Core	CPU time limit exceeded SIGXFSZ	31	Core	File size limit exceeded SIGWAITING	32	Ignore	All LWPs blocked SIGLWP	33	Ignore	Virtual Interprocessor Interrupt for Threads Library SIGAIO	34	Ignore	Asynchronous I/O pf-kernel # 介绍 是linux kernel 的fork, pf代表post-factum, 是作者的nickname libev # libevent 介绍 是linux kernel 的fork, pf代表post-factum, 是作者的nickname </description>
    </item>
    
    <item>
      <title>LinuxScene</title>
      <link>https://runout.run/docs/tool/linux/scene/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/linux/scene/</guid>
      <description>场景 # 路由 # 查路由表 ip ro route -n 改路由 route del -net 192.168.0.0 netmask 255.255.255.0 gw 10.146.81.117 转发 ip ro ad 192.168.0.0/24 via [主机ip] 主机配置 echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward # etc/sysctl.conf net.ipv4.ip_forward = 1 方案 # 高并发 # 查看当前TCP连接的状态和对应的连接数量： netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39; # TIME_WAIT占用端口会影响后继新连接 初步优化（提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN攻击。） /etc/sysctl.conf net.ipv4.tcp_syncookies = 1 # 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 # 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.</description>
    </item>
    
    <item>
      <title>LinuxTool</title>
      <link>https://runout.run/docs/tool/linux/linux_tool/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/linux/linux_tool/</guid>
      <description>辅助 # 快捷键 # ctrl alt f1/f2/... # 终端切换 帮助 # man -f # 简要介绍 -k # 通配搜索 whatis # man -f apropos # man -k 命令行 # clear pwd # 当前路径 bash -c # 执行命令字符串 set -o # 设置快捷键模式，默认emacs 快捷键 &amp;lt;Tab&amp;gt; bash补全 &amp;lt;C-c&amp;gt; 中断 &amp;lt;C-d&amp;gt; eof &amp;lt;C-tab&amp;gt; ls &amp;lt;C-l&amp;gt; clean &amp;lt;C-a&amp;gt; 移到行首 &amp;lt;C-e&amp;gt; 移到行尾 &amp;lt;C-u&amp;gt; 删除到行首 &amp;lt;C-k&amp;gt; 删除到行尾 &amp;lt;C-p&amp;gt; 上一个命令 &amp;lt;C-n&amp;gt; 下一个命令 &amp;lt;C-r&amp;gt; 查看历史 # &amp;lt;C-s&amp;gt; 向前查看历史 &amp;lt;C-s&amp;gt; 冻结 &amp;lt;C-q&amp;gt; 解冻 &amp;lt;C-t&amp;gt; 交换字符 &amp;lt;C-w&amp;gt; 删word &amp;lt;C-z&amp;gt; 暂停到后台 &amp;lt;C-\&amp;gt; 中断 &amp;lt;C-/&amp;gt; 撤消 &amp;lt;C-_&amp;gt; 删除一行 &amp;lt;M-r&amp;gt; 取消历史变更 场景 禁用&amp;lt;C-s&amp;gt;&amp;lt;C-q&amp;gt;, 以使&amp;lt;C-s&amp;gt;变为向前查看历史 stty -ixon -ixoff stty STOP ^w # 把原&amp;lt;C-s&amp;gt;改成&amp;lt;C-w&amp;gt; zsh fish tmux session window pane ~/.</description>
    </item>
    
    <item>
      <title>Monitor</title>
      <link>https://runout.run/docs/tool/ops/monitor/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/ops/monitor/</guid>
      <description>基础 # 监控的方式 主动、被动、旁路（舆情） 监控类型 服务端监控、客户端监控 目标 全、块、准 指标 请求量、成功率、耗时 统计 # 指标 访问、访客 停留时长 跳出率 退出率 转化率 参与度 显示方式 选时间段 时序数据表 max、min、avg 埋点 通过可视化工具配置，非硬编码 第三方 友盟 百度移动 魔方 App Annie talking data 神策数据 物理机 # Load Average # 介绍 数字n表示n倍 cpu # Usage: 100% system user IO wait Saturation: 1.0core Max Core Usage: 1.0core Interrupts and Context Switches: 10k Processes: 10ops create(Forks) Runnable Blocked mem # Physical Memory: RAM(Random-Access Memory)存储器 used free buffers Virtual Memory 介绍 映射到RAM或Disk used available Swap Space used free Swap Activity swap in(read) swap out(write) disk # space 增长趋势 I/O Activity read(page in) write(page out) File Descriptors: 1Milion limit allocated I/O Latency: 5ms write read I/O Load: 3 write read network # traffic: MB/s inbound outbound Utillization Hourly: GB sent received Local Network Errors: 0ops transmit drop receive drop transmit errors TCP Retransmission segments retransmitted: 0ops retransmit ratio: 0% 应用监控 # Prometheus # 监控, go实现 Grafana # 监控 Zabbix # 分布式监控 Nagios # 监控 Ganglia Zenoss Open-falcon emq # mqtt broker, erlang开发, 管理控制台 APM # # Application Performance Management SkyWalking CAT Jaeger Pinpoint Zipkin Dapper # C# Mysql # 总览 Services: 38 Min MySQL Uptime: 20 hours Max MySQL Uptime: 2.</description>
    </item>
    
    <item>
      <title>Security</title>
      <link>https://runout.run/docs/architect/code/security/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/code/security/</guid>
      <description>服务器 # 木马 # 自变异木马 改变自身hash或将自身大量复制到不同目录, 后台运行，躲避清理 自删除 伪装成系统程序或绑定系统程序 检查 可疑进程 定时任务 启动项 /etc/init.d或service --status-all systemctl list-unit-files | grep enabled 经验 # libudev.so # 自变异，/bin/下生成随机名称命令, 启动后可远程执行命令，在/etc/init.d下创建自启动项，在/etc/crontab中添加定时任务 chmod 0000 /lib/libudev.so &amp;amp;&amp;amp; rm -rf /lib/libudev.so &amp;amp;&amp;amp; chattr +i /lib/ /etc/init.d下随机名称文件删除, /etc/rc{0,1,2,3,4,5,6,S}.d中的软链删除 /etc/crontab/gcc.sh删除 sed &#39;/gcc.sh/d&#39; /etc/crontab &amp;amp;&amp;amp; chmod 0000 /etc/crontab &amp;amp;&amp;amp; chattr +i /etc/crontab 删除定时任务 重启 chattr -i /lib /etc/crontab 恢复可写 DDoS # 防范方法 # 漏洞扫描 # DVWA # Damn Vulnerable Web Application，PHP + MySQL模拟Web漏洞 W3af # Web应用扫描, Python实现 OpenVAS # 扫描主机漏洞 网络隔离 # 内外网分离 登录跳板机 Web安全 # XSS # # 向网页注入代码 CSRF # # Cross-Site Request Forgery, 跨站请求伪造 SQL注入 # Hash Dos # 上传大Json Object, 利用Hash算法的伪随机性，制造Value不同但Hash碰撞的数据，耗尽CPU 上传文件脚本 # 伪造Content-Type上传静态资源，再URL访问执行 防范方法 # 验证码 # 根据滑动响应时间、拖拽速度、时间、位置、轨迹、重试次数来评估风险 信息存储 # 密码非明文保存，加salt 身份证号、手机号加&amp;quot;*&amp;quot; 联系方式显示与否用户自己配置 加密 # 对称加密 DES # 56位秘钥，已被AES取代 3DES # 做3次DES AES # 128、192、256位秘钥 Blowfish # 1到448位变长秘钥 非对称加密 RSA # DSA # 性能快于RSA，只能数字签名 ECDSA # 螺旋曲线加密算法 ECC # 256位ECC秘钥相当于3072位RSA秘钥 哈希算法 MD5 # 不再安全 SHA-1 # 不再安全 SHA-256 授权、认证 # RBAC、ABAC SSO OAuth2.</description>
    </item>
    
    <item>
      <title>Eclipse</title>
      <link>https://runout.run/docs/tool/develop/eclipse/</link>
      <pubDate>Thu, 11 Oct 2018 18:33:08 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/develop/eclipse/</guid>
      <description>方案 # user library发布 项目右键 -&amp;gt; properties -&amp;gt; Deployment Assembly -&amp;gt; add -&amp;gt; javaBuild Path Entries中选择发布包 tomcat设置发布到外部 new server -&amp;gt; 直接finish 右键server -&amp;gt; open 修改server location -&amp;gt; use Tomcat installation 修改server location -&amp;gt; deploy path为webapps 修改TimeOuts -&amp;gt;所有时间为1200 java版本 window -&amp;gt; preferences -&amp;gt; java -&amp;gt; compiler window -&amp;gt; preferences -&amp;gt; java -&amp;gt; installed JREs 编码 general -&amp;gt; workspace Text file encoding general -&amp;gt; content types Text -&amp;gt; java source file defalt encoding输入UTF-8并点击update 快捷键 general -&amp;gt; editors -&amp;gt; keys content assist # 代码提示 word comletion # 代码补全 插件 # market place http://www.</description>
    </item>
    
    <item>
      <title>VIM</title>
      <link>https://runout.run/docs/tool/develop/vim/</link>
      <pubDate>Thu, 11 Oct 2018 18:31:16 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/develop/vim/</guid>
      <description>编译 # --with-features=tiny # 只包含最基本功能。small, normal, big, huge, :h feature-list查看 命令 # vim -u NONE -N # -u NONE 不加载配置文件和插件，并进入vi兼容模式 -u code/essential.vim # 加载指定配置文件 -N set nocompatible # 不进入vi兼容模式 --version # 可查看特性 mode # 普通模式 插入模式 可视模式 v/V # 面向字/面向行 可视模式 &amp;lt;C - v&amp;gt; # 面向块 可视模式 gv # 重选上次选区 o # 切换到选区的开头, 再按切换回尾端　替换模式 R 命令行模式(Ex命令) : # 可视模式中选定范围，切换到命令行时，自动输入range&#39;&amp;lt;,&#39;&amp;gt;代表选中区 操作符待决模式 # operator 与 motion之间的空闲时期 # 两个字符的operator, 字符间的空闲时期不是该模式，是命名空间，是普通模式的扩充 # 有了这个模式，能创建自定义映射项来激活或终结操作符待决模式，就可以自定义operator和motion 选择模式 # 类似windows中选中 &amp;lt;C - g&amp;gt;在可视和选择模式切换 历史 q: # 命令历史 q/ # 搜索历史 operate # 思想 {operator}{motion} {operator}{text-objects} shortcut key ctrl + c # 同Esc motions .</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://runout.run/docs/tool/ops/docker/</link>
      <pubDate>Thu, 11 Oct 2018 18:18:21 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/ops/docker/</guid>
      <description>基础 # 介绍 基于linux LXC，可以实现虚拟化 优点 低成本、高利用率、充分灵活、动态调度 核心网的最终形态 目录 /var/lib/docker 配置 # 镜象网站 https://hub.docker.com/ 阿里云个人仓库 入口: cr.console.aliyun.com docker login -u 934260428@qq.com registry.cn-qingdao.aliyuncs.com docker tag java/device:1.0 registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0 docker push registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0 docker pull registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0 /etc/sysconfig/docker # /etc/init.d/docker.conf OPTIONS=&#39;--selinux-enabled --log-driver=journald --insecure-registry 45.55.56.16:5000 --dns 8.8.8.8&#39; DOCKER_CERT_PATH=/etc/docker 命令 # 常用系统命令 # systemctl daemon-reload systemctl restart docker docker # -h version login docker login -u outrun -p asdf search mysql # 搜索镜像 pull centos:7 # 下载镜像 centos:latest outrun11/test:nginx1 image ls pull rm images centos # 本地镜象列表 rmi centos:latest # 删除镜象 container run # 新建容器 --user root --name a --privileged --name # 显示名 -t # 伪tty, -i 交互的 -rm=true # 执行完后删除 -v /etc/:/opt/etc/ # 挂载本机/etc到容器/opt/etc, /etc/:/opt/etc/:ro 只读挂载, /etc/ 对外共享/etc -p 1234:80 # 端口映射本机1234端口到容器80 --volumes-from etc_share # 使用另一个容器对外共享的磁盘 -d # 后台运行 --link redis_server:redis # 连接容器的redis命令 -w /var/node # 当前工作目录 -e NODE_ENV=&#39;&#39; # 环境变量 --net=bridge # 网络模式，bridge使用虚拟网桥docker0, host共享主机命名空间, container与已存在的一个容器共享命名空间, none关闭网络功能, overlay --name nsqd -p 4150:4150 nsqio/nsq /nsqd # 端口 -it centos /bin/bash # 启动容器, 执行bash b15 /bin/echo &#39;hello&#39; # 启动容器 -it --rm=true --name=ls-volume -v /etc/:/opt/etc/ centos ls /opt/etc # 创建共享 -it -p 1337:1337 --name=etc_share -v /etc/ centos mkdir /etc/my_share &amp;amp;&amp;amp; /bin/sh -c &amp;quot;while true; do echo hello; sleep 1; done&amp;quot; # 持续运行 -it --rm=true --volumes-from etc_share --name=ls_etc centos ls /etc # 使用共享 exec # 已有容器中运行 -i -t ls start 026 # 启动已建立的容器, id可以只输入前几位 cp 026e:/docker/file /local/file stop 026 restart 026e attach 026 # 进入容器运行命令行, 可显示日志 kill 026e prune ps -a # 容器列表 rm # 移除容器 docker rm docker ps -aq # 移除所有未运行的容器 rm -f 026 build .</description>
    </item>
    
    <item>
      <title>Kubernetes</title>
      <link>https://runout.run/docs/tool/ops/k8s/</link>
      <pubDate>Thu, 11 Oct 2018 18:18:21 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/ops/k8s/</guid>
      <description>常用 # 查看 # 系统日志 journalctl -u kubelet | tail kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -nmdw 日志 kubectl logs -f --since=5m --all-containers=true -lapp=[svcName] -o wide kubectl get pod [podName] -o yaml kubectl get pods -nmdw-log -l app=logstash-logstash -w # 等待启动 kubectl describe pods [podName] kubectl rollout status deploy/[deployName] # 查升级记录 kubectl get events -njnc -oyaml --field-selector=type=Normal # Normal, Warning 查ns所有资源 kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -nairflow 查节点详情 kubectl get nodes -o json 查扩缩状态 kubectl rollout status deploy/[deployName] 查所有nodeport kubectl get svc --all-namespaces -o go-template=&#39;{{range .</description>
    </item>
    
    <item>
      <title>Mongodb</title>
      <link>https://runout.run/docs/db/mongodb/</link>
      <pubDate>Thu, 11 Oct 2018 16:00:15 +0800</pubDate>
      
      <guid>https://runout.run/docs/db/mongodb/</guid>
      <description>特点 # 数据结构json(bson) 易写入，易修改 c++编写 分布式 介于关系数据库 和 非关系数据库之间 查询语句强 支持索引 bson格式 注意 # document不能大于4Mb 可以非安全模式异步马上成功 每个连接用队列存储命令 数据结构定义 # collection # 表 document # 记录 field(key, value) # 字段(field)与值(value) 与关系型数据库的区别 document中的field不要key俱全或一样 find()命令查询 bson的数据类型 # ＃bson 是json的扩展 # 增加了数据类型 # 把json数据转换成二进制码存到文件 null boolean undefined 数组 # 如{gps: [20, 56]} 32位和64位整数 # shell中不支持 ## node.js python java等高级语言的驱动中支持 64位浮点 # shell使用的全是这种类型, 如{x:3.14} utf-8 # 字符串类型 ObjectID Date # 如{x:new Date()} 正则 # 如{x:/uspcat/i} javascript块代码 # 如{x:function(){}} ## 相当于存储过程 内嵌文档 # 如{x: {xx: &amp;quot;a&amp;quot;}} 二进制 # shell中不能使用 ObjectId # 大小 12字节 显示为24个十六进制字符 # 空间换时间的思想 细节 前4字节是unix时间戳 后3字节集群machine hash 后2字节pid 后3字节inc自增计数器, 在前面都相等时全局自增 命名 # 数据库与集合名 不能是空字符串 特殊字符 &#39; (空格) , $ / \ \0 应该全小写 小于64字节 数据库名不与保留库名相同，如 admin, local, config 集合名 db-text合法，但不能db.</description>
    </item>
    
    <item>
      <title>Postgre SQL</title>
      <link>https://runout.run/docs/db/postgresql/</link>
      <pubDate>Thu, 11 Oct 2018 15:34:29 +0800</pubDate>
      
      <guid>https://runout.run/docs/db/postgresql/</guid>
      <description>命令 # initdb # 初始化数据库 --locale en_US.UTF-8 -D &#39;data&#39; postgres # 启动数据库 -D 目录 -p 6543 pg_ctl start # 控制数据库: start, stop等 -D data -l a.log postmaster -D /data psql -d db1 -h localhost -p 5432 -U 用户名 -W # 强制要求验证密码 -f 导入sql命令文件, 或者在末尾加 &amp;lt; a.sql 来导入 -L 导出日志文件 o-&amp;gt; psql -U outrun -f pg.sql db1 # 导入数据 pg_dump # 导出数据库 -f # 指定文件 -U # 用户 -E UTF8 # 编码 -h localhost -n public # 指定schema -a # 只导数据，没有schema -F t # 压缩成tar o-&amp;gt; pg_dump -U outrun -f pg.</description>
    </item>
    
    <item>
      <title>Java响应式编程</title>
      <link>https://runout.run/docs/pl/java/java_reactive/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/java/java_reactive/</guid>
      <description>Java响应式层级 # Level 0: Thread &amp;amp; Runnable (Java 1+) Level 1: ExecutorService, Callable, Future (Java 5+) Level 2: ForkJoinPool (Java 7+) Level 3: CompletableFuture (Java 8+) Level 4: reactive streams, Flow (Java 9+) Level 5: HTTP/2 client (Java 11+) Level 6: Reactive libraries (RxJava, Reactor) Level 7: Reactive services (Vert.x, Spring, Kafka) Flow # Flow.Publisher Flow.Subscriber Flow.Subscription # link publisher和subscriber Flow.Processor # subscriber和publisher的act ReactiveX # Flux Mono RxJava # 模型	Observable Subscriber Reactor # Vert.</description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://runout.run/docs/middleware/container/nginx/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://runout.run/docs/middleware/container/nginx/</guid>
      <description>基础 # 结构 一个主进程(root权限运行)和多个工作进程(普通权限运行) 优点 异步非阻塞 非常稳定 反向代理 后端服务io能力不高，nginx buffer http请求直到完整，再发送到后端。同样buffer响应 相对apache 轻量 apache阻塞 占资源低 模块化设计 社区活跃, bug少 多进程模型 使用epoll 多worker处理，业务阻塞时切换调度, 结束阻塞时分配 模块 handler filter upstream load-balance 功能 http 可以保持session， 相同的ip分配到同一个服务器上 缓存静态页面到内存，建立索引与自动索引 反向代理 负载均衡 模块化 过滤器 gzipping, byte ranges, chunked responses, SSI-filter 支持SSL与TLS SNI imap/pop3代理 命令 nginx -c /etc/nginx/nginx.conf nginx -s quit nginx -s stop nginx -s reload # 重载设置 ## service nginx reload nginx -v # 查看版本 ## -V nginx -t [-c nginx.</description>
    </item>
    
    <item>
      <title>Nodejs</title>
      <link>https://runout.run/docs/middleware/container/nodejs/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://runout.run/docs/middleware/container/nodejs/</guid>
      <description>基础 # 特点 commonJS规范 javascript书写(v8引擎) js设计之初就可以运行在后端 v8 成熟的事件驱动模式 没有i/o库, 没有历史包袱 v8性能好 单线程 不用在意多线程状态同步(没有死锁, 没有上下文切换) 无法利用多核, 错误时应用退出，计算密集时无法调度 # child_process解决 事件驱动(event-driven), 回调 event loop [while(true)] -&amp;gt; watcher -&amp;gt; handles watcher产生事件后, event loop取到并执行其handle(回调函数) event loop每一周询问多个watcher是否有事件 event loop中没有watcher时进程退出 http模块就是启动了一个watcher,所以执行后进程不结束 其它watcher有 timer, fs, udp/req, process 不同操作系统中event driven的实现: windows: IOCP Linux: epoll Mac:kqueue 非阻塞io(non-blocking i/o model) io与数据处理分离（所以必须异步） 线程池结合event-driven实现 异步io go语言有协程(coroutine)而node.js没有，协程可以同步式编程 # 有第三方协程模块 promise(commonJs的规范, 其实现有whenJs, Q) # 书写难度降低 eventProxy # 朴灵 async/step commonJS 模块 var math = require(&#39;math&#39;) # 缓存优先，核心模块优先。依次找.</description>
    </item>
    
    <item>
      <title>Spring Cloud</title>
      <link>https://runout.run/docs/middleware/distributed/spring_cloud/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://runout.run/docs/middleware/distributed/spring_cloud/</guid>
      <description>亿级流量 # 流量接入层 # 二级域名 泛域名 A记录 dns解析 udp 向网关请求dns解析 httpDNS 用ip请求http服务, 返回域名解析的ip 因为用ip请求，适合app，不适合网页 lvs + keepalive # 多lvs时用dns负载 nginx openresty kong 动静分离 cdn dns动态域名解析 cdn分发服务 源服务拉取FastDFS CDN节点分发 WEB服务层 # webflux 不基于重量的servlet标准 基于netty Eureka # 使用 @EnableEurekaServer application.properties eureka.client.register-with-eureka=false # 是否注册自己 eureka.client.fetch-registry=false # 是否拉取eureka eureka.client.service-url.defaultZone=http://localhost:7900/eureka/ # 设置注册中心的URL eureka.instance.hostname=euk1.com spring.application.name=EurekeServer # eureka集群中各节点要同名 行为 register # 注册 renew # 通过心跳, 默认30s。三次失败删除实例 fetch registry # 拉注册的信息 cancel # 发取消请求，删除实例 time lag # 同步时间延迟 communication mechanism # 通讯机制，默认jersey和jackson 功能 唯一标识 # service id 主机名:application.</description>
    </item>
    
    <item>
      <title>Bootstrap</title>
      <link>https://runout.run/docs/middleware/library_frontend/bootstrap/</link>
      <pubDate>Thu, 11 Oct 2018 09:39:11 +0800</pubDate>
      
      <guid>https://runout.run/docs/middleware/library_frontend/bootstrap/</guid>
      <description>介绍 # 在jquery基础上的组件框架 移动 # &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt; css # 全局 container # div, 唯一包裹容器 container-fluid # 占全部视口 栅格 # 必须放在row内 col-xs-1 # 适用于大于等于分界点的屏幕 ## 大于12的最后那个col另起一行排列 # xs &amp;lt; 768px 宽度, container 最大宽度: 自动 # sm &amp;gt;= 768px, 750px # md &amp;gt;= 992px, 970px # lg &amp;gt;= 1200px, 1170px col-md-offset-4 # 向右偏移4 col-md-pull-9 # 向后推9, 改变元素的顺序 col-md-push-3 o-&amp;gt; mixin make-row 如 .wrapper {.make-row();} make-xs-column make-sm-column-offset make-sm-column-push make-sm-column-pull 样式 # muted # 文本颜色 text-warning text-error text-info text-success text-left # 文本左对齐 text-center text-right text-justify text-nowrap text-lowercase text-uppercase text-capitalize bg-primary # p bg-success bg-info bg-warning bg-danger success # 状态类 # table行颜色, control-group div error danger warning info active has-warning # div元素 # 适用class: control-label, form-control, help-block has-error has-success has-feedback # div, pull-right # 任意元素向右浮动 pull-left navbar-right # 导航条中向右浮动 navbar-left clearfix # 清除浮动 initialism # 缩略语样式, abbr标签 small # small标签的样式 lead # p标签，突出显示 blockquote-reverse # blockquote标签使用, 内容右对齐 disabled # btn, input, 只disable样式 o-&amp;gt; 适用的class radio radio-inline checkbox checkbox-inline o-&amp;gt; 适用的标签 fieldset inline # 行内ul, checkbox center-block # 任意元素, 水平居中 show # 任意元素显示 hidden .</description>
    </item>
    
    <item>
      <title>Threejs</title>
      <link>https://runout.run/docs/middleware/library_frontend/threejs/</link>
      <pubDate>Thu, 11 Oct 2018 07:58:16 +0800</pubDate>
      
      <guid>https://runout.run/docs/middleware/library_frontend/threejs/</guid>
      <description>介绍 # 协调程序加载项的类库 使用 # var preload = new createjs.LoadQueue(false, &amp;quot;assets/&amp;quot;); var plugin= { getPreloadHandlers: function(){ return{ types: [&amp;quot;image&amp;quot;], callback: function(src){ var id = src.toLowerCase().split(&amp;quot;/&amp;quot;).pop().split(&amp;quot;.&amp;quot;)[0]; var img = document.getElementById(id); return {tag: img}; } } } } preload.installPlugin(plugin); preload.loadManifest([ &amp;quot;Autumn.png&amp;quot;, &amp;quot;BlueBird.png&amp;quot;, &amp;quot;Nepal.jpg&amp;quot;, &amp;quot;Texas.jpg&amp;quot; ]); api # 涉及dom # 属性 window.innerWidth window.innerHeight 事件 window.addEventListener(&#39;resize&#39;, onWindowResize, false); function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); controls.handleResize(); } 三大组件 场景(scene) var scene = new THREE.</description>
    </item>
    
    <item>
      <title>Angular</title>
      <link>https://runout.run/docs/middleware/library_frontend/angular/</link>
      <pubDate>Thu, 11 Oct 2018 07:47:51 +0800</pubDate>
      
      <guid>https://runout.run/docs/middleware/library_frontend/angular/</guid>
      <description>介绍 # google发布 提倡SPA(Single Page Apps), 运行快，一次加载 mvvm 特点 # 前端mvc 双向数据绑定 指令和语义化标签 模块化工具 依赖注入 html模板 常用工具封装，如$http $cookies $location directive # 内置 ng-app # 声明app名, 在最外层 ng-submit # &amp;lt;form ng-submit=&amp;quot;submit()&amp;quot;&amp;gt; ng-controller ng-repeat # $index返回当前引用的元素序号，$first, $middle, $last 返回布尔值 ng-model # 绑定当前元素的值 ng-click ng-eventhandler=&amp;quot;expression&amp;quot;类的指令可以在所有浏览器中有相同的行为，angular将会屏蔽差异性 不会在全局命名空间中进行操作，指定的表达式只能访问元素控制器作用域范围内的函数和数据 ng-bind ng-change &amp;lt;form ng-submit=&amp;quot;aaFunc()&amp;quot;&amp;gt; # 会阻止浏览器默认的提交操作 ng-dblclick ng-show ng-hide ng-class # 可以是类名字符串，空格分隔，可以是类名数组，可以是类名到布尔值的映射 ng-class=&amp;quot;{true: &#39;active&#39;, false: &#39;inactive&#39;}[isActive]&amp;quot; ng-class=&amp;quot;{&#39;selected&#39;: isSelected, &#39;car&#39;: isCar}&amp;quot; ng-style # templete中写css不好维护 ng-src=&amp;quot;/images/cats/{{favoriteCat}}&amp;quot; # src，href属性中简单使用templete,由于浏览器优先并行加载图片和其它内容,angular没有机会拦截到数据绑定请求，所以无法运行 ng-href ng-options &amp;lt;select ng-model=&amp;quot;x&amp;quot; ng-options=&amp;quot;(m.</description>
    </item>
    
    <item>
      <title>Jquery</title>
      <link>https://runout.run/docs/middleware/library_frontend/jquery/</link>
      <pubDate>Thu, 11 Oct 2018 07:34:03 +0800</pubDate>
      
      <guid>https://runout.run/docs/middleware/library_frontend/jquery/</guid>
      <description>对象命名方式 # var $a = $(&amp;quot;#inputID&amp;quot;); 选择器（选择多个时形成数组） # 基本选择器 $(&amp;quot;#inputID&amp;quot;); # id选择 $(&amp;quot;input&amp;quot;); // 标签名,默认获取第一个 # 标签名选择 $(&amp;quot;.className&amp;quot;); // 按样式名定位 # 样式名选择 $(&amp;quot;#div1ID,.myClass,p&amp;quot;); # 选择多个 $(&amp;quot;*&amp;quot;); # 所有元素 层级选择器 $(&amp;quot;form input&amp;quot;) # form所有后代元素中input元素的个数 $(&amp;quot;form&amp;gt;input&amp;quot;) # form子元素中input元素个数，不包括下层元素 $(&amp;quot;form+input&amp;quot;) # form同级并且下面的第一个input元素 $(&amp;quot;form~input&amp;quot;) # form同级并且下面的所有input元素 子元素选择器 # 只选择一个 $(&amp;quot;ul li:first&amp;quot;) # ul中第一个子元素li $(&amp;quot;ul li:last&amp;quot;) # ul中最后一个子元素li $(&amp;quot;input:not(:checked)&amp;quot;) # input标签中所有未选中的元素 $(&amp;quot;table tr:even&amp;quot;) # 表格的奇数行（索引号为偶数） $(&amp;quot;table tr:odd&amp;quot;) # 表格的偶数行（索引号为奇数） $(&amp;quot;table tr:eq(1)&amp;quot;) # table中索引号等于1的行 $(&amp;quot;table tr:gt(0)&amp;quot;) # table中索引号大于0的行（不包括0） $(&amp;quot;table tr:lt(2)&amp;quot;) # table中索引号小于2的行（不包括2） $(&amp;quot;:header&amp;quot;) # 匹配如 h1, h2, h3之类的标题元素 内容选择器 $(&amp;quot;div:contains(&#39;Join&#39;)&amp;quot;) # div 标签的html()中包含&#39;Join&#39;字符串的元素 $(&amp;quot;p:empty&amp;quot;) # p 标签的html()的内容为空的元素 $(&amp;quot;div:has(p)&amp;quot;) # div标签中包含p标签的该div标签 $(&amp;quot;p:parent&amp;quot;); # 非空的p标签元素，即p为父元素 可见性选择器 $(&amp;quot;tr:hidden&amp;quot;) # 查找隐藏的tr元素，如&amp;lt;tr style=&amp;quot;display:none&amp;quot;&amp;gt; &amp;lt;td&amp;gt;Value 1&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; $(&amp;quot;tr:visible&amp;quot;) # 查找可见的tr元素 属性选择器 $(&amp;quot;div[id]&amp;quot;) # 含有id属性的div元素 $(&amp;quot;input[name=&#39;newsletter&#39;]&amp;quot;) # 所有name属性是newsletter的input元素 $(&amp;quot;input[name!</description>
    </item>
    
    <item>
      <title>React</title>
      <link>https://runout.run/docs/middleware/library_frontend/react/</link>
      <pubDate>Thu, 11 Oct 2018 07:32:08 +0800</pubDate>
      
      <guid>https://runout.run/docs/middleware/library_frontend/react/</guid>
      <description>介绍 # facebook推出的用于build user interfaces 的类库 使用 # o-&amp;gt; webpack # webpack.config.js var webpack = require(&#39;webpack&#39;) module.exports = { devtool: &#39;inline-source-map&#39;, entry: [&#39;webpack/hot/dev-server&#39;, __dirname + &#39;/app/main.js&#39;], output: { path: __dirname + &#39;/build&#39;, filename: &#39;bundle.js&#39; }, module: { loaders: [ { test: /\.(js|jsx)$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, } ] }, plugins: [ new webpack.HotModuleReplacementPlugin(), new webpack.DefinePlugin({ &#39;process.env&#39;: { NODE_ENV: JSON.stringify(&#39;production&#39;) } }) ], devServer: { contentBase: __dirname + &#39;/build&#39;, historyApiFallback: true, inline: true, port: 3031, } } # index.</description>
    </item>
    
    <item>
      <title>产品规划</title>
      <link>https://runout.run/docs/architect/method/product_plan/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/method/product_plan/</guid>
      <description>云服务 # 本质 批发转零售 帮助别人成功而成功 产品型转服务型 优势 轻，方便 全 可计算 现象 外包被淘汰 行业 OS of business 功能 产品功能，样板 开发体验，文档 组件收费，容量收费，节省的成本收费 数据直接做决策 分类 service # 基础服务 plugins # 基础服务组合 app # plugins组合 产业互联网 # 供应链 # 为什么 大厂核心 各节点(库存)周转 是什么 资源 -&amp;gt; 渠道 -&amp;gt; 用户 反馈用户真实需求 上游关注制造业 下游关注erp 批量(精), 个性化(敏) 物流, 资金流(现金流), 信息流 库存管理 应对变化(保质期) 求零库存 供应商 评级 物流, 成本 难点 打通 怎么样 成本、利用率 可靠性, 反应力, 柔性(补错) 感知、预测 赋能 重点 按时制造 难点 协调(协议) 步骤 单品上下游延伸 人工智能 # 优化、预测 拟合函数, 高阶微积分, 梯度下降 元宇宙 # 传媒营销 # 媒体 # 场景控制 3CAD character camera control art direction 特效 会场散射光束（博物馆） 雾中焦点的竖光（saber的剑） 画线的光点（最终幻想） 密集的星星，远近缩放，光圈(tree.</description>
    </item>
    
    <item>
      <title>人员</title>
      <link>https://runout.run/docs/architect/manage/organize/people/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/manage/organize/people/</guid>
      <description> 人, 事, 团队 # 人 业内口碑 成分 技能，素质，精神 行动 感性，理性，惯性 发展 上限 下限 成本 低成本召回 事 知原理 是什么，为什么，怎么样，拆解 事与团队 事造就团队，好团队不一定出好成果 团队 存在合理性 有目标，成员能力认可，成员感性认可 小精英团队，才能解决问题 分配事 因特质分配，如稳定，峰值，沟通 成果评价 产出判断 分配利益和荣耀 时间和代码量评价不了程序员的工作, 可以匿名互评(口碑) 团队提升 培训无意义，自觉成长 成员 项目经理 设计 开发 测试人员 运维 系统工程师 设计、实现产品 数据分析师 技术总监 架构师 权衡, 出方案 职工 # 态度 把握分寸 靠谱(事事有交代) 负责(顾全局) 主动 超出预期 负责态度, 提高团队效率，而非自己效率 # 严肃判断 沟通 及早沟通、同步 文档 &amp;gt; 邮件 &amp;gt; im &amp;gt; 电话 # 即时性相反 留响应时间, 同组 -&amp;gt; 跨组 -&amp;gt; 跨部门 -&amp;gt; 跨公司 明确通知人时, 邮件, im特殊指定 文档 周报 文档简单有计划，为节省向别人解释的时间 建设性意见(提选择题) 只交“产品”: 背景清晰, 扼要, 完整, 引入独有经验 工程师 # 本质 解决问题 普遍问题 技能: 工具使用(写工具), 表面学习, 笨办法, 不会读文档, 只会知识迁移 设计: 不知经典设计, 不知设计哲学, 不知目的, 无法反应需求, 没有品位, 读不懂设计 知识更新: 学不动, 基础差(用二手资料), 无认知体系(认为都是新东西), 重复学习无用知识 沟通: 不专业(不用专业名词), 不主动, 不沟通对方, 不抓重点, 思路不连贯, 阅历不足(不会写文档), 不问为什么 能力 特点 知识、经验、技能、协作 # (1+天赋)x知识x工程习惯 犯错(多做多错) 方法 抽象 # 设计就是从升维中拆分和简化 沉淀 # 没有沉淀的学习不好回顾修改, 像没有测试的代码 品位 优点，缺点 # 找潜质, 并非此长彼短，是两个维度,有一定抑制作用 创造力，纪律 勤奋，聪明 稳定，峰值 深度，速度 细节，大局 开发 考虑工作的复用性 加入项目，需要可对所有代码修改 善用工具 自己的事主动跟进 owner 自我负责, 自我驱动, 持续改进 能部署, 能手工排查问题，手工修复数据, 开发调试工具, 数据修复工具 模块职责单一, 明白当前负责和极限性能 能降级, 知道下游调用和降级影响。了解上游依赖和上游降级影响 配好log、监控、告警, 告警及时响应 架构师 # 场景/用例/问题 -&amp;gt; 方案/方案权衡 -&amp;gt; 落地路径 分级 初级 代码 命名：精确性、简单性、一致性、区别性、业务性 逻辑: 缩进、换行 代码体积: 行、方法、类 抽象能力 边界 中级 流量、并发等 高级 理解业务核心价值、业务实现方式 业务技术支撑方式 业务趋势 创始人 # 心态: 平常心 职责: 找到善于解决问题的人，做好善于定义问题的人 艺术家 # 岗位 # 项目经理(pm, project manager) 技术经理(tm, technical manager) 产品设计经理(pdm, product design manager) 运营经理(pom) 测试经理(qam) 客服经理(csm, customer success manager) 开发组长(tl, team leader) 架构师(pa) 开发工程师(de, development engineer) 数据库管理员(dba, database administrator) 系统管理员(sa) 界面设计师(ui, user interface) 用户体验设计师(ue, user experience) 产品运营师(po, product operator) 产品设计师(pd, product designer) 测试工程师(qa, quality assurance) 配置管理员(pcm) 发布员(pb) 软件过程专员(sqa, software quality assurance) 运维工程师(sre, site reliability engineer) 招聘 # 双向选择 精确率&amp;amp;召回率 方面 沟通 喜欢技术，逻辑能力, 编码能力, 设计能力 基本概念, 边界考虑充足, 进阶答案, 衍生问题的解决 是否有自己思考，对自己负责 </description>
    </item>
    
    <item>
      <title>代码规划</title>
      <link>https://runout.run/docs/architect/method/code_plan/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/method/code_plan/</guid>
      <description>阻塞 # 阻塞(bio)指cpu等待io 非阻塞(nio)指调用io后立即返回，但要轮询事件状态 # 非阻塞指对cpu不阻塞，但业务线程阻塞 轮询(单线程) read 定时重复调用来检查 select 前后read, 中间select轮询检查文件描述符的事件状态 采用1024长度数组存储状态，只能同时检查1024个文件描述符 poll 前后read, 中间poll 用链表代替数组, 也避免了不必要的检查 epoll # linux 前后read, 中间epoll epoll检查不到事件，休眠epoll线程直到事件将它唤醒 kqueue # freeBSD中，类似epoll aio # async io, linux, 业务线程不阻塞 通过回调(信号)传递数据，不必像epoll线程(业务线程)阻塞等待 仅linux下有, 只O_DIRECT方式读取，不能利用系统缓存 IOCP # windows aio 模拟aio(io线程池) 业务线程的io操作, 起io线程, io线程完成通信到业务线程触发回调 库 glibc(有bug) libeio node.js的libuv封装 linux下自实现 windows下IOCP 事件 # 实现 回调 队列存事件, 单进程检测事件是否回调 库 libevent libev # bug比libevent少 工具 epoll(select, poll) libev(libevent) 并发并行 # 并发 多任务共享时间段, 类比: 任务队列 为什么并发 多任务能力 非阻塞 并行 多任务同时处理, 类比: 多核处理器 为什么并行 提高执行效率 分类 任务并行化 数据并行化 cpu交替任务 # EDSAC串行任务 协作式 # 可能独占，Windows3.</description>
    </item>
    
    <item>
      <title>演说</title>
      <link>https://runout.run/docs/basic/speach/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://runout.run/docs/basic/speach/</guid>
      <description> 要素 # 环境的设计 安全 规模小 改变被动传输为主动接受 交互、提问与思考 团队、竞争、奖励 控制场面 引导 </description>
    </item>
    
    <item>
      <title>身体</title>
      <link>https://runout.run/docs/basic/body/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://runout.run/docs/basic/body/</guid>
      <description> 造型期 # 体态 高低肩 骨盆前倾 体能 心肺 变速有氧：4、6、8各2min， 30min以上 力量 核心训练 健身计划 # 目标 指导 FITT Frequency: 一周3-5次 Intensity: 有氧 心率: 123-142 无氧 动作 间歇 个数 重量 Time: 60min力量 + 30min有氧 Type: 热身 抗阻力训练 拉伸 阶段 适应期(1-2月) 心肺功能: 功率 核心力量 保护腰：呼吸 + 静态 内脂 力量训练 动作规范 蹲、推、拉、举、旋转 进阶期(2-3月) 消耗 &amp;gt; 摄入 七大肌肉群：胸、肩、背、腹、腿、臀、手臂 三分化、四分化 爆发力 </description>
    </item>
    
    <item>
      <title>运维规划</title>
      <link>https://runout.run/docs/architect/method/ops_plan/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/method/ops_plan/</guid>
      <description> 指标 # 标准 ITIL(IT Infrastructure Library) ITSM(IT System Management) 目标 安全性 账号管理 漏洞修复 安全审计 可用性 服务监控 架构优化 冗余备份 预案演练 故障响应 运维成本 成本核算 服务选型 成本优化 运维效率 研发工作流支持 服务支持平台建设 运维自动化平台建设 工作方式 邮件申请开通 LDAP, VPN, 测试, 线上 监控 # </description>
    </item>
    
    <item>
      <title>工程</title>
      <link>https://runout.run/docs/architect/project/ddd/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/project/ddd/</guid>
      <description>介绍 # 介绍 Domain-driven Design 针对传统软件开发流程（分析-设计-编码）各阶段业务割裂问题，一开始定义好领域 目标 维护概念完整性(纯洁)，避免语义泄露和腐化 概念 # 领域（Domain） 界限上下文（Bounded Context） 领域模型（Domain Model） 领域通用语言 分层架构 展示层、应用层、领域层、基础设施层 最佳实践 关联尽量少、尽量单项、尽量降低整体复杂度 实体（Entity） 领域中的唯一标识，属性尽量少 值对象（Value Object） 没有唯一标识，属性值不变 领域服务（Domain Service） 协调多个领域对象，只有方法没有状态 应用层服务、领域层服务、基础层服务 聚合、聚合根（Aggregate, Aggregate Root） 聚合定义了一组有内聚关系的对象集合，聚合根是对聚合引用的唯一元素 修改聚合必须在事务级别 70%的聚合只有一个实体, 30%有2到3个实体。 只有一个实体时，实体就是聚合根。多实体时思考哪个对象有独立存在的意义，且可与外部直接交互 工厂（Factory） 工厂模式 仓储（Repository） 持久化到DB，管理对象 只对聚合设计仓储 建模 # 原则 # 简单、容易、清晰 使用不动点 领域专注 聚合内强一致，跨聚合最终一致 内部概念完整一致(unification) 术语不变、不矛盾、不重叠 数据模型（DO） # 失血 DO和DAO无业务逻辑，纯数据 贫血 持久化逻辑在DAO中 充血 service很薄，持久化的逻辑在DO中，无DAO或与DO双向依赖 肿胀 无service，全部逻辑放DO 分析设计 # 分析模型 # # 业务领域分析, 不考虑代码 问题 含意不完整，不可图形或文字表达，错误假设 会深入某细节 忽略某细节直到设计或实现, 如持久化、性能 目标 领域模型 架构设计 事件风暴 # 是开发建模，不是用户需求故事 准备 功能确认: 近期milestone 找正确的人: 领域专家, 前后端，架构师 引导者: 准备资料, 排程, 时间, 2/3时间预警 事件风暴 领域事件: 用户可感知状态 分支小组 -&amp;gt; 个人发散 -&amp;gt; 小组一致 -&amp;gt; 整体一致 # 不能一致表示准备不足 逻辑顺序 -&amp;gt; 最终流程 命令风暴 # 为什么, 分色 事件触发原因、方式 用户角色 读模型: 用户前置需求 写模型: 动词 描述 聚合 取名, 分职责 持续探索 领域模型一开始就结合编码设计 # 设计围绕模型, 模型受设计反馈改善 开发时意识到模型变更, 会保持完整性 每个开发在修改前需要了解模型 面向对象更易于建模, 过程化易于流程，如数学 重构 # 要求 设计灵活 使用经过验证的构造 目标 领域理解更深、更清晰 深刻(incisive)、深层(deep)的模型 技术的动机的代码转换 实现 小幅可控 基于测试 突破 新的概念或抽象 隐含的概念被凸显 倾听领域语言 过分复杂是因为关键点被替代 领域文献 # 深层视图 约束 # 表达不变量 过程(process) # 面向对象中的面向过程, 多个过程时用策略 规约 # 测试对象返回布尔值, 重构成对象而非写在application 战略建模 # # 形成上下文映射图 问题空间 领域 # 与公司组织关联 子域 # 最好对应一个限界上下文 核心域(core domain) # 项目动机, 公司核心竞争力, 尽量小, 最高优先级 通用子域(generic subdomain) # 作用于整个系统的支撑子域 支撑子域 # 重要非核心 集成 合作关系(partnership) # 同时成功失败 共享内核(shared kernel) # 小型内核, 持续集成功能 客户/供应(customer-supplier development) # 上下游 遵从(conformist) # 下游遵从上游 防腐层(anticorruption layer) # 翻译转换领域服务 开放主机服务(open host service) # 公开协议，子系统访问 发布语言(published language) # dsl, 通常与开放主机服务一起 分隔(separate way) # 声明无关联 大泥球(big ball of mud) # 已有纠缠的系统，隔离出来 解决方案空间 通用语言 一个限界上下文一个通用语言 清晰(概念无二义性), 简洁 # 如卖家和买家都叫用户，就是不清晰。如用type标记用户是卖家或买家，就是不简洁。所以直接用两个对象 限界上下文 # 条件的集合 目的 确保术语含义明确 切分规模, 易于保持领域纯洁 设定进化框架而非模块，包含模块 考虑因素 团队组织结构 应用特定部分惯例、物理表现 挑战 团队开发碎片化 # 写重复的代码，由于不知道或怕改错 持续集成 早合并 自动构建测试 # 检测不一致 模块 作用 降低模型规模复杂度 代码高内聚低耦合 设计 通信性内聚(communicational cohesion) 功能性内聚(functional cohesion) 每模块统一接口 名称反映深层理解 灵活性，进化性 上下文映射 # 领域间集成关系 模式 共享内核(shared kernel) # 为减少重复, 共享领域子集，多方测试 客户-供应商(customer-supplier) # 做反馈的需求, 需求测试, 自动化验收 顺从者 # 供应商不做需求, 客户用适配器对接组件 防腐层(anticorruption layer) # 双向领域模型转换器, 保持内部模型纯洁 从前 原始数据(api, db)无模型无语义的处理 实现 对外多门面(facade) 每个门面一个适配器(adapter) 适配器间用转换器(translator) 隔离通道(separate way) 开放主机服务(open host service) # 实现开放服务协议 提炼 # 多次重构后还很大 实现 分离基本概念和普通概念, 提炼核心域和子域 子域 使用第三方服务 外包 修改已有模型 六边形架构 领域模型简洁自治 对外适配器防腐, 保护限界上下文 # 如面向接口 消息, 内存, 数据库 soap, rest CQRS(command query responsibility segregationg) # 修改只记事件(日志), 查询时计算 查询方式 单数据库/读写分离，查询时计算事件 读写分离, 读库异步计算事件保存冗余, 读库负载均衡 战术建模 # # 组成限界上下文 领域 实体(entity) # 标识和延续性, 有id, 持续变化。 值对象(value object) # 无id, 只有属性, 最好不可变(可共享)。尽量建模值对象。可包含实体引用或值对象。 生命周期 聚合(aggregate) # 定义对象所有权和边界 简化 关联 # 可导航到的关联 1对1 # 对象引用 1对n # 包含集合 n对n # 删除关联，关系加约束或转换 目的 一致性 强化不变量 实现 聚合根(root) # 聚合根间是最终一致性 是个实体,有id 外部访问的唯一对象 向外传递副本 工厂(factory) # 在领域中没有定义, 但程序需要 目的 并非对象创建对象 对象创建存在自有知识 创建过程原子性 对已有持久化对象重建并修复 问题 外部访问根内对象，需关联不必要的根实体 实现 不用工厂 构造不复杂 不涉及其它对象 客户希望用策略创建 类是具体类型, 无层级 聚合根提供方法 单独工厂 # 违反了封装原则, 但保持了简单 资源库(repository) # 内存假象 目的 不关联根获取对象引用 不暴露细节, 会减少领域专注 防止代码扩散 减少变更修改 维护聚合封装性 容易的基础设施被滥用, 产生除聚合根外导航 实现 封装所有获取对象逻辑 基础设施, 全局可访问 不同对象不同策略访问、存储 # 领域与基础设施解耦 接口是领域模型, 实现像基础设施 参数筛选或规约(specification)筛选(筛选器) entity 介绍 entity即状态 应用开发即处理entity的表现 主从 主存储(可变) # 关键是选择主存储 多派生一致性好保障 派生表达业务的难易成度 只读派生(representation, 不可变) 多份存储, 一致性 派生, 合并, 转化 类型 东西(可变) # 单据叠加成东西, 东西叠加成东西 单据(可变) # 事件叠加成单据 事件(event, 不可变) 命令(command, 不可变) 视图(view model, 不可变) 子集(subset, 不可变) 视图(aggregation, 不可变) 表单(可变) # 是主存储 物理介质 OLTP(mysql) # 点查询 OLAP(clickHouse) # 范围查询 queue(kafka) # 顺序读, 低延迟 业务服务 # 业务逻辑, 像虚拟的表 分组entity主存储(BC, bounded context) 目的 分解 管理复杂度 系统 组织部门 实现内部一致性 概念, 数据 对主存储进行受控的修改 边界entity # 用于集成，不一定是主存储 形式 授权、binlog、工作流、视图数据、租户作为其它租户user 东西、单据、event 介质 queue, 带权限db, rpc虚拟表 触发 queue, ui, api 触发由worker托管, 输入是queue或rpc socket 粒度 分entity 分步骤 分entity字段 原则 BC尽可能少而大 关系 时间错开 外键关系 # BC挂载到BC, 如后台系统与计费系统的定价, 运营人员与服务系统的配置, 流程节点系统对流程的依赖 rpc, 数据库, 数据复制 报表关系 时效性高 一般做复制 # 所以边界entity是数据变更event 触发关系 # fire and forget 交棒关系 下游给上游command/event, 上游触发 上游实现降级 # 下游不可用时，安慰语 时间同时 accountable/responsible关系 # 负责人与实现人 原则 accountable尽量小 只调度 与responsible的边界entity是rpc虚拟表, 请求command, 返回event 补偿实现一致 # 如超卖 responsible提供自己界面 # accountable不控制 抢资源关系 锁服务 服务(service) # 无法划分对象的动作, 无状态。按功能分组, 多对象的连接点 可在application, domain, infrastructure 最终一致性建模 # In-Memory # 聚合根在内存，同步最新状态 事件溯源（Event Sourcing） # 没有CRUD，只有Append Event。数据不可变 对象最新状态通过事件溯源获得 Actor # 通过Mailbox取代调用，保证消息线性处理 EDA(Event-driven Architecture) # 节点只处理逻辑，节点间Event通信 是最终一致性的架构 CQRS # 介绍 Command Query Responsibility Seperation CQ接口分离、代码分离，分别设计 概念 项目结构 # 用户接口(user interface) 应用(application) # 尽可能小。数据验证，事务。故事, 表达出操作的事情 application service unit work presentation model 领域(domain) # 专注领域。准确定义业务对象 aggregate, entity, value object domain service, domain event 基础设施(infrastructure) # 辅助层 repository global support 项目文件 [ui] mall # 商城api [saleDomain] [application] mall.</description>
    </item>
    
    <item>
      <title>咨询规划</title>
      <link>https://runout.run/docs/architect/method/advice_plan/</link>
      <pubDate>Wed, 10 Oct 2018 16:49:27 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/method/advice_plan/</guid>
      <description> Presentation # 指导思想: 成于结构，臻于对话 PPT画页 画的是冰山一角 类似手持卡片 类似左右脑: 逻辑+展示 具体内容 思维导图 维度筛选，MECE不重不漏 空姐现象 共知的事情特色讲，去掉已知部分 卖钻讲孔 电梯法则 告知全局，步骤清晰，回顾小结 递进逻辑：信息，分析，方法 目录 首页效应 目录，章节页，总结页 视觉 图形代替文字: 缩小了看一看 标题附主题语: 有兴趣有信息量 讲 替画重点（提示语如: 请注意，提问） 细讲：页只写观点，串联起来讲，只有30%内容重合 心态 注意力放在观众那边 沟通合作而非防御 房间有更聪明的人 数字化转型 # 什么是数字化，有什么用 发展 信息化: 烟囱式，信息/数据孤岛，管理/运营孤岛 互联网化 互联互通: 0边际成本互联互通，云计算-&amp;gt;雾计算 大数据化 数据互联: 互联一切-&amp;gt;一切互联，跨界应用 数据资源: 核心要素/资产，第一权利 数智化 人工智能：大数据-&amp;gt;大知识, 人类设计-&amp;gt;自动学习，替代与超越 计算智能-&amp;gt;感知智能-&amp;gt;认知智能 三位一体：(互联网+大数据+人工智能)+ Any 数字孪生、元宇宙 互联网+ 信息传递边际成本趋向于0 连接机制革命 任意两个资源(人或物)0边际成本互联互通: 信息0边际成本 传播机制: 线性、金字塔式-&amp;gt;非线性、网状、几何级、病毒式 带来什么 数字科技三位一体：(互联网+大数据+人工智能)+ 边际革命：0边际成本效应，边际成本递减，边际收益递增 数智：可知、可达、可控、可预测，程度剧变、实现边际成本剧变 量变-&amp;gt;质变（工具革命-&amp;gt;革命的工具） 局部改善-&amp;gt;全面优化-&amp;gt;全面重构 技术应用-&amp;gt;业务优化-&amp;gt;全面变革 农业时代，工业时代，数字时代，造物时代 为什么数字化转型 企业处境 各行各业先后 总量短缺-&amp;gt;结构过剩，卖方市场-&amp;gt;买方市场，存量经济的争夺内卷加剧 成熟稳定期-&amp;gt;跃迁剧变期 各行各业被迫转型：不断重新分工、重新分利 产业链 重构/(替代+重构) 战略问题 不是未来做什么，是做什么有未来 提高打鱼技术但鱼没有了 不要战术勤奋战略懒惰, 战术成功战略失败 不是选择题是必答题 什么是企业/产业数字化 IBA+经济 电子商贸，流通 不是虚拟经济，是实体经济的全新形态 IBA+交易 渠道体系革命 线上渠道为主，主导线上线下一体化 终端(触点)为王 与用户空间时间距离不断缩短 一切皆终端，终端多样化-&amp;gt;场景碎片化(场景嵌入)-&amp;gt;新旧场景兴衰 泛在智能交互，泛在智能感应(不断向生产环节渗透) 交易边际成本大幅下降, 交易可能性边界急剧膨胀，资源配置能力与利用效率极大提高 产业链重构：M2B2C, M2C, P2P 野蛮营销-&amp;gt;精准营销-&amp;gt;智能匹配 产品变渠道，产品渠道一体化 智能产品-&amp;gt;触点+服务与生态体系 产品成为持续服务的载体 制造业服务业化 智能化，机器体系对人的脑力及体力的强助力、替代、超越 精细化、高度集成化 去人化、极致自动化 柔性化，按需生产、柔性制造能力 IBA+生产 业务跨界与跃迁：供应链资源，数据资源，新“物种”(产品) 低碳、低能耗、低消耗: 自然资源稀缺性下降 IBA+交易+生产 交易生产一体化 由需到供，按需生产，按需服务，按需研发，按需投资，0库存 非标-&amp;gt;标准化-&amp;gt;去标准化(个性化生产) 卖产品-&amp;gt;卖生产服务，制造业服务业化 延展到整个国民经济生态体系，有计划的市场经济 数据驱动，智能决策 平台化+极致专业化分工 企业(管理与产权)形态、雇佣形态的演变 管控型-&amp;gt;交易型/平台型 企业人员规模缩小，企业边界模糊 企业、资本与劳动者关系演变 数字化转型 数字经济质跃工业经济 数字经济系统 经济环境: 人类经济活动(分工协作)的基础条件(信息不对称性，资源稀缺性)发生剧变 经济活动: 交易和生产的边际成本大幅下降，经济活动的效率大幅上升，经济活动的可能性边界急剧膨胀 从根本上超越工业经济 数字化经济含义 交易、生产：0边际成本 边际革命：人类逐步进入0边际成本时代 边际成本递减-&amp;gt;0边际成本-&amp;gt;边际成本为负 结果变成原因，逼近转型升级 数字化转型升级 以数字科技为应用手段，持续推进业务变革、组织变革 经济的数字化转型升级: 以数字科技应用为手段，推进经济模式、经济形态持续转型升级 企业数字化转型升级：以数字科技应用为手段，推进企业营销模式、服务模式、管理模式、生产模式、决策模式、商业模式、产权模式等持续转型升级 鸿沟：科技&amp;lt;-&amp;gt;业务 可能性(无限)-&amp;gt;现实性(有限) 科技-&amp;gt;技术应用(产品/模式/制度创新变革)-&amp;gt;业务问题-&amp;gt;科技应用创新不足是制约转型升级、创新发展的关键瓶颈 问题导向，需求拉动 科技应用价值问题：经济效益是检验科技领先的唯一标准 科技应用方向问题：0到0的创新比0到1的创新更关键 科技应用的路径问题：并非都是&amp;quot;富家子&amp;quot;&amp;quot;优等生&amp;quot; 转型是什么 三个层次 新赛道(局部): 新技术、新产品、新兴产业链 新形态(普遍): 新业态、新模式、新型产业链 新经济(全面): 新生态、新格局 企业：全面转型或K型经济 可行方法 你是谁：业务现状 你想变成谁 动因与目标(短期、长期) 问题导向与需求分析 你能变成谁 基础条件与既有资源 信息化数字化的基础 你如何变成谁 (周而复始)设计-&amp;gt;建设-&amp;gt;运营(业务+系统)-&amp;gt;跟踪与评估 得客户资源者得天下 流量-&amp;gt;留量 客户资源：客户数据+客户关系+客户渠道 以更低边际成本掌控更大的客户资源 谁掌握完备的客户资源 如何掌握完备的客户资源 未来已临 划时代的技术都是试金石 与时代赛跑 实施 本质 数字驱动的用户中心观, 不是业务中心观 增长三角：规模、分工、效率 思维: 大数据、区块链 用户价值: 一个框架: 价值创造，用户挖掘，用户数据，个性化服务，差异化用户保留 一个目标: 每个用户&amp;quot;精耕细作&amp;quot; 一个重点: 数字化全链路管理，全场景营销, 全渠道服务 价值网络: 一个核心 商业模式 Costco&amp;quot;复利高墙&amp;quot; 差异化价值、服务对象、盈利模式+核心能力 数字化会员：精准预测，精准选品，自有品牌 供应链 问题：牛鞭效应，不确定效应 解决：基于数据观察趋势，不预测趋势 增长飞轮 数字化加速技术分层分化, 技术模块化 运营卓越: 上游核心技术，下游用户亲密 数智化转型 # 技术：人工智能，区块链，云计算，大数据，边缘计算 管理：科学管理-&amp;gt;人本管理-&amp;gt;精益管理-&amp;gt;价值共生 重塑思维 战略转型方向 管理变革 商业模式 重塑领导力 数字化营销 # 4P: 产品、价格、渠道、推广 4C： 消费者(Consumer)、成本(Cost)、便利(Convenience)、沟通(Communication) 4R: 关联(Relevance), 反应(Reacton), 关系(Relationship), 报酬(Reward) Marketing Jungle: 及时性、社会性、精准性、方便性 CIDR Contact: 全渠道(全场景): 在商，在家，在途 Identify: 二维码，小程序，人脸，Beacon Data: 数据标签(分级分群) Reaction 大数据营销 3V: 数量(Volume)、速率(Velocity)、多样(Variety) 维度 身份象征: 年龄、身高、性别、居住地 生活风格: 朝九晚五、泡吧达人、工作狂 消费行为: 购买时间、购买方式、促销敏感 社交行为：意见领袖、意见跟随者 商品偏好：咖啡达人、面包达人 RFM: 最近消费、消费频率、消费金额 升级：金字塔(二八原则) 挽留 精准营销：相关分析、逻辑回归分析、购物栏分析、标签群体聚类分析 私域 进(获客) 线下：自然来客、地推 会员裂变 大数据：探针法、数据交换法、WiFi法 产品为王 线上引流：SEO, SEM/关键字投放, ASO, CPS(按销售付费), DSP(跨平台), Banner, 嵌入代码/挂件，微信/社交/短视频 活(激活) 不删: 电子会员、交互平台、创造场景 关卡：产生兴趣、激发欲望、消除顾虑(七天免费)、立刻行动 粘(粘性) RFM分群 R: 最近一次消费 F: 消费频次 M: 消费金额 增加粘性: 次数带动，品类带动，场景带动 值(客户价值) CLV=贡献价值 - (取得成本+维系成本) 荐(裂变) 原因: 创造价值 获客 方法 分享, 红包，IP,亲子，团购, 朋友 移动营销 优势：实时在线、高效传递、多媒体负载、瞬间反应 特色4I: 个性化(I)、互动(Interactive)、分众识别(Individual Identification)、实时信息(Instant Message) 设备：二维码、App、小程序、穿戴技术 MAC Address: 基地台，路径 Beason: 室内 DSP: 标签种植 限制：隐私侵犯、推送用APP未打开、设备更换 七个瞬间 场景: 时间地点，和谁一起，当前感觉，需要什么; 和上次一样 位置距离: 地理定位，地理围栏，地理征地 时间 实用性产品(效率): 早上 享乐型产品(心情): 下午 天气 影响心情 预防性框架 轨迹 社会: 和谁一起 拥挤度 社交媒体 pay media, earned media, owned media 社群 粉丝: 目的 企业：目的 方式 找兴趣, 嬴关注 造品牌, 聚粉丝 场景思维 围绕产品 围绕时间 围绕特定事件 内容营销 步骤 任务规划：对象、目的、场景 阶段性目标：粉丝数、活跃度、互动数、观看数、展示数、流量数据 内容创意：起承转合, story board 标题、价值(有趣、有利)、为什么转发(显示一手信息、表达立场、自娱娱人) 确定渠道: 对象，内容类型，流量机制 评估学习 内容策略 热点性内容 即时性内容 生活故事内容 方案或学习性(生活小贴士) 连载性内容 促销性内容 全流程整合 交易平台: 微商、微店(企业内店、第三方平台)、微商城 分润机制: 入会条件、会员等级、推荐提成、等级折扣 企业管理 # 战略 目标：使命，愿景 分层 企业层面战略 业务单元层面战略（竞争战略） 职能层面战略 管理 战略分析阶段 战略选择阶段 战略评价阶段 战略实施阶段 战略控制阶段 优化咨询 # 问题 客户反馈 单体应用 模块耦合程度 微服务划分与边界 单节点数据库 查询崩溃 IoT控制 命令超时失败, 响应慢 出错业务处理 发现问题 现有代码逻辑梳理 通过链路追踪，找性能瓶颈 SQL平台建设，发现数据库性能问题，优化SQL 服务器节点监控，应用监控，数据库监控 解决问题 代码 纯代码优化：N+1调用，事务问题 逻辑优化：订单失败，复杂业务流程优化 发布流程优化CI/CD 中间件优化：优雅停机，灰度方案节点打标，全链路日志 性能优化：业务并行处理，业务异步处理 数据库 不合理调用治理：批量更新，大事务， 慢SQL治理 数据库备份：主从优化，定时备份 配置调优 架构 高可用：服务发现，分布式 业务缓存优化，减少数据库调用：热点数据，对象缓存，多级缓存 分布式任务平台：分片执行 任务中心：批量平台 稳定性 告警平台 异常告警(空指针，接口调用成功率) 监控告警(服务器使用率) 业务告警(下单失败) 限流熔断 网关限流，业务限流，接口限流，外部调用限流 业务平滑处理 运营工具 业务数据多维分析 </description>
    </item>
    
    <item>
      <title>服务治理</title>
      <link>https://runout.run/docs/architect/method/architect/</link>
      <pubDate>Wed, 10 Oct 2018 16:49:27 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/method/architect/</guid>
      <description>原则 # 高并发 高可用 高可靠 SLA(service level agreement)制定(吞吐量、响应时间、可用性、降级方案) 容量规划(流量、容量) 监控报警(机器负载、响应时间、可用率) tracing 应急预案(容灾、降级、限流、隔离、切流量、可回滚) 成本 经济学原理 比较优势 服务器类型 分工协作 组合 货币解耦 MQ 规模效益 集群 高可用 # 负载均衡 # 流量切换 # 某服务器挂了 DNS切换 httpDNS # app配置，绕过运营商localDNS lvs/haproxy # 切换故障的nginx nginx # 切换故障应用 限流 # 思路 恶意请求流量只访问cache 穿透到应用的流量用nginx limit 恶意ip nginx deny 降级 # 开关集中化管理, 推送开关配置 开关前置 # nginx层做开关 可降级读服务 # 只读本地缓存、只读分布式缓存、只读默认数据 业务降级 # 部分业务异步，处理高优先级，分配流量保障系统可用 隔离 # 线程隔离 进程隔离 集群隔离 机房隔离 读写隔离 动静隔离 爬虫隔离 热点隔离 资源隔离 回滚 # 事务 代码库 部署版本 数据版本 静态资源版本 超时与重试 # 压测与预案 # 线下、线上 高并发 # 缓存 # 客户端 浏览器缓存 # Pragma, Expires, Cache-control ajax app缓存 # 大促时更新静态资源, 地图 客户端网络 # 代理服务器缓存 广域网 代理服务器(如CDN) 推送 或 拉取(回源) 镜像服务器 P2P 源站 接入层缓存 # 如页面缓存，用redis url重写 一致性哈希 proxy_cache # 内存/SSD缓存内容 proxy_cache_lock # 一段时间的回源合并成一个 shared_dict # lua, 重启缓存不丢失 应用层缓存 # 如搜索，建议物品等 堆内缓存 堆外缓存 # local redis cache 分布式缓存(接入层后) redis集群 # 异步化写入, lua-resty-lock(非阻塞锁) 对象缓存 # db和应用间的查询结果集 静态化, 伪静态化 服务器操作系统缓存 连接池线程池 # 异步化 # 队列 # 作用 服务解耦 异步处理 流量削峰/缓冲 # 如促销期 问题 丢失/失败 # 持久化，日志，报警, 数据校对修正(worker扫库) 重复 # 业务上防重 例子 redis扣库存-&amp;gt;记录日志-&amp;gt;同步worker-&amp;gt;DB 消息总线可扩展 # x扩展不行，y扩展用专用总线(降低了灵活性), z扩展根据客户 减少拥挤 # 消息划分价值 扩容 # 无状态 # 应用无状态，配置有状态 尽可能浏览器端维护会话 分布式缓存放状态 拆分 # 加法组合，乘法功能 # 项目死于1到10，或10到100，因为解耦不够，无法重构 业务拆分 功能细分 读写 # 读缓存，写分库分表，聚合数据 AOP # 如CDN 模块 # 代码特征，如基础模块分库分表，数据库连接池 数据异构 例子 聚合数据表(一般KV存储) # 数据闭环(不依赖其它服务) 历史归档 并发化 选择工具 数据库 # rdb, nosql, hadoop 防火墙 # 墙需要的东西 日志 # 采集分析 用同品牌设备 慎用第三方 容错 隔离 # 不同步调用，限制异步调用(数量和超时)，能迅速发现故障 不单点 # 一切都出故障 不系统串联 功能支持启用禁用 # 实现wire on/wire off框架 服务方法 # 成本分析 # # autonomy.</description>
    </item>
    
    <item>
      <title>知识图谱</title>
      <link>https://runout.run/docs/architect/strategy/ai/map/</link>
      <pubDate>Wed, 10 Oct 2018 16:49:27 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/strategy/ai/map/</guid>
      <description> 与深度学习区别 # 深度学习是显性模型，知识图谱是隐性模型 场景：人脸识别；语音助手 目前进展: 在一些任务上已超过人类；知识量超过人类，推理不如人类 任务范围：面向具体任务，难以迁移；广泛适用于不同任务 可解释性：较难解释；可解释性强 数据量：海量训练数据；海量知识数据 未来趋势：深度融合 历史 # 2010年: 微软构建Satori、Probase 2012年: 谷歌X实验室识别&amp;quot;猫&amp;quot;, 发布Google Knowledge Graph 2013年：百度布局 2015年：阿里布局 2016年：亚马逊布局 特点 # 视觉思维 关联 推理 结构识别 降维 概念图 网络模型 潜在领域寻迹 领域 # 宇宙图谱 绘图学 陆地地图 天体图 生物图谱 轨迹 旅行商 虚拟世界搜索 信息觅食，过程建模 应用 # 内容理解 篇章理解 推荐场景 路径推荐 知识融入推荐 广告 召回排序 智能营销 画像 用户画像 产品画像 场景画像 库 概念库 语义本体库 规则库 建模分析 分词、词性标注、命名实体识别 句法分析、语义表示、概念发现 用户打标、场景打标、产品打标 语义匹配、指代消解、主题模型 搜索理解 语义搜索 演化分析 场景化搜索 路径召回 对话理解 商家 智能化商家运营 商业大脑 商业分析 可解释性 图谱路径推荐理由 知识融入生成推荐理由 实体卡片 资源聚合 内容分发 产业链图谱 用户画像 高管画像 价格图谱 债券风险预警 中小企业风控图谱 营销获客图谱 产品与工艺创新研发 安全质量 供应链 社会关系图谱 交易关系图谱 网络图谱 时空关系图谱 任务自动化 维度：可发现、可移接、可推理 自动化：自动数据结构化、流程自动化、业务服务化、服务开放化 推理 本体推理 概念补全 商品品类上下位发现 同质类目/属性项/属性值识别，新类目发现 实体识别与分类 关系抽取 实体对齐 实体链接 商品分类、增量商品分类、商品标题 常识推理 关系推理与链接预测 规则学习 百科知识发现 商品对齐 可比价同款规则挖掘 知识问答 知识增强学习 知识融入语言预训练 人货匹配 网络安全 专家系统-&amp;gt;感知智能-&amp;gt;认识智能-&amp;gt;决策智能 流程 # 数据爬取 数据爬取平台 知识获取 实体识别 概念、关系、属性抽取 标签挖掘 情感分析 知识融合：概念层融合，数据层融合 知识建模: 概念上下位关系生成、概念属性识别、规则建模、事件建模、时空建模 多元异构数据 非结构化文档 半结构化数据 结构化知识 抽取模块 基于规则 基于模板 基于模型 经典模型: PCNN、BiLSTM 预训练模型: BERT、摩天 预/后处理 先验知识库: 规则库、领域词表、模板库、黑白名单 数据集构建：人工标注、远程标注、数据集管理 知识融合 Schema对齐(异构转同构) 数据清洗 实体对齐(去重，消岐) 属性择优 知识关联 规则推理 建边模型 存储检索 图引擎 图存储引擎 图学习引擎 图查询引擎 优化 KV库 索引库 控制和数据分离 Schema压缩 知识计算 知识补全 知识推理 知识统计与图挖掘 知识图谱金字塔 文本(text)-&amp;gt;标签(label、tag)-&amp;gt;表格(table)-&amp;gt;图(graph)-&amp;gt;模式(schema)-&amp;gt;本体(ontology)-&amp;gt;规则(rule) 技术 计算：Spark 中间存储：HIVE 检索：ES 监控体系 知识管理系统 框架 # Spark HIVE ES 工具 # CiteSpace Jigsaw Carrot iOpener </description>
    </item>
    
    <item>
      <title>支撑-原理</title>
      <link>https://runout.run/docs/basic/computer/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:25:12 +0800</pubDate>
      
      <guid>https://runout.run/docs/basic/computer/principle/</guid>
      <description>主机 # cpu # 介绍 单cpu串行工作，前任务完成，后任务才开始 # 串行不适合图形处理(多点，线，面要同时乘投影矩阵) cpu把大量空间和电量分配给控制器和缓存，不能集成太多计算单元 cpu内存通过cpu总线连接, cpu总线与pci总线通过主桥(北桥)连接 gpu在pci总线上 控制逻辑在cpu中运行, 生成渲染数据, 到内存, 再到显存显卡计算。 内存到显存数据传输最花费时间。 原理 处理单元(processing unit) 算术逻辑单元(arithmetic logic unit) 处理寄存器(processor register) 控制单元(control unit) 指令寄存器(instruction register) 程序计数器(program counter) 指令集架构(ISA, instruction set architecture) # 机器码易兼容, 软件易编程, 易升级cpu 精简指令集RISC(reduced instruction set computing) 复杂指令集CISC(complex instruction set computer) 时钟频率(clock speed) 生产 生产线散热决定生存率，决定cpu型号 多级缓存 L1, L2, L3, L4 虚拟化 虚拟机监视器(VMM, virtual machine monitors) 分类 指令流的重数分类 SI(single instruction stream)单指令流 MI(multiple instruction stream)多指令流 操作数流的重数分类 SD(single data stream)单数据流 MD(multiple data stream)多数据流 SISD 串行计算机 SIMD 阵列机(多处理单元) MISD 很少 MIMD 多处理机 多计算机 硬件并行 位级(bit-level): 32位, 64位计算机 指令级(instruction-level) # 处理器内部并行度很高 流水线 指令分步骤(指令流), 每步专门部件处理 多指令流并行, 部件不空闲等待单指令流结束 六级流水线步骤 取指(FI), 译码(DI), 计算操作数地址(CO), 取操作数(FO), 执行指令(EI), 写操作数(WO) 多发射(超标量) 一时钟周期处理多指令 超线程 模拟多个逻辑线程 乱序执行 猜测执行 数据级 向量体系结构、图形处理器 单指令多数据(SIMD)架构 线程级 # 紧耦合硬件模型中开发数据级或任务级并行，线程间有交互 请求级 # OS或程序耦合任务间并行 程序并行 数据级(DLP, data-level parallel) 任务级(TLP, task-level parallel) # 多处理器, 超线程, 虽只有4个核，但可用核返回8 内存 共享内存模型 分布式内存模型 进程: 独有内存 线程: 共享进程内存(地址空间、文件描述符) 一个进程下的轻量进程 POSIX线程api是对已有unix进程模型扩展, 与进程多方面类似 自己的信号掩码 cpu affinity(倾向在某cpu尽量长时间运行) cgroups 进程调度 # 等级 高级调度(High-Level Scheduling) 作业调度, 后备作业调入内存运行 低级调度(Low-Level Scheduling) 进程调度, 就绪队列中某进程获得cpu 中级调度(Intermediate-Level Scheduling) 虚拟存储器引入, 内外存对换区进行进程对换 方式 非剥夺方式 处理机分配给某进程后一直运行下去,直到阻塞时,才分配处理机到另一个进程 剥夺方式 进程运行时,系统基于某种原则,剥夺分配给它的处理机.</description>
    </item>
    
    <item>
      <title>媒体</title>
      <link>https://runout.run/docs/architect/strategy/meta/media/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/strategy/meta/media/</guid>
      <description>原理 # 硬件 # CRT cathode ray tube 阴极射线管显示器 随机扫描方式 光栅扫描方式 DPU distributed processing unit 分散处理单元 标准 # Core Graphics System CGI(computer graphics interface) # 与设备无关的方法，方便的直接控制图形设备 CGM(computer graphics metafile) # 设备无关的主义定义图形文件格式 GKS(graphics kernal system) # 应用程序与图形输入输出设备之间的功能接口 PHIGS(programmer&#39;s hierarchical interactive graphics system) # 为3d设计的工具库 GL(graphics library) # 广泛应用的标准图形程序库 算法 # 基元的显示 直线扫描转换 DDA 中点画线法 Bresenham画线 圆的扫描转换 中点画圆 Bresenham 区域填充 种子填充 多边形扫描转换 图形变换 二维图形变换 二维视见变换 三维图形变换 投影 平行正交 平行斜交 透视投影 裁剪 直线段裁剪算法 Cohen-Sutherland算法 中点分割算法 梁友栋-Barsky算法 多边形裁剪Sutherland-Hodgman算法 三维图形裁剪 梁友栋-Barsky算法 曲线和曲面 概念 插值 逼近 参数连续性 几何连续性 光顺(smoothness) Hermite插值曲线多项式 Coons曲面 Bezier曲线和曲面 B样条曲线和曲面 图形运算 交点计算 多边形表面交线计算 平面中的凸壳算法 Graham扫描 Jarvis行进 包含与重叠 凸多边形 多边形的三角剖分 形体的表示 概念 图形信息 几何信息 拓扑信息 非图形信息 颜色 亮度 质量 体积 二维 边界 拆线逼近曲线 选点 共线性 三点转角阈值 带树法 图形的四叉树表示法 三维 几何元素 点 边 环(有序有向边) 面 体 体素 一组单元实体: 长方体、圆柱体、圆锥体、球体 扫描体 代数半空间定义的形体 线框图 顶点表、边表、面表 边界表示法 实体 CSG(constructive solid geometry), 指任意复杂形体都可用的体素组合 特征表示 Brep表示 八叉树(四叉树的推广) 分形 规则分形 # 严格自相似性的分形 Von Koch算法 Julia集和Mandelbrot集 消除隐藏线和隐藏面 线面比较法消除隐藏线 浮动水平线消除曲面隐藏线 深度排序算法(优先级算法) 画家算法(深度优先级表法) z一缓冲算法(深度缓冲算法) 扫描线算法消除隐藏面 区域分割算法消除隐藏面 BSP(binary space partitioning)树算法判别物体可见性 八叉树算法消除隐藏面 光线投射算法找到可见面 # 对包含曲面(特别球面的场景效率高) 真实感 漫反射及光源照明 照明效应 漫射照明 具体光源照明的照射效应、透射效应 漫反射、镜面反射 环境光 漫反射 镜面反射与Phong模型 光的衰减 多边形网的明暗处理 常数明暗法 亮度插值明暗法(Gouraund着色) 法向量插值明暗法(Phong着色) 阴影 纹理(texture) 整体光 透射光亮度模拟 Whitted光照模型(以Phong为基础) 光线跟踪 # 适用光滑表面 包围盒 空间分割成网格单元 辐射度方法 # 描述封闭环境中的能量交换 # 可模拟彩色渗透现象 色彩模型 颜色 色彩(Hue) 色饱和度(Saturation) 明度(Brightness) CIE(国际照明委员会)色度图(红绿蓝) 混合系统 面向硬件 RGB 红绿蓝加色系统 CMY 青、品红、黄着色系统 彩色印刷、胶卷等非发光显示体中采用 面向用户 HSV(Hue, saturation, value) # 六棱锥模型 # 可与RGB空间互相转化 HLS(Hue, lightness, saturation)双六棱锥模型 2d # 分形 # 介绍 Fractal 具有自相似性质的多个形状 大的部分由小的部分组成，小的部分像大的部分 用递归算法模拟 Mandelbrot Set 介绍 分形领域最著名的科学家 本华.</description>
    </item>
    
    <item>
      <title>程序语言原理</title>
      <link>https://runout.run/docs/pl/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/principle/</guid>
      <description>基础 # 注意 比较语言，共通处(抽象的元知识)是要点 在历史上判断设计者意图 # 利于了解知道的根基 不同规则，只在特点语言中合理 # 如0在ruby为真 历史 EDSAC # 1949，纸带 FORTRAN # 1954, 中缀表达式, 运算符优先级、结合性 FORTH # 1958, 没有语法，后缀表达式，语法树 LISP # 1958, 括号，前缀表达式，语法树 语法 引入优先级和左右结合 规则不冲突是困难的 vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; # c++的语法缺陷, &amp;gt;&amp;gt;是位运算，必须加空格 结构化 # 60年代 if # 汇编是判断再向后跳代码, if使可读性好 while # 可读了反复执行的if for # 可读了数值渐增的while foreach # 可读了集合遍历 函数 作用 便于理解 # 组织划分部门 便于再利用 # 再利用无代码成本 用了跳转命令和返回命令 # 从记录函数前后地址到函数记录返回地址 栈记录多级调用 # 解决多级调用返回地址被覆盖问题 递归 # 处理嵌套数据结构时，代码的嵌套结构 错误处理 历史 UNIVACI # 1950, 溢出时中断(interrupt)跳转到000 COBOL # 1959, 两种类型错误，用两关键字处理 PL/I # 1964 先定义出错处理代码。编程时引入on语句goto到处理代码, 不检查返回值 可定义新错误类型, 可用signal condition主动出错 john goodenough # 1975，论文 程序员可能忘处理异常、在不正确位置处理、处理不正确类型异常 应该声明可能抛出的异常、将可能出错结构括起来的语句结构 CLU # 1975, begin .</description>
    </item>
    
    <item>
      <title>企业级系统</title>
      <link>https://runout.run/docs/tool/product/enterprise_system/</link>
      <pubDate>Wed, 10 Oct 2018 14:51:24 +0800</pubDate>
      
      <guid>https://runout.run/docs/tool/product/enterprise_system/</guid>
      <description>ERP # # Enterprise Resources Planning, 企业资源计划 CMS # # Content Management System grav # 开源cms wordpress # # php dedecms # # 织梦cms, SEO优化 帝国cms # # SEO优化 phpcms # phpwind # # 开源, 社区管理系统 drupal # # 开源, cms 工作流 # activiti # 5,6已暂停维护，7叫作Activiti Cloud BPM flowable # activiti继任 YAML # 工作流 bossa # 工作流引擎 azkaban # 开源oa JBPM # # 常识 适用对象：业务逻辑不复杂，业务流程会变化 # s2sh适合业务逻辑复杂，但是业务流程不会变化的项目 jbpm封装hibernate 包含对象 模型 实例（由活动组成，包括活动、箭头等） 任务（需要人办理的活动） # 使用 myeclipse添加jbpm xml画图插件 MyEclipse -&amp;gt; MyEclipse Configuration Center -&amp;gt; Software -&amp;gt; Browse Software(add site) -&amp;gt; add from archive file找到jbpm-gpd-site.</description>
    </item>
    
    <item>
      <title>前端</title>
      <link>https://runout.run/docs/architect/project/frontend/</link>
      <pubDate>Wed, 10 Oct 2018 14:51:24 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/project/frontend/</guid>
      <description> 组件化Layout # layout service # 缓存layout到redis crud layout功能 layout对象 index # 缩略信息 plugins components table layout # 组合方式 水平，垂直，tab </description>
    </item>
    
    <item>
      <title>项目规划</title>
      <link>https://runout.run/docs/architect/method/project_plan/</link>
      <pubDate>Wed, 10 Oct 2018 14:51:24 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/method/project_plan/</guid>
      <description>平台服务 # aPaaS # # platform as a service，介于IaaS和SaaS中间 将软件研发的平台做为服务，以SaaS的模式交付 组件化支撑和驱动 # 组件的发展决定paas广度，组件的聚合决定paas深度 # 对内固守组件边界，对外暴露标准接口 分层 平台组件 基础业务 # 不可见，影响全局，通用业务逻辑，对性能很敏感 业务 组件 设计 # 自描述的，这样就在设计和开发上解耦 确定边界 定义标准接口 确定核心功能 规范异常处理 开发 # 像开发dsl一样,来评判核心逻辑和接口，抽象度高 技术评审 定义接口 # 面向接口开发，也称为BDD dubbo、grpc等 restful 接口设计 标准化 说明 服务路由 版本管理 授权管理 核心理念 # 体现在 服务、工具、模型、规范 开放 而非 封闭 合作 而非 限制 共享 而非 替代 重点关注 基础业务 组织架构和用户组 审批流 权限 通用模型 透明分布式缓存模型 分布式存储模型 分布式事务模型 效率工具 数据迁移工具 缓存配置工具 SaaS # aws线上云 微服务 + gRPC + k8s + Istio Golang + TypeScript + Python TiDB 行为分析 # 埋点 # 架构 数据采集 客户端采集 服务器采集 业务系统 第三方渠道 数据治理 ETL 实时ID mapping 元数据管理 数据质量管理: 数据校验, 实时导入监控，异常报警，debug数据查询，用户关联校验，数据质量看板 数据仓库 数据模型：Event, User, Item内容 实时导入系统 存储引擎、查询引擎 数据智能 特征工程 特征选择 模型训练: 深度学习, 自然语言处理，时序预测，GBDT/LR, AutoML 模型可视化 在线服务 工具 采集: SDK(JS, Android, iOS, 小程序，服务端，全埋点), ID Mapping, 归因链路 实施工具: 事件管理，变量管理，命名工具，埋点SLA配置, 预警配置，session管理，生命周期管理，tag管理，测试工具，ABTest工具 分析工具: 事件分析，漏斗分析，分布分析，留存分析，数据看板，热图分析，归因分析，自定义SQL查询, API管理，广告和活动效果监测 实现方式 代码埋点 全埋点、可视化全埋点（圈选） 规范 结构与命名清晰 方便历史版本对比 每个埋点数据质量负责到人（开发、测试、数据负责人） 数据统一管理 尽量用工具自动化 企业中台 # 数据 租户 用户 micro service 每个service监控 每个service不单点 单功能拆分，边界明确 service间只依赖sdk(好莱坞法则)，通过服务总线发现 servcie无状态接入 分类 内部服务 internal # 内外服务用互相转化 文件上传 图像处理 数据挖掘 报表 外部服务 external # 流控、质量监控、多链路备用、降级方案 邮件 短信 推送 cti 企业信息校验 业务服务 transaction 审批流 工作流 登录 海 核心服务 core 租户id服务 检索服务 报表服务 监控服务 k8s 服务总线 支持服务 supportive 文档 测试环境 沙盒同步 插件服务 plugin 集成服务 integration 事务服务 finance CPQ ERP saas基础 计费 用户管理 联动 导入企业数据 调用aws或aliyun，提供webhook 服务的sdk 多语言sdk 降级 ha apm 服务监控 # 用于发现问题、追查事故、评估缩容或扩容、评估降级 日志 接口 # 调用服务提供的监控接口 系统 # 容器提供 apm # 客户端采样 可达性 # 由通用监控完成 工程 打包docker镜像 服务升级 灰度发布与AB test 提供api版本接口供客户端查询 服务总线 管理服务状态、位置 本地生活 # 服务与功能</description>
    </item>
    
    <item>
      <title>Haskell</title>
      <link>https://runout.run/docs/pl/haskell/</link>
      <pubDate>Tue, 09 Oct 2018 16:54:16 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/haskell/</guid>
      <description>介绍 # 源于ML 标准化的、纯函数式编程语言 非限定性语义和强静态类型 作为其他语言设计新功能时的样板，如Python的lambda标记语句 工具 # 检索函数用http://www.Haskell.org/hoogle 单词 # polymorphism # 多态 monomorphic # 单态 风格 # point free style sum&#39; xs = foldl (+) 0 xs sum&#39; = foldl (+) 0 注意 # 使用缩进代替括号，但也可用括号 文件扩展名 # # 文件中不用let定义变量, # 变量赋值两次会报错, 这意味着代码顺序不重要 hs 内置变量 # pi 模块 # :m Data.Char Data.Map # 加载模块 chr # chr :: Int -&amp;gt; Char ord # ord :: Char -&amp;gt; Int toUpper toLower import Data.</description>
    </item>
    
    <item>
      <title>Html</title>
      <link>https://runout.run/docs/pl/markup_language/html/</link>
      <pubDate>Tue, 09 Oct 2018 16:42:05 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/markup_language/html/</guid>
      <description>事件 # blur change click dblclick focus keydown keypress keyup load mousedown mousemove mouseout mouseover mouseup reset select submit unload Abort # 中断图片下载时激发 AfterPrint # 打印文档后激发 AfterUpdate # 传送完数据 BeforeCopy # 复制到剪贴板前 BeforeCut # 剪切到剪贴板前 BeforeEditFocus BeforePaste BeforePrint BeforeUnload BeforeUpdate Bounce CellChange CtextMenu Copy Cut DataAvailable DatasetChanged DatasetComplete Drag DragDrop DragEnd DragEnter DragLeave DragOver DragStart Drop Error ErrorUpdate FilterChange Finish Help LoseCapture Move Paste PropertyChange ReadyStateChange Resize RowEnter RowExit RowsDelete RowsInserted Scroll SelectStart Start Stop 标签 # &amp;lt;var&amp;gt; # 标识常量 &amp;lt;samp&amp;gt; # 标识输出内容的样式 &amp;lt;pre&amp;gt; # 代码块 &amp;lt;code&amp;gt; # 一段代码 属性 # 全局属性 # 配置所有元素共有行为 accesskey # 快捷键 ## 需要按alt + 指定的键 class contenteditable # 内容是否可修改, 如p标签 contextmenu # 定义右键菜单，未实现 dir # 文字对齐方式 draggable dropzone hidden id lang spellcheck style tabindex # tab键切换元素的顺序 title 浏览器特性 # 视频播放 支持vaapi, chrome 加上--enable-vaapi参数可以开启硬件加速解码 方案 # 标签 &amp;lt;input&amp;gt;表单 单选框 &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; checked value=&amp;quot;1&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; value=&amp;quot;1&amp;quot;&amp;gt; 下拉框 &amp;lt;select id=&amp;quot;mySelect&amp;quot; size=10 multiple&amp;gt; # 长度等于10 ，多选 &amp;lt;option selected=&amp;quot;selected&amp;quot;&amp;gt;Apple&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;Orange&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; 勾选框 &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;&amp;quot; /&amp;gt; 按钮 &amp;lt;input type=&amp;quot;button&amp;quot;/&amp;gt; &amp;lt;button&amp;gt; # &amp;lt;button&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;搜索&amp;lt;/button&amp;gt; button之间可以加图片 &amp;lt;table&amp;gt;表格 &amp;lt;caption&amp;gt; # 标题 &amp;lt;thead&amp;gt; &amp;lt;th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;td&amp;gt; &amp;lt;/th&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tfoot&amp;gt; 属性 &amp;lt;tr style=&amp;quot;display: none;&amp;quot;&amp;gt; # 设置属性为隐藏 &amp;lt;form&amp;gt;表单 enctype属性 application/x-www-form-urlencoded(默认) # 在发送编码所有字符（空格转换为 &amp;quot;+&amp;quot; 加号，特殊符号转换为 ASCII HEX 值） multipart/form-data # 不对字符进行编码，在上传文件时使用 text/plain # 空格转换为+，但是不对特殊字符进行编码 &amp;lt;hr&amp;gt;分割线 字体 &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; .</description>
    </item>
    
    <item>
      <title>Css</title>
      <link>https://runout.run/docs/pl/markup_language/css/</link>
      <pubDate>Tue, 09 Oct 2018 16:27:24 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/markup_language/css/</guid>
      <description>基础 # # cascading style sheet 层级匹配 不同级 1. style属性 2. style标签 3. link标签 4. 浏览器中用户自定义样式表 5. 浏览器默认样式 # 浏览器对每个元素定义了默认的样式表 !important color: black !important 同级 # 评估得出最特殊的样式, 评分相同时，使用最后的 1. id值的数目 2. 其它属性和伪类的数目 3. 元素名和伪元素的数目 继承 部分元素继承父元素样式 外观继承 布局不继承 inherit # 指明使用父元素样式 border: inherit 三种引入方式 内联式 &amp;lt;div style=&amp;quot;color:#000;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 嵌入式 &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt; div {color:#000;} &amp;lt;/style&amp;gt; 引用式 &amp;lt;link href=&amp;quot;css.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt; @ @charset &amp;quot;UTF-8&amp;quot; # 默认UTF-8, 在import前 @import &amp;quot;styles.css&amp;quot; # 静态引用, 效率比&amp;lt;link&amp;gt;标签慢 单位 # 颜色 名称, 如silver, gray 0xffffff rgb(112, 128, 144) rgb(112, 128, 114, 0.</description>
    </item>
    
    <item>
      <title>Elixir</title>
      <link>https://runout.run/docs/pl/elixir/</link>
      <pubDate>Tue, 09 Oct 2018 16:24:04 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/elixir/</guid>
      <description>介绍 # 跑在erlang虚拟机上 与erlang相同，actor称作进程, 是比线程更轻量的概念 使用 # o-&amp;gt; 元组 {:foo, &amp;quot;this&amp;quot;, 42} # 三元组 o-&amp;gt; actor defmodule Talker do def loop do receive do {:greet, name, age} -&amp;gt; IO.puts(&amp;quot;Hello #{name}&amp;quot;) {:shutdown} -&amp;gt; exit(:normal) end loop end end pid = spawn(&amp;amp;Talker.loop/0) send(pid, {:greet, &amp;quot;Huey&amp;quot;, 16}) sleep(1000) Process.flag(:trap_exit, true) pid = spawn_link(&amp;amp;Takler.loop/0) send(pid, {:shutdown}) receive do {:EXIT, ^pid, reason} -&amp;gt; IO.puts(&amp;quot;Talker has exited (#{reason})&amp;quot;) end o-&amp;gt; 有状态的actor # 递归 defmodule Counter do def start(count) do spawn(__MODULE__, :loop, [count]) # 伪变量__MODULE__, 是当前模块的名字 end def next(counter) do send(counter, {:next}) end def loop(count) do receive do {:next} -&amp;gt; IO.</description>
    </item>
    
    <item>
      <title>Go</title>
      <link>https://runout.run/docs/pl/go/</link>
      <pubDate>Tue, 09 Oct 2018 16:10:44 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/go/</guid>
      <description>基础 # 特点 易工程化 简单性而不方便性，避免工程复杂性乘法增长 # 某部分变复杂，增加其他部分的复杂性(功能、选项、配置) 没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储 类型系统，无类型风格 自然方式工作 不显式初始化和隐式构造函数 集合直接持有元素 标准库避免配置和解释 # 自带电池 项目结构简单 编译检查代码格式 csp(communicating sequential process)并发，变长栈运行轻量线程 编译为本地机器码 # 像c一样，所以又叫类c语言 编译快 引用包名在头 包依赖有向无环，可独立和并行编译 目标文件包含依赖包信息 强静态类型 有gc 变长栈，最小2kb, 最大1GB 大厂支持 历史 2007年设计，受影响于Alef(CSP系列), Oberon-2(ALGOL60, Modula-2系列), C # 目的解决google许多复杂性激增的软件系统 2009年发布, 作者是Robert Griesemer, Rob Pike, Ken Thompson 2012年1.0 并发编程特点 语言层面关键字 例程 流程控制: csp # channel为一等公民 通信方式: promise-future, channel, event 高效调度模型(调度器，资源占用小) O(1)的调度 一进程可支撑上百万例程,5kib/goroutine的开销, 变长栈存goroutine 编译 CGO_ENABLED=0 # 静态链接，不跨平台 初始化 包级别初始化在main前 局部变量在函数执行时 配置 GOROOT # go安装目录 GOPATH # 包目录, 默认要有go的bin目录 GOBIN # 当前bin目录 GO15VENDOREXPERIMENT # 依赖目录 GOOS # 指定操作系统, 如android, linux, darwin, windows GOARCH # 处理器架构，如amd64, 386, arm 命令 # go help importpath # 说明 指定代码托管网站版本协议 gopath # vendor怎么使用 list # go list 说明 version env # 打印go环境信息 run # 编译并运行 -race # 检查运行中的竞态冲突并报告 build # 库被舍弃，main包编译成二进制执行文件, 会检测mod go build gopl.</description>
    </item>
    
    <item>
      <title>Python</title>
      <link>https://runout.run/docs/pl/python/</link>
      <pubDate>Tue, 09 Oct 2018 16:05:05 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/python/</guid>
      <description>介绍 # 虚拟机语言 虽然是脚本语言，可以预编译成pyc文件来执行 shell # #! /usr/bin/python # -*- coding: utf8 -*- 语法 # 规范 pep8 内置函数 # o-&amp;gt; input(&amp;quot;&amp;quot;) # x = int(input(&amp;quot;Please enter an integer:&amp;quot;)) print(&amp;quot;%s&amp;quot;, % s1) ## %.3s % (&amp;quot;abcdef&amp;quot;)取3字符 ## %.* s % (2, &amp;quot;abcd&amp;quot;)取2字符) # %r repr()显示字符串 # %c 单个字符 # %b 二进制整数 # %x 十六进制整数 # %d 十进制整数 # %i 十进制整数 # %o 八进制整数 # %e %E 指数(基底分别为e E) # %-10.3f %-10.</description>
    </item>
    
    <item>
      <title>Clojure</title>
      <link>https://runout.run/docs/pl/clojure/</link>
      <pubDate>Tue, 09 Oct 2018 16:00:21 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/clojure/</guid>
      <description>介绍 # 是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程 操作符知道自己的特征值(identity value), 如+是0, *是1 数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃 集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能 # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的 没有尾递归优化，不常用递归，要用loop.recur 语法 # s-expressions (max 3 5) (+ 1 (* 2 3)) (def meaning-of-life 42) (if (&amp;lt; meaning-of-life 0) &amp;quot;negative&amp;quot; &amp;quot;non-negative&amp;quot;) (def droids [&amp;quot;Huey&amp;quot; &amp;quot;Dewey&amp;quot; &amp;quot;Louie&amp;quot;]) (count droids) (droids 0) (def me {:name &amp;quot;Paul&amp;quot; :age 45 :sex :male}) (:age me) (defn percentage [x p] (* x (/ p 100.0))) (percentage 200 10) 并发 # o-&amp;gt; 原子变量 # 对一个值进行同步更新 (def my-atom (atom 42)) (deref my-atom) @my-atom (swap!</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>https://runout.run/docs/pl/js/</link>
      <pubDate>Tue, 09 Oct 2018 10:31:30 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/js/</guid>
      <description>基础 # 特性 原型链, 面向对象, 动态语言(已超出脚本语言的范畴) 弱类型，变量都是var 解释器有自己的内存管理机制(garbage collection) 自由数据类型转换 # 产生了==, ===的判断相等的不同定义 v8引擎 直接生成机器码 分代式GC java jvm工程师参数了优化 历史 Netscape(现Mozilla)创建JavaScript, 但JavaScript是Sun(现Oracle)的注册商标 作为标准提交给ECMA(欧洲计算机制造协会), 改名为ECMAScript ECMAScript 3(ES3) 作为标准广泛使用 ECMAScript 5(ES5) 定义了新的语言标准 JavaScript1.5是Mozilla的版本号, 相当于ES3,包含一些非标准语言扩展 JavaScript1.8 在实现es7 JavaScript解释器或引擎(engine)也有版本号 Google的叫做V8(现在是4.0) 微软改动并取名Jscript 标准 # ECMAScript 6 # 介绍 目标是js可写 复杂的应用程序 函数库 代码自动自成器(code generator) mozilla基于ECMAScript6 发布 JavaScript2.0 V8, node.js使用 let # 块级作用域中声明变量 const # 声明常量 Set对象 # 同java Set, 是一个数组 属性 size 方法 add(value) delete(value) has(value) clear() Map对象 # 键值对，键可以是对象 使用 var m = new Map(); o = {p: &amp;quot;Helllo&amp;quot;}; m.</description>
    </item>
    
    <item>
      <title>JavaWeb</title>
      <link>https://runout.run/docs/pl/java/javaweb/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/java/javaweb/</guid>
      <description>基础 # 分层 视图层 jsp 控制层 servlet 业务层 过滤数据 manager层 封装第三方，service能力下沉，dao中间件 数据访问层对象 封装对象 数据库 java web 13种技术 JDBC Java Database Connectivty JNDI Java Name and Directory Interface EJB Enterprise JavaBean RMI Remote Method Invoke Java IDL/CORBA JSP Java Server Pages Java Servlet XML Extensible Markup Language JMS Java Message Service JTS Java Transaction Service JTA Java Transaction Architecture JavaMail JAF JavaBeans Activation Framework jsp # 基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层 域对象 pageContext # 当前页面有效 request # 一次请求范围 session # 会话 application context # 同一服务器 内置对象 Request Response Session Out # 输出流 PageContext # context Page # jsp的this Exception # &amp;lt;%@ page isErrorPage=&amp;quot;true&amp;quot;%&amp;gt; 时使用，显示异常信息 Application # 服务器 Config # 服务器配置 jsp-el表达式 # ${ } 11个内置对象 pageContext // pageContext page // map （相当于pageScope，不过写法上省略了Scope） requestScope // map sessionScope // map applicationScope // map param // map ,用${param.</description>
    </item>
    
    <item>
      <title>Java并发</title>
      <link>https://runout.run/docs/pl/java/juc/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/java/juc/</guid>
      <description>基础 # 并发编程三大特性 可见性(visibility) synchronized会刷新线程栈 有序性(ordering) 原子性(atomicity) CPU # PC寄存器(Program Counter Register, 存下一指令) 优化 乱序读 合并写 乱序执行(流水线) ALU 访问速度 Registers: &amp;lt; 1ns L1 cache(核内): 1ns WC(Writer Comblining) Buffer # 合并写, 一般4个字节 L2 cache(核内): 3ns L3 cache(CPU内): 15ns memory: 80ns 局部性原理 空间 按块读取(cache line) 一次读64Bytes # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知 Java1.8注解@Contended # 保证不在同一行，需要JVM参数-XX:-RestrictContended 时间 批量读指令 内存屏障 # 不同CPU不一样 Intel sfence # save, 之前写操作必须完成 lfence # load, 之前读操作必须完成 mfence # mix(save + load) lock指令 # 指令执行完之前，锁内存 lock_add CPU缓存一致性协议 # # 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁 状态 MESI Cache一致性协议 # Intel CPU，实现方式为主动监听 Modified # 一行数据在CPU Modified, 其它CPU为Invalid Exclusive # 独享，其它CPU没有 Shared # 别人也在读 Invalid # 别人改过了 MSI MOSI 缓存行 # 多数64字节 伪共享 # 缓存行内无关数据也要同步 OS # 进程 # 资源分配 线程 # 调度执行 切换(Context Switch) CPU导出原线程指令和data到cache, 再导入新线程数据 线程数 N(threads) = N(CPU) * U(CPU) * (1 + W/C) # N(CPU): CPU数 # U(CPU): 期望CPU利用率, 0到1 # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析 压测决定 CPU性能压榨 单进程 批处理 多进程切换 多线程进程内切换 I/O复用 协程(纤程、绿色线程)用户空间切换 JVM # 内存屏障 # LoadLoad StoreStore LoadStore StoreLoad 乱序执行(指令重排序) # 为什么 CPU快, 指令1阻塞时，指令2先执行 判断 代码不影响单线程最终一致性 例子，多线程 static int x = 0, y = 0; static int a = 0, b = 0; void main(){ for (long i = 0; i &amp;lt; Long.</description>
    </item>
    
    <item>
      <title>Java设计模式</title>
      <link>https://runout.run/docs/architect/code/design_mode/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://runout.run/docs/architect/code/design_mode/</guid>
      <description>六个原则 # 单一职责原则(SRP, Single Responsibility Principle) 一个类只做一件事，应该只有一个引起它修改的原因 开闭原则(OCP, Open-Close Principle) 对修改封闭，对扩展开放 里氏替换原则(LSP, the Liskov Substitution Principle) 子类可以完全替换父类。也就是继承只扩展新功能 依赖倒置原则(DIP, the Dependency Inversion Principle) 细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定 接口隔离原则(ISP, the Interface Segregation Principle) 客户端不依赖它不需要的接口。冗余依赖应该将接口拆分 迪米特法则（最少知道原则）(LoD, Law of Demeter) 一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话 构建型 # 工厂方法(Factory Method) # # 简单工厂, 根据参数创建不同的类 # 静态工厂，单例工厂 public interface Sender{ public void Send(); } public class MySender implements Sender{ @Override public void Send(){} } public SenderFactory { public static Sender produceStatic() { return new MySender(); } public Sender produce(){ return new MySender(); } public Sender produce(int i){ return new MySender(); } } # 工厂子类继承工厂接口, 不同产品对应不同工厂 public interface AbstractFactory { public MySender produce(); } public class MyFactory implements AbstractFactory { @Override public MySender produce(){ return new MySender(); } } 抽象工厂(Abstract Factory) # # 生产抽象产品 public interface AbstractFactory { public Sender produce(); } public class MyFactory implements AbstractFactory { @Override public Sender produce(){ return new MySender(); } } 单例(Singleton) # 确保只有一个实例 # 大多有资源管理器的功能 # 反射机制会使所有单例失效：私有构造方法可以被访问 应用 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 o-&amp;gt; 饿汉 public class Singleton { public static Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } o-&amp;gt; 懒汉式 public class Singleton { private static Singleton single=null; private Singleton() {} public synchronized static Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; } } o-&amp;gt; 懒汉，双重检测(DCL) # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。 # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized public class Singleton { private static volatile Singleton singleton = null; # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。 private Singleton(){} public static Singleton getInstance(){ if (singleton == null) { // t1,t2并发进入 synchronized (Singleton.</description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://runout.run/docs/pl/java/jvm/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://runout.run/docs/pl/java/jvm/</guid>
      <description>基础 # 定义 JVM规范说明书, JVMS(Java Virtual Machine Specifications) Java语言规范, JLS(Java Language Specification) 虚拟机 指令集 内存管理 过程 x.java -&amp;gt; javac -&amp;gt; x.class -&amp;gt; ClassLoader -&amp;gt; (字节码解释器、JIT) -&amp;gt; 执行引擎 JVM语言 Scala, Kotlin, Groovy, Clojure, jython, jruby等100多个 JVM实现 HotSpot # Oracle官方, 8之后收费, OpenJDK为开源版本 Jrockit # Oracle收购, 合并入HotSpot J9 # IBM Microsoft VM TaobaoVM # HotSpot深度定制 LiquidVM # 直接匹配专门硬件 azul zing # 收费，快, GC1mm, HotSpot参考写的G1 JRE, JDK JRE = jvm + core lib JDK = JRE + development kit JVM构造 # 指标 # 吞吐量: 代码时间 / (代码时间 + GC时间) 响应时间: STW越短, 响应时间越好 指令(Instructions) # 分类 基于栈的指令类 # 简单, HotSpot 基于寄存器的指令集 # 复杂但快, HotSpot局部变量表 8大原子操作(JSR-133已放弃这个描述，但指令没变化) lock # 主内存，标识变量线程独占 unlock # 主内存，解锁独占 read # 主内存，读到工作内存 load # 工作内存，read后的值放入线程本地变量副本 use # 工作内存，传值给执行引擎 assign # 工作内存，执行引擎结果赋值给线程本地变量 store # 工作内存，存值到主内存给write备用 write # 主内存，写变量值 方法指令 # 在methods的Code中罗列 aload_0 # 变量表第0项入栈 invokespecial #1 # 调private(无多态)的方法 invokevirtual # 调有多态可能性的方法 invokestatic # 调静态方法 invokeinterface # 调interface方法 invokedynamic # 1.</description>
    </item>
    
    <item>
      <title>算法思想</title>
      <link>https://runout.run/docs/basic/algorithm/thought/</link>
      <pubDate>Mon, 08 Oct 2018 22:21:21 +0800</pubDate>
      
      <guid>https://runout.run/docs/basic/algorithm/thought/</guid>
      <description>口诀 # 难题首选动归 受阻贪心暴力 考虑分治思想 配合排序哈希 递归(recursion) # 介绍 利用递归，把状态的管理责任推给运行时 递归转迭代 可加上memory做优化 分治(divide and conquer) # 介绍 广义分治法 例子 二分检索 找最大/最小元素 归并分类 快速分类 选择问题 斯特拉森矩阵乘法 贪心(greedy) # 案例 Dijkstra最短路径 最小生成树Prim, Kruskal 背包问题 作业排序 最优归并模式 动态规划(dynamic planning) # 方法 常用滚动数组降低空间复杂度 案例 多段图 结点间最短路径 最优二叉检索树 0/1背包问题 可靠性设计 货郎担问题(旅行商问题) 流水线调度问题 检索与周游(retrieval/travel) # 案例 深度优先检索 广度优先检索 与/或图 对策树 回溯(backtracking) # 案例 8皇后问题 图的着色 哈密顿环 背包问题 暴力(brute force) # 介绍 分支限界条件加快效率 例子 DFS, BFS 分支-限界(branch and bound) 案例 LC检索 0/1背包问题 货郎担问题 并行(parallel) # 时间复杂度(time complexity) # O()表示上界(&amp;lt;=), Ω() [omega]表示下界(&amp;gt;=), Θ() [Theta] 表示上下界相同, o()表示非Θ()的O() N &amp;gt;= n0时, T(N) &amp;lt;= cf(N), 记为T(N) = O(f(N)) N &amp;gt;= n0时, T(N) &amp;gt;= cg(N), 记为T(N) = Ω(g(N)) T(N) = Θ(h(N)) 当且仅当T(N) = O(h(N)) 和 T(N) = Ω(h(N)) 上界(upper bound) 下界(lower bound) 法则 # 约定, 不存在特定的时间单位 # 约定, 机器模型中, 1.</description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://runout.run/docs/basic/algorithm/data_structure/</link>
      <pubDate>Sun, 07 Oct 2018 13:46:46 +0800</pubDate>
      
      <guid>https://runout.run/docs/basic/algorithm/data_structure/</guid>
      <description>线性 # 列表(list) 数组(array) # 相同数据类型元素的序列，下标(index)访问 low high 字符串 二进制串(binary string) # 位串(bit string) 链表(linked list) 节点(node) 指针(pointer) 表头(header) 单链表(singly linked list) 双链表(doubly linked list) 栈(stack) # 插入和删除只能在端部进行的列表，应用于递归 栈顶(top) LIFO last-in-first-out 队列(queue) 队头(front) 队尾(rear) 入队(enqueue) FIFO first-in-first-out 优先队列(priority queue) # 数据项多来自于全序域(常整数或实数) 查找最大元素，删除最大元素，插入新元素 堆(heap)实现 散列表 # 介绍 有序输入时，树效率低，如果不要求查找有序结果，可以用散列 概念 hash table hashing(散列) item(项) key(关键字) # 项中某部分 hash function(散列函数) # 映射函数 collsion(冲突) # 多个关键字散列到同项的状况 load factor(装填因子) # λ 元素个数对表长度的比， # 如果散列是均匀的，表示了一个项中关键字的平均长度 # 一次成功查找要遍历约1 + (λ / 2)个链，1表示被匹配的项 rehashing(再散列) 一半时进行 直到插入失败再进行 middle-of-the-road # 到达某load factor时进行 caching the hash code(闪存散列代码) 算法 separate chaining(分离链接法) # 解决冲突 probing hash table(探测散列表) 线性探测法 primary clustering(聚集) # 线性探测法中形成数据区块 平方探测法 secondary clustering(二次聚集) # 模拟结果指出，对每次查找，会引起另外的少于一半的探测 double hashing(双散列) # 模拟表明, 两个散列都mod质数时，探测次数几乎和随机冲突解决方法相同 extendible hashing(可扩散列) D directory(目录) # 一个分区中bit的个数，所以M最多2^D 性质 # 基于位模式(bit patterm)是均匀分布的事实, 是&amp;quot;分支系数(branch factor)&amp;quot;, N 是记录总数(随时间变化) 树叶期望个数为(N/M)log(2)(e) 所以平均树叶满的程度为ln2 = 0.</description>
    </item>
    
    <item>
      <title>数学</title>
      <link>https://runout.run/docs/basic/algorithm/math/</link>
      <pubDate>Sun, 07 Oct 2018 12:46:46 +0800</pubDate>
      
      <guid>https://runout.run/docs/basic/algorithm/math/</guid>
      <description>指数 # X^A * X^B = X^(A + B) X^A / X^B = X^(A - B) (X^A)^B = X^(A * B) X^N + X^N = 2X^N &amp;lt;&amp;gt; X^(2N) 2^N + 2^N = 2^(N + 1) 对数 # 约定 计算机科学中, log默认为log(2) X^A = B, log(X)(B) = A log(A)(B) = log(C)(B)/log(C)(A) logAB = logA + logB 级数 # ∑(i=0)(N)2^i = 2^(N + 1) - 1 ∑(i=0)(N)A^i = (A^(N + 1) - 1) / (A - 1) 如果0 &amp;lt; A &amp;lt; 1, 则 &amp;lt;= 1 / (1 - A) ∑(i=1)(∞)i/2^i = 2 ∑(i=1)(N)i = N(N + 1) / 2 ≈ N^2 / 2 ∑(i=1)(N)i^2 = N(N + 1)(2N + 1) / 6 ≈ N^3 / 3 ∑(i=1)(N)i^k ≈ N^(k + 1) / |k + 1| k &amp;lt;&amp;gt; -1 k = -1时, Hn = ∑(i=1)(N)1 / i ≈ log(e)(N), Hn是调和级数 该近似式误差趋向于 λ ≈ 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/architect/strategy/ai/deep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/architect/strategy/ai/deep/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/architect/strategy/datalake/ecology/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/architect/strategy/datalake/ecology/</guid>
      <description>Hadoop体系 # 发行版 Apache Hadoop CDH(Cloudera&#39;s Distribution Including Apache Hadoop) HDP(Hortonworks Data Platform) 宜信 D.Bus # 数据收集与计算 UAVStack # AIOps, 智能运维 UAV.Monitor # 监控 UAV.APM # 性能管理 UAV.ServiceGovern # 服务治理 UAV.MSCP # 微服务计算 Wormhole # SPaaS(Stream Processing as a Service) Gartner # ITOA，算法即运维 大数据 PB级数据 4V volume(大量) velocity(高速) variety(多样) value(低价值密度) 场景 物流仓储: 精细化运营，命中率 推荐 保险: 风险预测 金融: 用户特征 房产: 精准投策、营销 AI 组织部门 平台: 集群 Hadoop、Flume、Kafka、HBase、Spark等搭建 性能监控、调优 数据仓库: 写SQL ETL, 数据清洗 Hive, 数据分析、建模 数据挖掘 数据支持 算法、推荐、用户画像 报表 JavaEE hadoop Apache开源, 分布式系统基础架构 面临问题 硬盘 1块: 10TB-14TB 1PB: 102块硬盘 算 MySQL5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/architect/strategy/iot/framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/architect/strategy/iot/framework/</guid>
      <description>ThingsBoard # # java, 社区版、企业版 文档 github.com/thingsboard/thingsboard thingsboard.io/docs localhost:8080/swagger-ui.html # 本地swagger 安装 docker docker run -it -p 9090:9090 -p 1883:1883 -p 5683:5683/udp -v ~/.mytb-data:/data -v ~/.mytb-logs:/var/log/thingsboard --name mytb thingsboard/tb-postgres maven 确定ui/pom.xml中&amp;lt;nodeVersion&amp;gt; mvn install -DskipTests 配置 application zk ZOOKEEPER_ENABLED ZOOKEEPER_URL cassandra CASSANDRA_URL CASSANDRA_USERNAME CASSANDRA_PASSWORD redis REDIS_HOST REDIS_PORT REDIS_DB REDIS_PASSWORD postgresql SPRING_DATASOURCE_URL SPRING_DATASOURCE_USERNAME SPRING_DATASOURCE_PASSWORD kafka TB_KAFKA_SERVERS 运行 application server transport http demo数据 admin sysadmin@thingsboard.org sysadmin tenant tenant@thingsboard.org tenant customer customer@thingsboard.org或customerA@thingsboard.org customer customerB@thingsboard.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/basic/computer/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/basic/computer/performance/</guid>
      <description>基础 # 性能指标 latency throughput qps = throughput / latency 性能分析 bottle-nect(first-principle) 资源 CPU和GPU 内存 磁盘 网络 能源 逻辑资源 fds(文件描述符) sockets 内核对象: locks inodes(磁盘索引节点) transactions ip addresses ports random numbers(分布式随机数) 容量 2000前 尽量少 200~ 不到机型限制 2017 尽量把机器用满 以后 metrics分离, 单独规划 计算 # cpu gpu 存储 # 类型 时间 描述 L1 cache 0.5ns branch mispredict(分支、转移) 5ns L2 cache 7ns 14x L1 cache Mutex lock/unlock 25ns Main memory 100ns 20x L2 cache, 200x L1 cache 1k字节压缩Zippy 3,000ns = 3us 在1Gbps网络上发送1k字节 10,000ns = 10us SSD随机读4k 150,000ns = 150us 1GB/秒 内存顺序读1MB 250,000ns = 250us 同一数据中心往返 500,000ns = 500us SSD顺序读1MB 1,000,000ns = 1000us = 1ms 1GB/秒, 4x 内存 磁盘搜索 10,000,000ns = 10,000us = 10ms 20x 数据中心往返 磁盘顺序读1MB 20,000,000ns = 20,000us = 20ms 80x 内存, 20x SSD 发包: 美国 -&amp;gt; 荷兰 -&amp;gt; 加拿大 150,000,000ns = 150,000us = 150ms 传输 # 带宽 热门并发1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/cache/ops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/cache/ops/</guid>
      <description> java # -Dserver.port=18001 -Deureka.client.serviceUrl.defaultZone=http://localhost:19090/eureka -javaagent:/opt/svc/apache-skywalking-apm-bin/agent/skywalking-agent.jar -Dspring.profiles.active=prod -Dlogging.config=classpath:logback-spring-prod.xml mac os 改mac # sudo /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -z sudo ifconfig &amp;lt;intf&amp;gt; lladdr 00:bb:cc:dd:ee:ff </description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/cache/work_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/cache/work_code/</guid>
      <description>框架编写 # 命令 # git update-index &amp;ndash;assume-unchanged a mvn clean deploy -P keruyun -pl alsc-item-solution-kryun-dish-client -DskipTests
阿里云搜索词 # 大屏 # and tag:path: &amp;ldquo;/data/app/jncloud/screen/log/info.log&amp;rdquo; and resourceMap and {7435ca87-1c8c-4c76-bcfd-6f45b9c8b167} 时长请求 # tag:path:/var/log/nginx/access.log and upstream_response_time &amp;gt; 1 | select distinct request_uri , count(request_uri) as &amp;ldquo;count&amp;rdquo;, max(upstream_response_time) as max_time, min(upstream_response_time) as min_time, avg(upstream_response_time) as avg_time from log group by request_uri order by count desc
IP分布 # tag:path:/var/log/nginx/access.log | select count(1) as c, ip_to_province(remote_addr) as address group by address order by c desc limit 100 tag:path:/var/log/nginx/access.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/db/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/db/elasticsearch/</guid>
      <description>介绍 # 分布式实时lucene 使用 # ./bin/elasticsearch curl http://localhost:9200 命令 # elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name 概念存储 # index type # document中加_type field实现 # 所以不同type中的field在index要唯一，否则冲突 # 对field排序会载入所有type的document document # 对应lucene中的key value倒排文档 # 对就一个请求的json对象 field mapping # 定义type的field，映射json到document field 设置 # config/elasticsearch.yml action.auto_create_index: -l*, +z* # 自动创建，以z开头和非l开头的索引 action.destructive_requires_name: true # 允许通配删index http.cors.enables: true http.cors.allow-origin: &amp;quot;*&amp;quot; cluster.name: c1 node.name: n1 node.master: true node.data: true transport.host: localhost transport.tcp.port: 9300 network.host: 0.0.0.0 # 修改es监听地址，别的机器也可以访问。同时设置bind_host和publish_host # 需要设置transport.host:localhost network.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/db/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/db/mysql/</guid>
      <description>基础 # 介绍 c++编写 端口 3306 命令 mysql --max-relay-logs-size=300 # 中继日志大小(sql语句数) --relay-log-purge={0|1} # 中继日志自动清空 --relay-log-space-limit=0 # 限制中继日志大小,0表示无限制 o-&amp;gt; mysql -h 127.0.0.1 -u root -p mysqldump -uroot -p -h127.0.0.1 -P3306 --force --all-databases # 所有库 --databases db1 db2 # 多库 o-&amp;gt; mysqldump -uroot -p db1 tb1&amp;gt; tb1.sql mysqladmin -uroot -p status # 查看当前连接数 组件 mysql enterprise monitor documentation mysql enterprise monitor connector mysql enterprise monitor service manager mysql enterprise monitor agent mysql enterprise backup mysql connector 工具 mysql database mysql cluster # 创建集群，配置复杂 mysql cluster manager # cluster帮助软件，配置简单 mysql workbench # 据库建模工具 mysql utilities # 提供一组命令行工具用于维护和管理 MySQL 服务器 连接参数 root:123456@tcp(abcdefg:3306)/meiqia?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/db/oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/db/oracle/</guid>
      <description>基础 # 安装 运行services.msc 找到OracleServiceORCL 服务 （最后是数据库名）改为手动 sqlplus / as sysdba 运行oracle测试是否安装成功 解锁scott用户 sqlplus / as sysdba alter user scott account unlock; alter user scott identified by tiger; 启动 OracleServiceORCL OracleOraDb11g_home1TNSListener 端口 1521 # 停了以后再开会变 权限 系统权限：创建数据库，创建用户 对象权限：表操作 sys create database权限 system 没有create database权限 scott hr 角色 # 超管以角色进入，普通用户输入用户名密码 dba dbaoperator 服务器的组成 oracle数据库 存储位置 oracle安装位置/oradata/ 每个数据库文件夹中有多个二进制文件（*.dbf） oracle实例(内存概念) 一个数据库进程可以有多个实例 一个实例可以有多个数据库进程和一个内存池(缓存) # 不同于windows进程，每个进程对应一个用户访问 服务名为OracleService数据库名 集群(多实例) 连接失败转移 负载均衡 连接类型 normal sysdba sysoper 分布式 认证 开发技术认证 Java认证 数据库开发语言SQL和PL/SQL认证 数据库技术认证 OCM【大师】 OCP【专家】 OCA【初级】 中间件技术认证 OracleServer认证，WEB服务器认证 专业领域技术认证 ERP CRM HR OA 支持的事务隔离 只支持读提交与序列化两种 版本 8i 9i 10i # i是internet 11g # 基于jdk6, g是grid网格(一个请求多个服务器运行) 12c # c是cloud SQL99标准 # 不区分大小写 PLSQL是Oracle对SQl99标准的扩展 结构代查询语言 DML select,insert,update,delete DDL create table,alter table, drop table DCL grant, revoke TCL(杜撰) commit, rollback,rollback to savepoint 加载过程 启动oracle服务 oradim -startup -sid 数据库名 # 相当于windows服务中启动该服务，会从windows注册表中加载配置 oradim -shutdown -sid orcl -shuttype srvc # 停止oracle 服务 普通登录 sqlplus system/asdf # 从注册表中查找默认的数据库名称进行登录 sqlplus system/asdf@orcl # 指定数据库名登录，必须有监听的时候该命令可以执行，监听的进程是独立于oracle之外的进程 管理员登录 sqlplus / as sysdba # windows管理员的身份进行登录，不需要用户名密码，可以在配置文件中禁用它 无连接登录 sqlplus /nolog #用来设置sql/plus 启动实例 cmd&amp;gt; sqlplus / as sysdba # 连接到数据库的空闲实例 sql&amp;gt; select status from v$instance # 查看实例状态 sql&amp;gt; shutdown abort # 立即终止当前的实例,实例结束后用户仍然登录状态，但没有连接实例 sql&amp;gt; startup nomount # 启动默认实例（不加载数据库） sql&amp;gt; startup open # 启动、装载、打开默认的数据库 cmd&amp;gt; set oracle_sid=orcl # 在windows下设置oracle的默认登录数据库 启动过程 加载参数文件database/init数据库名 分配sga (system global area)到内存空间，用于缓存数据库信息 创建后台进程 挂载数据库 sql&amp;gt; startup mount 挂载过程 装载数据库文件夹中的文件 # sga中有已经初始化了ctl文件的路径，通过ctl文件装载数据库 ctl(从中得到数据库文件名) -&amp;gt; dbf # 3种数据库文件: .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/db/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/db/redis/</guid>
      <description>基础 # remote dictionary server 特点 no-sql, c编写 内存数据库 # 请求不经过parser和optimizer key-value 单线程 可持久化 与memcache区别 memcache全在内存，不能持久化，redis部分硬盘 memcache类型支持简单 # memcache类型只有字符串，append字符串, blacklist删除麻烦 emecache多线程, redis单线程 底层模型，与客户端通信协议不同，redis自己实现vm机制(冷热数据分离) value, memcache只能存1MB, redis可存1GB redis可设置expire, 支持排行榜, 浮点数 类型 string 整个或一部分操作 整数、浮点数自增自减 list 两边推入或弹出 偏移量trim 读单个多个元素 值查找移除元素 set 增删查单个元素 单个元素是否存在 交集、并集、差集 随机取元素 hash 增删查单个键值对 获取所有键值对 zset # 有序集合, 排序根据score, score为双精度浮点数 增删查单个元素 根据range或成员获取元素 应用 会话缓存(session cache) 全面缓存(FPC) 队列 排行榜/计数器 发布/订阅 命令 文件命令 redis-server # 端口为6379 redis-server /etc/redis.conf 来加载配置文件 redis-cli redis-benchmark # 性能测试工具 redis-cli命令 ping # 成功时返回 PONG shutdown # 关闭redis-server服务 -p 端口号 quit 功能 # 性能高 # 100k次读写/s 数据类型丰富 所有操作有原子性 支持发布/订阅，通知，key过期 发布订阅 subscribe psubscribe # 订阅给定模式匹配的所有频道 unsubscribe punsubscribe publish sort # 列表、集合、有序集合排序，返回结果或生成存储 过期 persist # 移除键过期时间 ttl # 键距离过期时间还有多少秒 pttl # 多少毫秒 expire # 给定键指定数秒后过期 pexpire # 指定的毫秒后过期 expireat # unix时间戳过期 pexpireat # 毫秒unix时间戳 事务 # 事务期其他客户端命令阻塞 multi # 创建事务队列，开始记录命令 exec # 提交事务队列 watch # 对键加锁 unwatch discard # 取消事务 持久化 bgsave # fork线程创建快照, windows不支持 save # 停止响应创建快照 sync # 向主服务器要求复制时，主服务器bgsave，非刚bgsave过 bgrewriteaof # 重写aof文件使它缩小 复制 slaveof 客户端分片 不完全事务 性能 # 内存数据库，需要预估内存，使用key过期节约 完整重同步占资源，可以部分重同步 重启数据加载慢 master内存快照时，save命令调rdbSave阻塞主线程 master AOF持久化，追加文件大时影响master重启恢复速度 用slave AOF master调用BGREWRITEAOF重写AOF文件时，cpu和内存负载高 主从复制最好同局域网 数据 # set mykey somvalue get mykey del mykey incr decr incrby decrby incrbyfloat append getrange setrange getbit setbit bitcount # 二进制位串位为1的数量 bitop # 二进制位串执行and, or, xor, not rpush list-key item lpush lrange list-key 0 -1 # -1为结束索引 lindex list-key 1 rpop lpop list-key lrange ltrim # 修剪 blpop # timeout秒内阻塞并等待弹出元素 brpop rpoplpush # 一个列表中右弹元素推入另一个列表左端，最后返回这个元素 brpoplpush sadd set-key item smembers set-key sismember set-key item srem set-key item # 删除，返回删除的数量 scard # 元素数 srandmember # 随机返回一个或多个元素。count正数时，返回的元素不重复, 负数时可重复 spop # 随机移除一个元素 smove # 一个集合中移除，并在一个集合中添加。返回移除的数量 sdiff # 差集 sdiffstore # 差集生成集合 sinter # 交集 sinterstore sunion # 并集 sunionstore hset hash-key sub-key value hget hash-key sub-key hdel hash-key sub-key hlen hexists hash-key sub-key hkeys hash-key hvals hgetall hash-key hincrbyfloat hincrby hash-key field -1 hmget hmset hash-key field1 &amp;quot;foo&amp;quot; field2 &amp;quot;bar&amp;quot; zadd zset-key 728 member zrange zset-key 0 -1 withscores zrevrange zset-key 0 -1 withscores zrangebyscore zset-key 0 800 withscores # 根据score范围查找 zrevrangebyscore zrem zset-key member zremrangebyrank zremrangebyscore zincrby zinterstore sum 3 sub1 sub2 sub3 # 生成交集, 重复值score相加, 3 指定可变参数的数量 zunionstore # 并集 zcard # 成员数量 zcount # 分值之间的成员数量 zrank # 返回排名 zrevrank zscore # 返回分值 client # jedis # java, 支持redis sharding, 即ShardedJedis结合ShardedJedisPool Jedis jedis = new Jedis(&amp;quot;localhost&amp;quot;); # 连接redis数据库 jedis.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/middleware/library/hibernate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/middleware/library/hibernate/</guid>
      <description>基础 # 优点 完全面向对象编程思想，无sql 减少代码 控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率 hibernate具有独立性（访问层随时可以更换） 特性 不写hbm.xml映射文件，而是基于注解的验证 对象、集合、属性的延迟加载 dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常 目录 . # hibernate程序包 documentation # 文档 lib # 所有依赖包 project # 源码文件 加载顺序 后面的覆盖前面的 hibernate.properties中的配置被覆盖 # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置 hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准） 开发流程 加载配置: jdbc参数，数据库方言，hbm映射 创建SessionFactory # 内有连接池 创建session 事务处理 关闭session 关闭连接池 对象状态 𣊬时态 # 没有OID(持久化标识), 没有关联session 持久态 # 有OID, 与session关联, 事务未提交 脱管态 # 有OID, 没有关联session 缓存机制 一级缓存(session) 事务级，事务结束缓存失效 # 请求同一对象，取得同一实例 总是打开 二级缓存 SessionFactory级别，session共享 缓存散装持久化实例, 有不同缓存策略 先设置策略，再设置过期时间与cache提供器 优点 提高速度、减小压力 缓存失效时，不立即查找，而是合并sql查找 查询方式 HQL QBC(命名查询) SQL get与load get立即加载，load延时加载 get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库 # 代理对象只存id get没有时返回null, load抛异常 检索策略 # 取关联对象 立即检索 # 一次全加载, select多 延迟检索 # 访问游离状态代理类，需要在持久化状态时已被初始化 迫切左外连接检索 # 用外连接取代select，全加载 优化 # 数据库设计调整 HQL优化 api正确使用 配置参数 # 日志、查询缓存，fetch_size, batch_size等 映射文件优化 # id生成策略，二级缓存，延迟加载，关联优化 一级缓存管理, 二级缓存策略 事务控制策略 基本概念 # o-&amp;gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题 o-&amp;gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想) DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准 它们的区别在于 hibernate中不写sql语句 ibatis中写少量sql语句 DBUtils中写sql语句 它们的另一个相同点是 底层全都是jdbc o-&amp;gt; 结构对应 javabean中的 类，对象，属性 数据库中的 表，记录，字段 o-&amp;gt; hql hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用 o-&amp;gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean 使用 # 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/pl/java/collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/pl/java/collection/</guid>
      <description>基础 # 物理容器 数组 链表 Java容器 Collection List ArrayList Vector # JDK1.0，所有方法加synchronized Stack LinkedList CopyOnWriteList # 写时复制整个list, 写加锁读无锁, 无fail-fast Set HashSet LinkedHashSet SortedSet TreeSet EnumSet CopyOnWriteArraySet ConcurrentSkipListSet Queue # 相比List添加线程友好API Deque # 双端队列 ArrayDeque BlockingDeque LinkedBlockingDeque BlockingQueue # LockSupport实现, channel, 生产者消费者 SynchronousQueue # 锁实现, 无缓冲区channel TransferQueue # CAS, 生产者带队列阻塞 LinkedTransferQueue ArrayBlockingQueue # 有缓冲区channel DelayQueue # 内部维护按时间排序队列 PriorityBlockingQueue LinkedBlockingQueue # 最大数量Integer.MAX_VALUE PriorityQueue # 堆排序实现 ConcurrentLinkedQueue # CAS Map HashMap LinkedHashMap # 双向链表，按插入或访问顺序遍历 Hashtable # JDK1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/pl/java/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/pl/java/spring/</guid>
      <description>基础 # 特点 容器, 也容纳管理了第三方框架 # 目的是解耦框架api 轻量级，模块化，无(少)侵入 IOC(inversion of control) 容器用工厂装配对象并管理, 面向接口编程 优点 降低代码量 容易测试 最小侵入性松耦合 方式 Setter 构造器 静态工厂、实例工厂 DI(dependency injection) 容器向类添加属性 # 反射，用带参构造或set方法 AOP(aspect oriented programming) # 继承是纵向组织，AOP横切入业务 # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用） 动态代理实现切入代码 权限控制 事务管理 记录日志 概念 连接点:普通方法 切入点:名称满足条件的连接点 增强（通知）类:服务对象 # 切入点与增强是多对多的 切面:切入点 + 增强类 # 我们切入的是横切面 目标对象（服务对象）：要注入的对象 通知 before # 执行前 after # 执行后 after-returning # 正常退出 after-throwing # 异常退出 around # 执行前后 代理对象(业务对象)：被注入的对象 模块 dao, orm, aop, jee, web, core 结构 核心容器(core container) Core # 最底层，资源访问，类型转换 Beans # IOC, DI, BeanFactory Context # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播 EL # 表达式语言 AOP, Aspects # Aspects对AspectsJ集成, 功能多于spring asp 数据访问/集成 JDBC ORM OXM # object xml 映射 JMS # 消息与异步通信 事务 Web/Remoting Web # ioc窗口，rmi, hessian,burlap, web service Web-Servlet Web-Struts Web-Porlet # portal认证 Test 设计模式 代理 目标对象实现接口，使用Proxy 未实现接口，使用CGLIB 单例 bean默认单例 模板, 解决代码重复问题 RestTemplate, JmsTemplate, JpaTemplate 控制器 DispatherServlet对请求分发 视图帮助(view helper) 提供jsp标签、高效宏 帮助在视图中写代码 依赖注入 BeanFactory, ApplicationContext核心理念 工厂 BeanFactory 循环依赖问题 构造器, 正在创建在Bean池标记，创建完删除标记，标记冲突报错 # 所以用@Autowired决定注入时机，不写在构造方法里 单例， 三级缓存, 提前暴露使双方都可初始化 setter, 提前暴露bean 版本 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runout.run/docs/tool/product/framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/tool/product/framework/</guid>
      <description>博客框架 # cleaver # # 基于node幻灯片 hexo # 介绍 简单轻量，基于node的静态博客框架 可以部署在自己node服务器上，也可以部署在github上 目录结构 scaffolds # 脚手架 scripts # 写文件的js, 扩展hexo功能 source # 存放博客正文内容 _drafts # 草稿箱 _posts # 文件箱 themes # 皮肤 _config.yml # 全局配置文件 db.json # 静态常量 使用 npm install -g hexo hexo version hexo init nodejs-hexo cd nodejs-hexo &amp;amp;&amp;amp; hexo server hexo new 新博客 # 产生 source/_posts/新博客.md hexo server # 启动server hexo generate # 静态化处理 github中创建一个项目nodejs-hexo, 在_config.yml中找到deploy部分，设置github项目地址 hexo deploy # 部署以后，分支是gh-pages, 这是github为web项目特别设置的分支 上github，点settings找到github pages, 找到自己发布的站点 无法访问静态资源 设置域名 申请域名 dnspod 中 绑定ip hugo # 简介 hugo由go编写，开源，特点为编译快 本文基于hugo0.</description>
    </item>
    
    <item>
      <title>Apple</title>
      <link>https://runout.run/docs/tool/develop/apple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/tool/develop/apple/</guid>
      <description>ipad # 操作 下边向上(短)：桌面 下边向上(停): dock dock拖app: 小窗、分屏 小窗向边(短): 隐藏 小窗向边(停): 分屏 小窗向上：分离 下角向内(短): 切app 下角向内(停): app表 右上角向下: 控制中心 左上角向下：通知 桌面向下: 搜索 3指左右: app内切换 4指左右：切app 4指向内(短): 桌面 4指向内(停): app表 home一下：桌面 home两下：app表 截图、导出pdf: 主按键 + 电源键 键盘：两指缩小浮动 分屏: 一指拉出dock, 一指拖出程序 siri 问答: 笑话, 常识, 抛硬币 safari: 搜索 设置: 蓝牙,飞行模式 时钟 6点起床 德国时间 倒计时 日历: 9点开会 提醒：提醒和给妈妈打电话 备忘录：记下我花了10块钱 地图：回家路线 打车 打电话, 发信息 照片 体育：比赛消息 音乐 邮件 天气 计算器 股票: xx涨了吗 朋友：xx在哪里 发微博 指定xx: 打开trello发送a 附近店 相机：自拍模式 alfred # 搜索 指定网站搜索 文件 剪贴板 计算器 自定义脚本 打字 命令 工作流 fantastical # 个人总结 名字 date 9th from 9.</description>
    </item>
    
    <item>
      <title>Jetbrains</title>
      <link>https://runout.run/docs/tool/develop/jetbrains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/tool/develop/jetbrains/</guid>
      <description>Intellij Idea # 注意 Project 相当于workspace, module 相当于工程 注册 服务器 # 发布网站 http://idea.lanyus.com http://idea.qinxi1992.cn http://idea.lianghongbo.com/licens http://im.js.cn:8888 javaagent https://zhile.io/ 快捷键 settings -&amp;gt; Keymap 设置eclipse alt + enter # 改错 shift shift # 搜索跳转 shift + f4 # 新窗口打开文件 类注释 settings -&amp;gt; Editor -&amp;gt; File and Code Templates -&amp;gt; Includes -&amp;gt; File Header /** * * @Description: ${Description} * @author: ShenWenqing * @date: Created on ${DATE} ${TIME} * */ alt + enter 可生成 serialVersionUID settings -&amp;gt; Inspections 勾选 Serializable class without &#39;serialVersionUID&#39; JDK Project Settings -&amp;gt; Project settings -&amp;gt; Build Tools settings -&amp;gt; Compilers 编码 file -&amp;gt; settings -&amp;gt; appearence里use custom font设置中文字体 file -&amp;gt; settings -&amp;gt; editor -&amp;gt; file encodings 三处utf-8 idea安装目录/bin/idea.</description>
    </item>
    
    <item>
      <title>实物工具</title>
      <link>https://runout.run/docs/tool/physics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/tool/physics/</guid>
      <description> HHKB HyBrid # 生产日期 20210108 购买日期 202104 配对方式 # 1.按Fn + q键进入配对模式。 2.再按Fn + z + ~ 键清空键盘配对信息,键盘自动关闭。 3.长按开关键重新打开键盘后按Fn + q键进入配对模式,再按Fn + Ctrl + 1/2/3/4指定一个序号。 4.然后关闭电脑蓝牙功能再打开进行搜索。 切换 # Fn + Ctrl + 1/2/3/4 Fn + Ctrl + 0 Swiftpoint ProPoint # Blix Komfort Prima # </description>
    </item>
    
    <item>
      <title>测试规划</title>
      <link>https://runout.run/docs/architect/method/test_plan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/architect/method/test_plan/</guid>
      <description>规划 # 蓝图 规范 &amp;amp; 稳定 用例规范，测试方案规范，自动化代码规范，工单处理标准，提测准人/出标准，Bug规范 线上异常监控，PPE环境监控，发布接管，线上问题对接，线上告警，自动巡检 内容 基础：功能测试，兼容性测试，性能测试，数据治理，安全测试，线上问题，环境治理，故障演练 提效：API自动化，框架&amp;amp;测试代码自动生成，自动部署&amp;amp;持续集成，数据工厂，UI自动化，Doom引流 赋能：测试用例开放，代码质量度量，story_QA，测试工具&amp;amp;平台开放，自由组装case场景，精准推荐 探索：探索性测试，契约测试，AI技术赋能测试 度量 线上：发布次数，紧急发布/回滚，工单预警数，生产冒烟数，线上工单数，复盘数 线下：代码质量数据，缺陷修复效率，Bug打回数据，自动化通过率，项目进度度量，Story owner度量 基础 # 功能测试 业务梳理：业务结构图，服务调用图，数据流，特殊逻辑时序图 用例设计：模板化，框架化 安全测试 清扫漏洞: 敏感信息，接口安全问题 工具：BurpSuite, 自研代码安全扫描工具 常态化: 下沉QA流程，研发流程加入 兼容性测试 包括：App，H5，操作系统，Web浏览器，API 线上问题治理 工具：工单系统 线上反馈线上化：钉钉机器人接入，Bug自动转移 数据沉淀及可视化 FAQ 运营自查：-&amp;gt;QA-&amp;gt;开发产品 问题解决 功能缺陷类: 开发解决-&amp;gt;QA-&amp;gt;运营 答疑问：加入自查文档 功能优化类：指派给产品 问题规约 宣导：线上群公告，线下组织文档操作和业务培训 问题分类和定级 1/5/30原则：1分钟感知，5分钟响应，30分钟解决 FAQ持续转化输出 提效 # API测试 工具: Jenkins+Newman, JMeter, 思想: 模块化，测试库，数据驱动，关键字驱动，BDD 框架 Jenkins+Python(UnitTest/Pytest, Requests, HTMLTestRunner/Allure) Jenkins+Java+Maven+JUnit/TestNG+HttpClient/RestAssured+ExtentReport/Allure 框架思想 框架分层解耦: 用例层，组件/业务层，API层，公共基础层 数据分类处理: 公共数据，隔离数据，运行时数据 多协议封装: 接口协议，接口定义及调用 多环境处理: 发布流，框架管理(切换、可维护性可扩展性) 结果自动验证 框架扩展: Pytest 对比策略 数据库设计: 自动化用例nodeid，请求URL，运行环境，用例路径，request_id，请求体，cURL，Response 对比引擎设计：JSONPath匹配对比策略 API覆盖率统计 分类 白盒覆盖率: 代码 灰盒覆盖率：接口 黑盒覆盖率：需求 实践 分子：结合日志，生成RequestID扩展py.</description>
    </item>
    
    <item>
      <title>程序调试</title>
      <link>https://runout.run/docs/tool/test/debug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/tool/test/debug/</guid>
      <description>分析方向 # cpu # 方法调用 调用栈时长比例 录制时间内调用栈时长 火焰图(graph frames) 宽度: 方法耗时 高度: 调用栈深 排序是按字母的，颜色是随机的 subsecond offset heat map x轴: 秒 y轴: 一秒内各阶段 z轴: 颜色深度标记events采样数 内存 # 对象 对象个数、空间比例 调用栈分配比例 线程/协程 # 泄露 I/O阻塞 锁阻塞 channel阻塞 GC问题 # 少建对象 Linux # time ftrace perf_events eBPF SystemTap LTTng ktap dtrace4linux OEL DTrace sysdig Java # VisualVM # JProfiler # # 收费, java perfino # # 监测jvm YourKit # # 收费, java, 有调用链 Spring Insight # # java spring Golang # go命令 go tool pprof Xx.</description>
    </item>
    
    <item>
      <title>软考架构师</title>
      <link>https://runout.run/docs/cache/soft_arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/cache/soft_arch/</guid>
      <description>计算机基础 # 冯诺依曼 输入、输出、存储器(中心)、运算器控制器(CPU) 硬件图 主机(运算器、控制器、主存) 存储器: 主存、辅存 I/O设备 CPU 指令: 操作码, 地址码 运算器 ALU: 算逻运算 PSW状态寄存器 ACC MQ	X 加 被加数、和	加数 减	被减数、差	减数 乘	乘积高位	乘数、乘积低位	被乘数 除	被除数、余数	商	除数 控制器 CU: 控制单元 时序部件: 时钟控制 ID: 指令译码器 IR: 指令寄存器,即将执行的指令,查MAR PC: 程序计数器,下条指令地址 存储体 MAR: 地址寄存器, 现在集成到了CPU MDR: 数据寄存器, 指令存到IR 主存 存储单元: 存1字节, 唯一地址用16进制数表示 总线 地址总线: 长度表示n位二进制数地址数 数据总线: 长度表示一次处理多少位，叫作1个字的长度 存储器 分类 位置 内存(主存) 外存(辅存) 材料 半导体 静态: 双稳态触发器 动态: 依靠电容上的电荷存储，主存 磁介质: 磁性材料的不同状态存储，外存 光: 利用光斑、晶像的变化表示信息，外存 工作方式 读/写RAM 只读 固定ROM: 用户不可写 可编程PROM: 用户写1次 可擦除可编程EPROM: 可多次编程，紫外线擦除 电擦除可编程EEPROM: 可多次编程，电擦除 闪存: 接近EEPROM 访问方式 按地址访问的 按内容访问的 寻址方式 随机RAM: 按地址访问任一单元，主存 顺序SAM: 访问时按顺序查找目标地址，磁带 直接DAM: 按照数据块所在位置访问，磁盘 相联：按照内容进行访问，Cache 校验码 类别 奇偶校验码 只能发现奇数个位出错 海明码 奇偶校验、分组校验 n为数据位个数，求校验位个数k: 2^k &amp;gt;= n+k+1 CRC循环冗余校验码 码距: 任意两个码字的最小距离 检测出e个误码，要求码距d&amp;gt;=e+1 纠正t个误码，要求码距d&amp;gt;=2t+1 指令 指令周期 执行 顺序执行 重叠执行 流水线 建立时间: 第一条指令执行完毕时间 流水线周期: 部件(取指、分析、执行)执行时间最长的一段 全部执行完时间 理论公式: (t1+t2+.</description>
    </item>
    
    <item>
      <title>这些年我做过的技术</title>
      <link>https://runout.run/docs/architect/summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runout.run/docs/architect/summary/</guid>
      <description>13年毕业以来，做技术有9年了。加上大学4年学计算机，已经13年的时间做技术了。虽然没什么成就，但也想学别人写出来看一看，起码也为自己的时间做一个交代。
背景经历 # 2009年-2013年：上学幻想期。幻想的意思是，那时技术是学来玩的，大部分时间在搞Linux，安装各种多系统和发行版，配Conky, 配各种Compiz 3D桌面，安装各种攻击工具。还买了《深入Linux内核架构》、《鸟哥的Linux私房菜》、《Linux与UNIX Shell编程指南》、《算法导论》可惜最终基础没看多少，大概与牛人的差距就是从看不完这些书体现出来的。
2013年-2015年: 入门乱学期。毕业后在C++与Java中做了Java。从此书变成了Java系列，还去学了Java线下课。可能天生的好奇心体现了出来，Java工作不久就用刚流行的Node.js改造了公司的消息推送程序，又学起了新兴的WebGL与Three.js。还改用Dell的平板装了Linux来开发。可能做的东西太过于玄幻，成为了公司的架构师。
2015年-2018年: 技术学习期。可能源于对各种技术的探索，走上了全栈开发的道路，用Node.js做起了Proxy和后端，全栈体系里用MongoDB做了业务库，并在前端不断寻求Web3D的应用，还扬言计算机交互必将从一维的Command和二维的Window发展到三维的3D界面，被打脸到现在。之后做了Golang的企业微服务，自我感觉到此才算学会了负起责任,真的承担了TeamLeader的责任与架构师工作，从追求各种代码的特性和代码的优雅，转到了追求设计的优雅，并开始系统研究各种中间件。
2018年-至今: 架构探索期。此期间的职位头衔是基础服务架构师、技术专家和架构师Manager。得益于知识的全面性和折腾的各种经验，主要做了几件事。一是从0到1的基础服务平台建设，二是解决中型SaaS系统开发维护中的各种问题，三是设计各种微服务系统并给咨询方出解决方案。技术方向一个是系统设计，另一个是折腾K8S和DevOps与测试的各种问题。折腾的方向似乎升级到了战略性，IoT、AI、湖仓一体、区块链、元宇宙。然后惊奇的发现技术栈竟然挺吻合，阻碍没想象中的大，大概得益于多年用Linux工作的基础和什么都折腾一下的经历。
思维方式 # 业务经验很重要，各个行业的经验要小心全面的积累下来，甚至比技术更重要一些，因为它更贴近实用，也有更长久的不变性。 技术实现方面设计是主题，可能设计能力是评价一个工程师最主要的方面，当然前提是有写可靠代码的能力。 基础知识是演绎的关键，凡是别人说学这个有什么用的，一定要抓紧学一学。 靠工具解决问题 大型系统的提效，完善测试是关键。可能这就是所说的抓手，也是降本增效的着力点。它前边直接对应需求，后边促进运维体系和开发体系。并本身体现出系统质量。 企业知识库是核心，体现知识的结构化和历史变化，降低了沟通成本并提供了信息一致性保障。 持续关注业界解决方案，有渠道无遗漏的过重要信息，保持敏感性。 后记 # 互联网公司陷入增长瓶颈
但AI的应用发展日新月异 其实元宇宙的概念很好的统一了现在科技应用的增长点，创造了需求 当然马斯克代表的多行星发展的方向暂时与我没有关系 量子计算似乎也有了可工业化的迹象 我首先要避免的是变成修蒸汽机的人&amp;ndash;只会解决曾经的问题。其次要成为完整的人，在技术外的场景也寻求人生的意义。 </description>
    </item>
    
  </channel>
</rss>
