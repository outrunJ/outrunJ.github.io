<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>介绍 on outrun的笔记</title>
    <link>https://example.com/</link>
    <description>Recent content in 介绍 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>整理笔记到github</title>
      <link>https://example.com/posts/note/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/posts/note/</guid>
      <description>记笔记 由于从事软件行业，信息量大，所以养成了记笔记的习惯。 笔记可以按自己的格式和思路写自己需要的，也便于查看。网上的东西对自己来说比较杂乱。 自学的都记了下来了，工作上的少些。
笔记变更史 一开始用的是ubuntu论坛上推荐的一个工具，现在名字都忘了。 后来一直在用mybase，感觉不错，到现在有5年了。但有几个问题:
 linux下容易打出乱码字符。 删除文档容易出bug。 格式不太好，版本7后用了html做内容，也会有些问题。 是本地数据库，没法在线备份，也不好分享。毕竟东西都放网上比较方便。 软件是收费的。（但开发者很良心，修改下配置就可以接着用，这个&amp;rdquo;bug&amp;rdquo;他们一直不修复）  一直在考虑有道云笔记，开始时它功能不全，没有用。现在功能不错了，我又不想用了。 因为我想自己做一个，容易满足自己的想法和维护。
现在 这里是用了hugo和它的book主题，多谢它们的作者。 经过一段时间的整理，今天这个笔记可以用了，其它细节用到时再调整。</description>
    </item>
    
    <item>
      <title>博客原则</title>
      <link>https://example.com/posts/first/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/posts/first/</guid>
      <description> 博客原则  做有意义的分享  </description>
    </item>
    
    <item>
      <title>LinuxTool</title>
      <link>https://example.com/docs/ops/linux_tool/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      
      <guid>https://example.com/docs/ops/linux_tool/</guid>
      <description>内核 modprobe vboxdrv # 内核 lsmod # 显示当前系统加载的模块，如systemctl中start了的模块 sysdig sysdig -c topprocs_cpu # 进程cpu top evt.cpu=0 # 只统计cpu0 topprocs_net # 进程带宽 top topprocs_file # 进程硬盘i/o top topfiles_bytes # 文件读写 top proc.name=httpd # 指定进程名 topfiles_time # 文件时间 top topprocs_errors # 进程error top topfiles_errors # 文件error top topscalls_time # 系统调用时间 top topscalls &amp;quot;evt.failed=true&amp;quot; # 系统调用出错 top topconns # 网络连接 top fdcount_by proc.name &amp;quot;fd.type=file&amp;quot; # 进程文件描述符 fdbytes_by fd.directory &amp;quot;fd.type=file&amp;quot; # 目录读写 top fd.</description>
    </item>
    
    <item>
      <title>Eclipse</title>
      <link>https://example.com/docs/tool/eclipse/</link>
      <pubDate>Thu, 11 Oct 2018 18:33:08 +0800</pubDate>
      
      <guid>https://example.com/docs/tool/eclipse/</guid>
      <description>方案 user library发布 项目右键 -&amp;gt; properties -&amp;gt; Deployment Assembly -&amp;gt; add -&amp;gt; javaBuild Path Entries中选择发布包 tomcat设置发布到外部 new server -&amp;gt; 直接finish 右键server -&amp;gt; open 修改server location -&amp;gt; use Tomcat installation 修改server location -&amp;gt; deploy path为webapps 修改TimeOuts -&amp;gt;所有时间为1200 java版本 window -&amp;gt; preferences -&amp;gt; java -&amp;gt; compiler window -&amp;gt; preferences -&amp;gt; java -&amp;gt; installed JREs 编码 general -&amp;gt; workspace Text file encoding general -&amp;gt; content types Text -&amp;gt; java source file defalt encoding输入UTF-8并点击update 快捷键 general -&amp;gt; editors -&amp;gt; keys content assist # 代码提示 word comletion # 代码补全  插件 market place http://www.</description>
    </item>
    
    <item>
      <title>VIM</title>
      <link>https://example.com/docs/tool/vim/</link>
      <pubDate>Thu, 11 Oct 2018 18:31:16 +0800</pubDate>
      
      <guid>https://example.com/docs/tool/vim/</guid>
      <description>编译 --with-features=tiny # 只包含最基本功能。small, normal, big, huge # :h feature-list查看  命令 vim -u NONE -N # -u NONE 不加载配置文件和插件，并进入vi兼容模式, -N set nocompatible，不进入vi兼容模式 # -u code/essential.vim 加载指定配置文件 --version # 可查看特性  mode 普通模式 插入模式 可视模式 v/V # 面向字/面向行 可视模式 &amp;lt;C - v&amp;gt; # 面向块 可视模式 gv # 重选上次选区 o # 切换到选区的开头, 再按切换回尾端　替换模式 R 命令行模式(Ex命令) : # 可视模式中选定范围，切换到命令行时，自动输入range&#39;&amp;lt;,&#39;&amp;gt;代表选中区 操作符待决模式 # operator 与 motion之间的空闲时期 # 两个字符的operator, 字符间的空闲时期不是该模式，是命名空间，是普通模式的扩充 # 有了这个模式，能创建自定义映射项来激活或终结操作符待决模式，就可以自定义operator和motion 选择模式 # 类似windows中选中 &amp;lt;C - g&amp;gt;在可视和选择模式切换 历史 q: # 命令历史 q/ # 搜索历史  operate 思想 {operator}{motion} {operator}{text-objects} shortcut key ctrl + c # 同Esc motions .</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://example.com/docs/ops/docker/</link>
      <pubDate>Thu, 11 Oct 2018 18:18:21 +0800</pubDate>
      
      <guid>https://example.com/docs/ops/docker/</guid>
      <description>基础 介绍 基于linux LXC，可以实现虚拟化 优点 低成本、高利用率、充分灵活、动态调度 核心网的最终形态 镜象网站 https://hub.docker.com/ 配置 /etc/sysconfig/docker # /etc/init.d/docker.conf OPTIONS=&#39;--selinux-enabled --log-driver=journald --insecure-registry 45.55.56.16:5000 --dns 8.8.8.8&#39; DOCKER_CERT_PATH=/etc/docker  命令 docker -h search mysql pull centos:7 centos:latest outrun11/test:nginx1 images centos # 本地镜象列表 rmi centos:latest # 删除镜象 run # 在新容器中运行命令 # -t 伪tty, -i 交互的 # -rm=true执行完后删除 # -v /etc/:/opt/etc/ 挂载本机/etc到容器/opt/etc, /etc/:/opt/etc/:ro 只读挂载, /etc/ 对外共享/etc # -p 1234:80 端口映射本机1234端口到容器80 # --volumes-from etc_share 使用另一个容器对外共享的磁盘 # -d 后台运行 # --link redis_server:redis 连接容器的redis命令 # -w /var/node 当前工作目录 # -e NODE_ENV=&#39;&#39; 环境变量 --name nsqd -p 4150:4150 nsqio/nsq /nsqd # 端口 -t -i centos /bin/bash # 启动容器, 执行bash b15 /bin/echo &#39;hello&#39; # 启动容器 --rm=true -i -t --name=ls-volume -v /etc/:/opt/etc/ centos ls /opt/etc # 创建共享 -i -t -p 1337:1337 --name=etc_share -v /etc/ centos mkdir /etc/my_share &amp;amp;&amp;amp; /bin/sh -c &amp;quot;while true; do echo hello; sleep 1; done&amp;quot; # 持续运行 --rm=true -i -t --volumes-from etc_share --name=ls_etc centos ls /etc # 使用共享 start 026 # 启动已建立的容器, id可以只输入前几位 cp 026e:/docker/file /local/file restart 026e kill 026e ps -a # 容器列表 rm # 移除容器 docker rm docker ps -aq # 移除所有未运行的容器 rm -f 026 login build -t=&amp;quot;nginx/test&amp;quot; .</description>
    </item>
    
    <item>
      <title>Mongodb</title>
      <link>https://example.com/docs/db/mongodb/</link>
      <pubDate>Thu, 11 Oct 2018 16:00:15 +0800</pubDate>
      
      <guid>https://example.com/docs/db/mongodb/</guid>
      <description>特点  数据结构json(bson) 易写入，易修改 c++编写 分布式 介于关系数据库 和 非关系数据库之间 查询语句强 支持索引 bson格式  注意  document不能大于4Mb 可以非安全模式异步马上成功 每个连接用队列存储命令  数据结构定义  collection # 表 document # 记录 field(key, value) # 字段(field)与值(value) 与关系型数据库的区别 document中的field不要key俱全或一样 find()命令查询  bson的数据类型  ＃bson 是json的扩展 # 增加了数据类型 # 把json数据转换成二进制码存到文件 null boolean undefined 数组 # 如{gps: [20, 56]} 32位和64位整数 # shell中不支持 ## node.js python java等高级语言的驱动中支持 64位浮点 # shell使用的全是这种类型, 如{x:3.14} utf-8 # 字符串类型 ObjectID Date # 如{x:new Date()} 正则 # 如{x:/uspcat/i} javascript块代码 # 如{x:function(){}} ## 相当于存储过程 内嵌文档 # 如{x: {xx: &amp;quot;a&amp;quot;}} 二进制 # shell中不能使用  ObjectId  大小 12字节 显示为24个十六进制字符 # 空间换时间的思想 细节 前4字节是unix时间戳 后3字节集群machine hash 后2字节pid 后3字节inc自增计数器, 在前面都相等时全局自增  命名  数据库与集合名 不能是空字符串 特殊字符 &#39; (空格) , $ / \ \0 应该全小写 小于64字节 数据库名不与保留库名相同，如 admin, local, config 集合名 db-text合法，但不能db.</description>
    </item>
    
    <item>
      <title>Postgre SQL</title>
      <link>https://example.com/docs/db/postgre_sql/</link>
      <pubDate>Thu, 11 Oct 2018 15:34:29 +0800</pubDate>
      
      <guid>https://example.com/docs/db/postgre_sql/</guid>
      <description>命令 initdb --locale en_US.UTF-8 -D &#39;data&#39; postgres -D data # -p 6543 pg_ctl -D data -l a.log start postmaster # -D /data psql -d postgres # 默认创建的数据库，用户名为当前用户名 ＃ -h localhost -p 5432 -d dbname 用户名 密码 # -f 导入sql命令文件, 或者在末尾加 &amp;lt; a.sql 来导入 # -L 导出日志文件 pg_dump -f a.sql -i -C -E UTF8 -n public -h localhost # 导出数据库 # -a 导出某表 createdb # -hlocalhost -Upostgres -O 用户名 数据库名 # 创建数据库并指定 owner dropdb # -U user dbname 元命令 \?</description>
    </item>
    
    <item>
      <title>Nodejs</title>
      <link>https://example.com/docs/architecture/nodejs/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      
      <guid>https://example.com/docs/architecture/nodejs/</guid>
      <description>基础 特点 commonJS规范 javascript书写(v8引擎) js设计之初就可以运行在后端 v8 成熟的事件驱动模式 没有i/o库, 没有历史包袱 v8性能好 单线程 不用在意多线程状态同步(没有死锁, 没有上下文切换) 无法利用多核, 错误时应用退出，计算密集时无法调度 # child_process解决 事件驱动(event-driven), 回调 event loop [while(true)] -&amp;gt; watcher -&amp;gt; handles watcher产生事件后, event loop取到并执行其handle(回调函数) event loop每一周询问多个watcher是否有事件 event loop中没有watcher时进程退出 http模块就是启动了一个watcher,所以执行后进程不结束 其它watcher有 timer, fs, udp/req, process 不同操作系统中event driven的实现: windows: IOCP Linux: epoll Mac:kqueue 非阻塞io(non-blocking i/o model) io与数据处理分离（所以必须异步） 线程池结合event-driven实现 异步io go语言有协程(coroutine)而node.js没有，协程可以同步式编程 # 有第三方协程模块 promise(commonJs的规范, 其实现有whenJs, Q) # 书写难度降低 eventProxy # 朴灵 async/step commonJS 模块 var math = require(&#39;math&#39;) # 缓存优先，核心模块优先。依次找.</description>
    </item>
    
    <item>
      <title>Bootstrap</title>
      <link>https://example.com/docs/frontend/bootstrap/</link>
      <pubDate>Thu, 11 Oct 2018 09:39:11 +0800</pubDate>
      
      <guid>https://example.com/docs/frontend/bootstrap/</guid>
      <description>介绍 在jquery基础上的组件框架  移动 &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt;  css 全局 container # div, 唯一包裹容器 container-fluid # 占全部视口 栅格 # 必须放在row内 col-xs-1 # 适用于大于等于分界点的屏幕 ## 大于12的最后那个col另起一行排列 # xs &amp;lt; 768px 宽度, container 最大宽度: 自动 # sm &amp;gt;= 768px, 750px # md &amp;gt;= 992px, 970px # lg &amp;gt;= 1200px, 1170px col-md-offset-4 # 向右偏移4 col-md-pull-9 # 向后推9, 改变元素的顺序 col-md-push-3 o-&amp;gt; mixin make-row 如 .wrapper {.make-row();} make-xs-column make-sm-column-offset make-sm-column-push make-sm-column-pull  样式 muted # 文本颜色 text-warning text-error text-info text-success text-left # 文本左对齐 text-center text-right text-justify text-nowrap text-lowercase text-uppercase text-capitalize bg-primary # p bg-success bg-info bg-warning bg-danger success # 状态类 # table行颜色, control-group div error danger warning info active has-warning # div元素 # 适用class: control-label, form-control, help-block has-error has-success has-feedback # div, pull-right # 任意元素向右浮动 pull-left navbar-right # 导航条中向右浮动 navbar-left clearfix # 清除浮动 initialism # 缩略语样式, abbr标签 small # small标签的样式 lead # p标签，突出显示 blockquote-reverse # blockquote标签使用, 内容右对齐 disabled # btn, input, 只disable样式 o-&amp;gt; 适用的class radio radio-inline checkbox checkbox-inline o-&amp;gt; 适用的标签 fieldset inline # 行内ul, checkbox center-block # 任意元素, 水平居中 show # 任意元素显示 hidden .</description>
    </item>
    
    <item>
      <title>Threejs</title>
      <link>https://example.com/docs/frontend/threejs/</link>
      <pubDate>Thu, 11 Oct 2018 07:58:16 +0800</pubDate>
      
      <guid>https://example.com/docs/frontend/threejs/</guid>
      <description>介绍 协调程序加载项的类库  使用 var preload = new createjs.LoadQueue(false, &amp;quot;assets/&amp;quot;); var plugin= { getPreloadHandlers: function(){ return{ types: [&amp;quot;image&amp;quot;], callback: function(src){ var id = src.toLowerCase().split(&amp;quot;/&amp;quot;).pop().split(&amp;quot;.&amp;quot;)[0]; var img = document.getElementById(id); return {tag: img}; } } } } preload.installPlugin(plugin); preload.loadManifest([ &amp;quot;Autumn.png&amp;quot;, &amp;quot;BlueBird.png&amp;quot;, &amp;quot;Nepal.jpg&amp;quot;, &amp;quot;Texas.jpg&amp;quot; ]);  api 涉及dom 属性 window.innerWidth window.innerHeight 事件 window.addEventListener(&#39;resize&#39;, onWindowResize, false); function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); controls.handleResize(); } 三大组件 场景(scene) var scene = new THREE.</description>
    </item>
    
    <item>
      <title>Angular</title>
      <link>https://example.com/docs/frontend/angular/</link>
      <pubDate>Thu, 11 Oct 2018 07:47:51 +0800</pubDate>
      
      <guid>https://example.com/docs/frontend/angular/</guid>
      <description>介绍 google发布 提倡SPA(Single Page Apps), 运行快，一次加载 mvvm  特点 前端mvc 双向数据绑定 指令和语义化标签 模块化工具 依赖注入 html模板 常用工具封装，如$http $cookies $location  调试插件 Batarang  directive nested inside ng-app # 声明app名, 在最外层 ng-submit # &amp;lt;form ng-submit=&amp;quot;submit()&amp;quot;&amp;gt; ng-controller ng-repeat # $index返回当前引用的元素序号，$first, $middle, $last 返回布尔值 ng-model # 绑定当前元素的值 ng-click # angularjs中，ng-eventhandler=&amp;quot;expression&amp;quot;类的指令可以 ## 在所有浏览器中有相同的行为，angular将会屏蔽差异性 ## 不会在全局命名空间中进行操作，指定的表达式只能访问元素控制器作用域范围内的函数和数据 ng-bind ng-change &amp;lt;form ng-submit=&amp;quot;aaFunc()&amp;quot;&amp;gt; # 会阻止浏览器默认的提交操作 ng-dblclick ng-show ng-hide ng-class # 可以是类名字符串，空格分隔，可以是类名数组，可以是类名到布尔值的映射 ng-class=&amp;quot;{true: &#39;active&#39;, false: &#39;inactive&#39;}[isActive]&amp;quot; ng-class=&amp;quot;{&#39;selected&#39;: isSelected, &#39;car&#39;: isCar}&amp;quot; ng-style # templete中写css不好维护 ng-src=&amp;quot;/images/cats/{{favoriteCat}}&amp;quot; # src，href属性中简单使用templete,由于浏览器优先并行加载图片和其它内容,angular没有机会拦截到数据绑定请求，所以无法运行 ng-href ng-options # &amp;lt;select ng-model=&amp;quot;x&amp;quot; ng-options=&amp;quot;(m.</description>
    </item>
    
    <item>
      <title>Jquery</title>
      <link>https://example.com/docs/frontend/jquery/</link>
      <pubDate>Thu, 11 Oct 2018 07:34:03 +0800</pubDate>
      
      <guid>https://example.com/docs/frontend/jquery/</guid>
      <description>对象命名方式 var $a = $(&amp;quot;#inputID&amp;quot;);  选择器（选择多个时形成数组） 基本选择器 $(&amp;quot;#inputID&amp;quot;); # id选择 $(&amp;quot;input&amp;quot;); // 标签名,默认获取第一个 # 标签名选择 $(&amp;quot;.className&amp;quot;); // 按样式名定位 # 样式名选择 $(&amp;quot;#div1ID,.myClass,p&amp;quot;); # 选择多个 $(&amp;quot;*&amp;quot;); # 所有元素 层级选择器 $(&amp;quot;form input&amp;quot;) # form所有后代元素中input元素的个数 $(&amp;quot;form&amp;gt;input&amp;quot;) # form子元素中input元素个数，不包括下层元素 $(&amp;quot;form+input&amp;quot;) # form同级并且下面的第一个input元素 $(&amp;quot;form~input&amp;quot;) # form同级并且下面的所有input元素 子元素选择器 # 只选择一个 $(&amp;quot;ul li:first&amp;quot;) # ul中第一个子元素li $(&amp;quot;ul li:last&amp;quot;) # ul中最后一个子元素li $(&amp;quot;input:not(:checked)&amp;quot;) # input标签中所有未选中的元素 $(&amp;quot;table tr:even&amp;quot;) # 表格的奇数行（索引号为偶数） $(&amp;quot;table tr:odd&amp;quot;) # 表格的偶数行（索引号为奇数） $(&amp;quot;table tr:eq(1)&amp;quot;) # table中索引号等于1的行 $(&amp;quot;table tr:gt(0)&amp;quot;) # table中索引号大于0的行（不包括0） $(&amp;quot;table tr:lt(2)&amp;quot;) # table中索引号小于2的行（不包括2） $(&amp;quot;:header&amp;quot;) # 匹配如 h1, h2, h3之类的标题元素 内容选择器 $(&amp;quot;div:contains(&#39;Join&#39;)&amp;quot;) # div 标签的html()中包含&#39;Join&#39;字符串的元素 $(&amp;quot;p:empty&amp;quot;) # p 标签的html()的内容为空的元素 $(&amp;quot;div:has(p)&amp;quot;) # div标签中包含p标签的该div标签 $(&amp;quot;p:parent&amp;quot;); # 非空的p标签元素，即p为父元素 可见性选择器 $(&amp;quot;tr:hidden&amp;quot;) # 查找隐藏的tr元素，如&amp;lt;tr style=&amp;quot;display:none&amp;quot;&amp;gt; &amp;lt;td&amp;gt;Value 1&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; $(&amp;quot;tr:visible&amp;quot;) # 查找可见的tr元素 属性选择器 $(&amp;quot;div[id]&amp;quot;) # 含有id属性的div元素 $(&amp;quot;input[name=&#39;newsletter&#39;]&amp;quot;) # 所有name属性是newsletter的input元素 $(&amp;quot;input[name!</description>
    </item>
    
    <item>
      <title>React</title>
      <link>https://example.com/docs/frontend/react/</link>
      <pubDate>Thu, 11 Oct 2018 07:32:08 +0800</pubDate>
      
      <guid>https://example.com/docs/frontend/react/</guid>
      <description>介绍 facebook推出的用于build user interfaces 的类库  使用 o-&amp;gt; webpack # webpack.config.js var webpack = require(&#39;webpack&#39;) module.exports = { devtool: &#39;inline-source-map&#39;, entry: [&#39;webpack/hot/dev-server&#39;, __dirname + &#39;/app/main.js&#39;], output: { path: __dirname + &#39;/build&#39;, filename: &#39;bundle.js&#39; }, module: { loaders: [ { test: /\.(js|jsx)$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, } ] }, plugins: [ new webpack.HotModuleReplacementPlugin(), new webpack.DefinePlugin({ &#39;process.env&#39;: { NODE_ENV: JSON.stringify(&#39;production&#39;) } }) ], devServer: { contentBase: __dirname + &#39;/build&#39;, historyApiFallback: true, inline: true, port: 3031, } } # index.</description>
    </item>
    
    <item>
      <title>Infomation</title>
      <link>https://example.com/docs/infomation/</link>
      <pubDate>Wed, 10 Oct 2018 20:56:27 +0800</pubDate>
      
      <guid>https://example.com/docs/infomation/</guid>
      <description>工具 http://lpaste.net/ # 粘代码 https://pastee.org/ # 粘贴代码 http://editor.method.ac/ # 在线ps https://www.processon.com/ # 在线思维导图, uml等 https://www.gliffy.com/go/html5/launch # 在线画图 etherpad.org # 在线协作无缝编辑 www.webpagetest.org # web test http://www.lmgtfy.com/?q=Linux#seen # let me google this for you http://tool.lu/coderunner/ # 在线repl http://bird.so # 程序信息搜索 zeplin # 设计和前端协同工具  更新学习 大前端 http://a.haskellcn.org/study # haskell书目录 liaoxuefeng # 廖雪峰blog http://blogjava.net/ # blog java https://github.com/alsotang/node-lessons # alsotang blog http://www.yinwang.org/ https://yinwang0.wordpress.com/ # 王垠 http://tech.meituan.com/ # 美团tech http://harttle.com/ # harttle博客 http://learningwebgl.com/ # webgl 基础 http://www.</description>
    </item>
    
    <item>
      <title>English</title>
      <link>https://example.com/docs/english/</link>
      <pubDate>Wed, 10 Oct 2018 20:53:25 +0800</pubDate>
      
      <guid>https://example.com/docs/english/</guid>
      <description>发音 spelling and numbers Acronym ibM, miT, ph.D mbA lA iQ revP ciA fbI coD soS xyZ Spelling boX cooK wiLsoN sentence stress with descriptive phrases It&#39;s SHORT. It&#39;s a short NAIL It&#39;s CHOCOLATE. It&#39;s a chocolate CAKE. contrasting description and a set phrase It&#39;s a short NAIL. It&#39;s a FINGERnail It&#39;s a chocolate CAKE. It&#39;s a PANcake T,D,S or Z + Y T + Y = CH what&#39;s your name can&#39;t you do it?</description>
    </item>
    
    <item>
      <title>管理</title>
      <link>https://example.com/docs/management/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/management/</guid>
      <description> 战略 ai 云 本质 批发转零售 帮助别人成功而成功 产品型转服务型 优势 轻，方便 全 可计算 现象 外包被淘汰 行业 OS of business 功能 产品功能，样板 开发体验，文档 组件收费，容量收费，节省的成本收费 数据直接做决策 分类 service # 基础服务 plugins # 基础服务组合 app # plugins组合 产品 开箱即用，做瑞士军刀不做零件 矛盾 强大，易用 小客户无付费能力，大客户要求多 行业分类 垂直，水平  上级 态度 把握分寸 靠谱(事事有交代) 领导利益着想(购买能力和时间的客户) 负责(顾全局) 分忧 超出预期 提问题与建设性意见(提选择题) 只交“产品” 背景清晰 扼要 完整 引入独有经验 沟通 主动、及时、规律 update 问题和需求 重要性(紧迫感) 变化 下一个工作重点 下一个沟通节点  架构师 职责 权衡需求与资源(人、时间), 提出大家认可的方案 素养 深入一线(面对客户) 思考全面 人 owner 自我驱动，持续改进 告警及时响应 出问题，写相关文档 砸需求，看弹性 小精英团队，智能解决问题 沟通 文档 &amp;gt; 邮件 &amp;gt; im &amp;gt; 电话 # 即时性相反 方法 划分项目边界 想清楚再行动，行动也会顺畅 拆分 分界 正交 技术 kiss # 有生命力，简单却不容易 设计清晰 选型简单 代码精炼 抽象优雅 任务 任务列表: 难度, 优先级, 排期, 地平线目标, 现状, wishlist nice to have给新人 工程 找瓶颈  团队 负责态度 提高团队效率，而非自己效率 # 严肃判断 存在合理性 有目标，成员能力认可，成员感性认可 分配事 因特质分配，如稳定，峰值，沟通 成果评价 产出判断 分配利益和荣耀 团队提升 培训无意义，自觉成长 成员 项目经理 设计 开发 测试人员 运维 数据分析师 技术总监 架构师  人 成分 技能，素质，精神 行动 感性，理性，惯性 优点，缺点 # 并非此长彼短，是两个维度 态度 找潜质的眼光 一定特性抑制作用 创造力，纪律 勤奋，聪明 稳定，峰值 深度，速度 细节，大局 发展 上限 下限 成本 低成本召回  事 知原理 是什么，为什么，怎么样，拆解 事与团队 事造就团队，好团队不一定出好成果  招聘 能力 真诚, 主动 表达 快 重点 沟通 双方 逻辑能力，写代码能力 分析/解决问题 设计 时间/流程意识  工程 历史 程序设计阶段1946-1955 节省空间 软件设计阶段1956-1970 硬件发展，软件危机 软件工程阶段1970-今 组件化 迭代 迭代周期 一个迭代周期中不新添加需求 一个迭代周期中包含多次迭代 一个阶段的结束称之为里程碑 初始化阶段增量 项目启动 建立业务模型 定义业务问题域 找出主要风险因素 定义项目需求的外延 创建业务问题域的相关说明文档 细代阶段增量 高层的分析与设计 建立项目的基础框架 监督主要的风险因素 制订达成项目目标的创建计划 构建阶段增量 代码及功能的实现 移交阶段增量 向用户发布产品 beta测试(alpha测试是内部测试， beta测试是用户测试) 执行性能调优，用户培训和接收测试 瀑布模型 #每一次执行工作流的深度不同 # 80/20原则 可行性分析 实现会不会复杂，尽量简单 需求分析 分类 生存点 痒点 兴奋点 # 不会按时交付（只完成主要，然后延期，用户测试） 客户沟通，同类产品比较，行业标准 功能 正确, 可行, 必要, 有序, 明确, 一致 性能 完善, 简短 分析 设计 先出成果再优化 任务分配(进度条) 命名标准 文档 可移植、可维护易扩展 排期 实现 测试 运维 螺旋模型（模块化） # 边分析边开发边交付（一环一环向目标实现） 主要问题 人员流动 代码维护  </description>
    </item>
    
    <item>
      <title>设计-代码</title>
      <link>https://example.com/docs/design/code/</link>
      <pubDate>Wed, 10 Oct 2018 17:40:53 +0800</pubDate>
      
      <guid>https://example.com/docs/design/code/</guid>
      <description>思想 原则 替换 子类继承超类的所有 单一职则 一个类负责一个功能 开闭 对扩展开放，对修改关闭，如接口 最小功能隔离 顺序依赖 低层依赖高层，具体依赖抽象 非侵入 # non-intrusion 将功能推入代码，而非代码拿到功能 代码实现接口，而非继承类 创建 factory, abstract factory # 工厂 builder # 构建者 prototype # 原型复制来产生对象 singleton # 单例 结构 adapter # 适配器 bridge # 抽象与实现分离 composite # 抽取公共行为 decorator # 装饰 facade # 外观。提供子类的默认视图 flyweight # 享元 proxy # 代理 行为 interpreter # 解释器 template method # 模板方法、泛型 chain of responsibility # 责任链 command # 命令 iterator # 迭代器 mediator # 消息传递中介 memento # 保存、恢复状态 observer # 观察者 state # 不同状态定义不同行为 strategy # 同行为的不同算法、替换算法 visitor # 访问者。抽象行为本身，不同访问对象不同行为 并发的世界，并发的软件 分布式的世界，分布式的软件 不可预测的世界，容错性强的软件 复杂的世界，简单的软件  面向对向 # Object Oriented 接口 一定要实现所有方法 接口可以实现多重继承 抽象类 抽象类可以有私有方法或私有变量 可以只实现部分方法 ooad # Object Oriented Analysis and Design ooa # analysis 建立针对业务问题域的清晰视图 列出核心任务 针对问题域建立公共词汇表 列出针对问题域的最佳解决方案 ood # design 细化类关系，明确可见性 增加属性 分配职责(方法) 消息驱动系统中消息传递方式 局部应用设计模式 类图时序图 oop # program 抽象: abstract 封装: encapsulation # 数据和方法绑定 继承: inheritance 多态: polymorphism overload为编译时 override为运行时 关联: association # has a 双向关联 两个类互相知道对方公共属性和操作 单向关联（大多数） 一个类知道另一个类的公共属性和操作 聚合: aggregation a包含b, b可以不在a创建时创建 组合: composition 比聚合强，a包含b, b在a创建时创建 内聚与耦合: cohesion &amp;amp; coupling # 高内聚低耦合 依赖: dependency # use a 泛化: generalization # is a  单例 单例模式 单例模式确保某个类只有一个实例，自行实例化并向整个系统提供这个实例。 # 大多有资源管理器的功能 # java反射机制会使所有单例失效：私有构造方法可以被访问 如 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 例子 public class Singleton{ private static Singleton uniqueInstance = null; private Singleton(){} public static Singleton getInstance(){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 几种单例 o-&amp;gt; 饿汉式，类初始化时实例化 public class Singleton1 { // 私有的默认构造子 private Singleton1() {} // 已经自行实例化 ，final private static final Singleton1 single = new Singleton1(); // 静态工厂方法 public static Singleton1 getInstance() { return single; } } o-&amp;gt; 懒汉式，第一次调用时实例化 public class Singleton2 { // 私有的默认构造子 private Singleton2() {} // 注意，这里没有final private static Singleton2 single=null; // 静态工厂方法 public synchronized static Singleton2 getInstance() { if (single == null) { single = new Singleton2(); } return single; } } o-&amp;gt; 双重锁,解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug # 避免bug就直接创建static属性，或get方法修饰synchronized public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ // 两线程并行到此，一个block synchronized(Singleton.</description>
    </item>
    
    <item>
      <title>设计-工程</title>
      <link>https://example.com/docs/design/project/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      
      <guid>https://example.com/docs/design/project/</guid>
      <description>思想 设计 墨菲定律 事情不是表面看起来那么简单 事情都会比预计时间长 可能出错总会出错 如果你担心发生，它更可能发生 二八定律 系统划分与组织划分 康威定律 系统架构是公司组织架构的反映 按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本 沟通出现问题，考虑调整组织架构 在该拆分时拆分 角度决定设计 如对cache的设计 业务角度 选择简单易用的缓存框架 有人会用，学习成本别太高 关注数据模型结构设计 缓存更新真麻烦 paas角度 声明式使用，配置文件设置 缓存对比，选择强大且稳定的 存取接口设计，方便易用 数据变动监听，自动刷新缓存 平台角度 缓存服务器集群方式 存储空间监控 命中率监控 避免缓存集中失效引起雪崩 考虑因素 高并发、高可用、高可靠 容量规划(流量、容量) SLA制定(吞吐量、响应时间、可用性、降级方案) 压测方案(线下、线上) 监控报警(机器负载、响应时间、可用率) tracing 应急预案(容灾、降级、限流、隔离、切流量、可回滚)  业务设计 不过度设计 # 不超出需求，不用复杂方式实现 # 少就是多，应一减再减。简单才能强大，也会提高性能和扩展性 范围减少 # 28原则，最小可行产品 设计减少 # 易理解，低成本，可扩展 实施减少 # 找开源-&amp;gt;找内部已实现-&amp;gt;找方案描述-&amp;gt;自己解决 维护 设计时考虑扩展性 DID(设计20倍, 实现3-20倍, 部署1.5-3倍) 设计能够监控的应用 版本升降 # 代码仓库 业务 防重 # 重复提交，重复扣减，重复支付(异构系统无法防重，用退款处理) 防重key, 防重表 幂等 # 消息处理，第三方支付回调 流程要抽象 # 如工作流 状态与状态机 订单系统 # 状态多时用状态机驱动 正向状态(待付款、待发货、已发货、完成) 逆向状态(取消、退款) 状态轨迹 # 跟踪和记日志，可回溯 并发修改，状态变更有序，状态变更消息有序 前端 减少dns查找 # dns可能查多个域 减少对象 # 页面布局少，图片合并。对象不要过大，减少到浏览器并发连接数 后台系统操作可反馈 # 便于确认效果 文档和注释 设计架构 设计思想 数据字典/业务流程 现有问题  高并发原则 无状态 # 应用无状态，配置有状态 尽可能浏览器端维护会话 分布式缓存放状态 拆分 # 加法组合，乘法功能 # 项目死于1到10，或10到100，因为解耦不够，无法重构 业务拆分 功能细分 读写 # 读缓存，写分库分表，聚合数据 AOP # 如CDN 模块 # 代码特征，如基础模块分库分表，数据库连接池 扩展 服务化发展 进程内服务 单机远程服务 集群手动注册服务(nginx负载多实例) 自动注册和发现服务(zookeeper) 服务分组/隔离/路由 服务治理(限流/黑白名单) AKF扩展立方 x轴 横向复制 # 复制服务或db, 瓶颈：内存缓存、特有数据 y轴 面向功能、服务、资源拆分 # 微服务 动词拆分 # 登录、搜索、推荐等 名词拆分 # 目录、库存、账户等 z轴 拆相近东西 # 数据分片(大小客户、地区、新旧等) 横向扩展 # 复制服务或数据分散负载，纵向扩展是升级设备 使用经济型系统 扩展数据中心 # 三实时站点备份: a(0.</description>
    </item>
    
    <item>
      <title>构架-方案</title>
      <link>https://example.com/docs/architecture/solution/</link>
      <pubDate>Wed, 10 Oct 2018 16:49:27 +0800</pubDate>
      
      <guid>https://example.com/docs/architecture/solution/</guid>
      <description>微服务 o-&amp;gt; 数据 租户 用户 micro service 每个service监控 每个service不单点 单功能拆分，边界明确 service间只依赖sdk(好莱坞法则)，通过服务总线发现 servcie无状态接入 分类 内部服务 internal # 内外服务用互相转化 文件上传 图像处理 数据挖掘 报表 外部服务 external # 流控、质量监控、多链路备用、降级方案 邮件 短信 推送 cti 企业信息校验 业务服务 transaction 审批流 工作流 登录 海 核心服务 core 租户id服务 检索服务 报表服务 监控服务 k8s 服务总线 支持服务 supportive 文档 测试环境 沙盒同步 插件服务 plugin 集成服务 integration 事务服务 finance CPQ ERP saas基础 计费 用户管理 联动 导入企业数据 调用aws或aliyun，提供webhook 服务的sdk 多语言sdk 降级 ha apm 服务监控 # 用于发现问题、追查事故、评估缩容或扩容、评估降级 日志 接口 # 调用服务提供的监控接口 系统 # 容器提供 apm # 客户端采样 可达性 # 由通用监控完成 工程 打包docker镜像 服务升级 灰度发布与AB test 提供api版本接口供客户端查询 服务总线 管理服务状态、位置 o-&amp;gt; 《一个可供中小团队参考的微服务架构技术栈》  aPaaS # platform as a service，介于IaaS和SaaS中间 将软件研发的平台做为服务，以SaaS的模式交付 组件化支撑和驱动 # 组件的发展决定paas广度，组件的聚合决定paas深度 # 对内固守组件边界，对外暴露标准接口 分层 平台组件 基础业务 # 不可见，影响全局，通用业务逻辑，对性能很敏感 业务 组件 设计 # 自描述的，这样就在设计和开发上解耦 确定边界 定义标准接口 确定核心功能 规范异常处理 开发 # 像开发dsl一样,来评判核心逻辑和接口，抽象度高 技术评审 定义接口 # 面向接口开发，也称为BDD dubbo、grpc等 restful 接口设计 标准化 说明 服务路由 版本管理 授权管理 核心理念 # 体现在 服务、工具、模型、规范 开放 而非 封闭 合作 而非 限制 共享 而非 替代 重点关注 基础业务 组织架构和用户组 审批流 权限 通用模型 透明分布式缓存模型 分布式存储模型 分布式事务模型 效率工具 数据迁移工具 缓存配置工具  工作流 本质 状态管理 工作流重流程轻数据，业务重数据轻流程。工作流修改数据，数据触发工作流 分层 kernel # engine adapter # services  数据 数据迁移 去掉约束 排序（中断继续）  数据存储 缓存 queue + map # queue存储、限量, map查询，指向queue中元素  缓存 queue + map # queue存储、限量, map查询，指向queue中元素  实时并发 异步方案 node.</description>
    </item>
    
    <item>
      <title>架构-原理</title>
      <link>https://example.com/docs/architecture/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:25:12 +0800</pubDate>
      
      <guid>https://example.com/docs/architecture/principle/</guid>
      <description>基础 CAP定理 # 当面临分区的时候，必须在一致性和可用性之间权衡 一致性Consistency 可用性Availability 分区容错性Partition tolerance BASE # 解决CAP 基本可用(basic available) 软状态(soft state) 最终一致性(eventually consistent)  cpu 介绍 单cpu串行工作，前任务完成，后任务才开始 # 串行不适合图形处理(多点，线，面要同时乘投影矩阵) cpu把大量空间和电量分配给控制器和缓存，不能集成太多计算单元 cpu内存通过cpu总线连接, cpu总线与pci总线通过主桥(北桥)连接 # 显卡在pci总线上 ## 控制逻辑在cpu中运行, 生成渲染数据, 到内存, 再到显存显卡计算。 ### 内存到显存数据传输最花费时间。 进程: 独有内存 线程: 共享进程内存(地址空间、文件描述符) 一个进程下的轻量进程 POSIX线程api是对已有unix进程模型扩展, 与进程多方面类似 自己的信号掩码 cpu affinity(倾向在某cpu尽量长时间运行) cgroups 并行架构 位级(bit-level): 32位, 64位计算机 指令级(instruction-level) # 处理器内部并行度很高 流水线 乱序执行 猜测执行 数据级, 单指令多数据(SIMD)架构 # 图像处理 任务级(task-level) # 多处理器 # 超线程, 虽只有4个核，但可用核返回8 共享内存模型 分布式内存模型 分类 指令流的重数分类 SI(single instruction stream)单指令流 MI(multiple instruction stream)多指令流 操作数流的重数分类 SD(single data stream)单数据流 MD(multiple data stream)多数据流 SISD 串行计算机 SIMD 阵列机(多处理单元) MISD 很少 MIMD 多处理机 多计算机  进程调度 等级 高级调度(High-Level Scheduling) 作业调度, 后备作业调入内存运行 低级调度(Low-Level Scheduling) 进程调度, 就绪队列中某进程获得cpu 中级调度(Intermediate-Level Scheduling) 虚拟存储器引入, 内外存对换区进行进程对换 方式 非剥夺方式 处理机分配给某进程后一直运行下去,直到阻塞时,才分配处理机到另一个进程 剥夺方式 进程运行时,系统基于某种原则,剥夺分配给它的处理机.</description>
    </item>
    
    <item>
      <title>媒体</title>
      <link>https://example.com/docs/media/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      
      <guid>https://example.com/docs/media/</guid>
      <description>原理 硬件 CRT cathode ray tube 阴极射线管显示器 随机扫描方式 光栅扫描方式 DPU distributed processing unit 分散处理单元  标准 Core Graphics System CGI(computer graphics interface) # 与设备无关的方法，方便的直接控制图形设备 CGM(computer graphics metafile) # 设备无关的主义定义图形文件格式 GKS(graphics kernal system) # 应用程序与图形输入输出设备之间的功能接口 PHIGS(programmer&#39;s hierarchical interactive graphics system) # 为3d设计的工具库 GL(graphics library) # 广泛应用的标准图形程序库  算法 基元的显示 直线扫描转换 DDA 中点画线法 Bresenham画线 圆的扫描转换 中点画圆 Bresenham 区域填充 种子填充 多边形扫描转换 图形变换 二维图形变换 二维视见变换 三维图形变换 投影 平行正交 平行斜交 透视投影 裁剪 直线段裁剪算法 Cohen-Sutherland算法 中点分割算法 梁友栋-Barsky算法 多边形裁剪Sutherland-Hodgman算法 三维图形裁剪 梁友栋-Barsky算法 曲线和曲面 概念 插值 逼近 参数连续性 几何连续性 光顺(smoothness) Hermite插值曲线多项式 Coons曲面 Bezier曲线和曲面 B样条曲线和曲面 图形运算 交点计算 多边形表面交线计算 平面中的凸壳算法 Graham扫描 Jarvis行进 包含与重叠 凸多边形 多边形的三角剖分 形体的表示 概念 图形信息 几何信息 拓扑信息 非图形信息 颜色 亮度 质量 体积 二维 边界 拆线逼近曲线 选点 共线性 三点转角阈值 带树法 图形的四叉树表示法 三维 几何元素 点 边 环(有序有向边) 面 体 体素 一组单元实体: 长方体、圆柱体、圆锥体、球体 扫描体 代数半空间定义的形体 线框图 顶点表、边表、面表 边界表示法 实体 CSG(constructive solid geometry), 指任意复杂形体都可用的体素组合 特征表示 Brep表示 八叉树(四叉树的推广) 分形 规则分形 # 严格自相似性的分形 Von Koch算法 Julia集和Mandelbrot集 消除隐藏线和隐藏面 线面比较法消除隐藏线 浮动水平线消除曲面隐藏线 深度排序算法(优先级算法) 画家算法(深度优先级表法) z一缓冲算法(深度缓冲算法) 扫描线算法消除隐藏面 区域分割算法消除隐藏面 BSP(binary space partitioning)树算法判别物体可见性 八叉树算法消除隐藏面 光线投射算法找到可见面 # 对包含曲面(特别球面的场景效率高) 真实感 漫反射及光源照明 照明效应 漫射照明 具体光源照明的照射效应、透射效应 漫反射、镜面反射 环境光 漫反射 镜面反射与Phong模型 光的衰减 多边形网的明暗处理 常数明暗法 亮度插值明暗法(Gouraund着色) 法向量插值明暗法(Phong着色) 阴影 纹理(texture) 整体光 透射光亮度模拟 Whitted光照模型(以Phong为基础) 光线跟踪 # 适用光滑表面 包围盒 空间分割成网格单元 辐射度方法 # 描述封闭环境中的能量交换 # 可模拟彩色渗透现象 色彩模型 颜色 色彩(Hue) 色饱和度(Saturation) 明度(Brightness) CIE(国际照明委员会)色度图(红绿蓝) 混合系统 面向硬件 RGB 红绿蓝加色系统 CMY 青、品红、黄着色系统 彩色印刷、胶卷等非发光显示体中采用 面向用户 HSV(Hue, saturation, value) # 六棱锥模型 # 可与RGB空间互相转化 HLS(Hue, lightness, saturation)双六棱锥模型  2d 分形 介绍 Fractal 具有自相似性质的多个形状 大的部分由小的部分组成，小的部分像大的部分 用递归算法模拟 Mandelbrot Set 介绍 分形领域最著名的科学家 本华.</description>
    </item>
    
    <item>
      <title>程序语言原理</title>
      <link>https://example.com/docs/pl/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/principle/</guid>
      <description>语言 注意 比较语言，共通处(抽象的元知识)是要点 在历史上判断设计者意图 # 利于了解知道的根基 不同规则，只在特点语言中合理 # 如0在ruby为真 历史 EDSAC # 1949，纸带 FORTRAN # 1954, 中缀表达式, 运算符优先级、结合性 FORTH # 1958, 没有语法，后缀表达式，语法树 LISP # 1958, 括号，前缀表达式，语法树 语法 引入优先级和左右结合 规则不冲突是困难的 vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; # c++的语法缺陷, &amp;gt;&amp;gt;是位运算，必须加空格 结构化 # 60年代 if # 汇编是判断再向后跳代码, if使可读性好 while # 可读了反复执行的if for # 可读了数值渐增的while foreach # 可读了集合遍历 函数 作用 便于理解 # 组织划分部门 便于再利用 # 再利用无代码成本 用了跳转命令和返回命令 # 从记录函数前后地址到函数记录返回地址 栈记录多级调用 # 解决多级调用返回地址被覆盖问题 递归 # 处理嵌套数据结构时，代码的嵌套结构 错误处理 历史 UNIVACI # 1950, 溢出时中断(interrupt)跳转到000 COBOL # 1959, 两种类型错误，用两关键字处理 PL/I # 1964 先定义出错处理代码。编程时引入on语句goto到处理代码, 不检查返回值 可定义新错误类型, 可用signal condition主动出错 john goodenough # 1975，论文 程序员可能忘处理异常、在不正确位置处理、处理不正确类型异常 应该声明可能抛出的异常、将可能出错结构括起来的语句结构 CLU # 1975, begin .</description>
    </item>
    
    <item>
      <title>Haskell</title>
      <link>https://example.com/docs/pl/haskell/</link>
      <pubDate>Tue, 09 Oct 2018 16:54:16 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/haskell/</guid>
      <description>介绍 源于ML 标准化的、纯函数式编程语言 非限定性语义和强静态类型 作为其他语言设计新功能时的样板，如Python的lambda标记语句  工具 检索函数用http://www.Haskell.org/hoogle  单词 polymorphism # 多态 monomorphic # 单态  风格 point free style sum&#39; xs = foldl (+) 0 xs sum&#39; = foldl (+) 0  注意 使用缩进代替括号，但也可用括号  文件扩展名 # 文件中不用let定义变量, # 变量赋值两次会报错, 这意味着代码顺序不重要 hs  内置变量 pi  模块 :m Data.Char Data.Map # 加载模块 chr # chr :: Int -&amp;gt; Char ord # ord :: Char -&amp;gt; Int toUpper toLower import Data.</description>
    </item>
    
    <item>
      <title>Html</title>
      <link>https://example.com/docs/pl/markup_language/html/</link>
      <pubDate>Tue, 09 Oct 2018 16:42:05 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/markup_language/html/</guid>
      <description>事件 blur change click dblclick focus keydown keypress keyup load mousedown mousemove mouseout mouseover mouseup reset select submit unload Abort # 中断图片下载时激发 AfterPrint # 打印文档后激发 AfterUpdate # 传送完数据 BeforeCopy # 复制到剪贴板前 BeforeCut # 剪切到剪贴板前 BeforeEditFocus BeforePaste BeforePrint BeforeUnload BeforeUpdate Bounce CellChange CtextMenu Copy Cut DataAvailable DatasetChanged DatasetComplete Drag DragDrop DragEnd DragEnter DragLeave DragOver DragStart Drop Error ErrorUpdate FilterChange Finish Help LoseCapture Move Paste PropertyChange ReadyStateChange Resize RowEnter RowExit RowsDelete RowsInserted Scroll SelectStart Start Stop  标签 &amp;lt;var&amp;gt; # 标识常量 &amp;lt;samp&amp;gt; # 标识输出内容的样式 &amp;lt;pre&amp;gt; # 代码块 &amp;lt;code&amp;gt; # 一段代码  属性 全局属性 # 配置所有元素共有行为 accesskey # 快捷键 ## 需要按alt + 指定的键 class contenteditable # 内容是否可修改, 如p标签 contextmenu # 定义右键菜单，未实现 dir # 文字对齐方式 draggable dropzone hidden id lang spellcheck style tabindex # tab键切换元素的顺序 title  浏览器特性 视频播放 支持vaapi, chrome 加上--enable-vaapi参数可以开启硬件加速解码  方案 &amp;lt;=================================标签========================================&amp;gt; &amp;lt;input&amp;gt;表单 单选框 &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; checked value=&amp;quot;1&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; value=&amp;quot;1&amp;quot;&amp;gt; 下拉框 &amp;lt;select id=&amp;quot;mySelect&amp;quot; size=10 multiple&amp;gt; # 长度等于10 ，多选 &amp;lt;option selected=&amp;quot;selected&amp;quot;&amp;gt;Apple&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;Orange&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; 勾选框 &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;&amp;quot; /&amp;gt; 按钮 &amp;lt;input type=&amp;quot;button&amp;quot;/&amp;gt; &amp;lt;button&amp;gt; # &amp;lt;button&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;搜索&amp;lt;/button&amp;gt; button之间可以加图片 &amp;lt;table&amp;gt;表格 &amp;lt;caption&amp;gt; # 标题 &amp;lt;thead&amp;gt; &amp;lt;th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;td&amp;gt; &amp;lt;/th&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tfoot&amp;gt; 属性 &amp;lt;tr style=&amp;quot;display: none;&amp;quot;&amp;gt; # 设置属性为隐藏 &amp;lt;form&amp;gt;表单 enctype属性 application/x-www-form-urlencoded(默认) # 在发送编码所有字符（空格转换为 &amp;quot;+&amp;quot; 加号，特殊符号转换为 ASCII HEX 值） multipart/form-data # 不对字符进行编码，在上传文件时使用 text/plain # 空格转换为+，但是不对特殊字符进行编码 &amp;lt;hr&amp;gt;分割线 字体 &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; .</description>
    </item>
    
    <item>
      <title>Css</title>
      <link>https://example.com/docs/pl/css/</link>
      <pubDate>Tue, 09 Oct 2018 16:27:24 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/css/</guid>
      <description>介绍 cascading style sheet  层叠 # 浏览器对每个元素定义了默认的样式表 不同级 1. style属性 2. style标签 3. link标签 4. 浏览器中用户自定义样式表 5. 浏览器默认样式 !important color: black !important 同级 # 评估得出最特殊的样式 ## a-b-c值依次排序，a如id个数, b如其他属性个数, c如元素名个数 # 评分相同时，使用最后的 id值的数目 其它属性和伪类的数目 元素名和伪元素的数目  继承 部分元素继承父元素样式 元素外观继承 布局不继承 inherit # 指明使用父元素样式 border: inherit  css样式一共三种用法: 内联式 &amp;lt;div style=&amp;quot;color:#000;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 嵌入式 &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt; div {color:#000;} &amp;lt;/style&amp;gt; 引用式 &amp;lt;link href=&amp;quot;css.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt; @ @charset &amp;quot;UTF-8&amp;quot; # 默认UTF-8, 在import前 @import &amp;quot;styles.</description>
    </item>
    
    <item>
      <title>Elixir</title>
      <link>https://example.com/docs/pl/elixir/</link>
      <pubDate>Tue, 09 Oct 2018 16:24:04 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/elixir/</guid>
      <description>介绍 跑在erlang虚拟机上 与erlang相同，actor称作进程, 是比线程更轻量的概念  使用 o-&amp;gt; 元组 {:foo, &amp;quot;this&amp;quot;, 42} # 三元组 o-&amp;gt; actor defmodule Talker do def loop do receive do {:greet, name, age} -&amp;gt; IO.puts(&amp;quot;Hello #{name}&amp;quot;) {:shutdown} -&amp;gt; exit(:normal) end loop end end pid = spawn(&amp;amp;Talker.loop/0) send(pid, {:greet, &amp;quot;Huey&amp;quot;, 16}) sleep(1000) Process.flag(:trap_exit, true) pid = spawn_link(&amp;amp;Takler.loop/0) send(pid, {:shutdown}) receive do {:EXIT, ^pid, reason} -&amp;gt; IO.puts(&amp;quot;Talker has exited (#{reason})&amp;quot;) end o-&amp;gt; 有状态的actor # 递归 defmodule Counter do def start(count) do spawn(__MODULE__, :loop, [count]) # 伪变量__MODULE__, 是当前模块的名字 end def next(counter) do send(counter, {:next}) end def loop(count) do receive do {:next} -&amp;gt; IO.</description>
    </item>
    
    <item>
      <title>Go</title>
      <link>https://example.com/docs/pl/go/</link>
      <pubDate>Tue, 09 Oct 2018 16:10:44 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/go/</guid>
      <description>基础 特点 易工程化 简单性而不方便性，避免工程复杂性乘法增长 没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储 类型系统，无类型风格 集合直接持有元素 # 自然方式 标准库避免配置和解释 # 自带电池 项目结构简单 编译为本地机器码 编译快 强静态类型 有gc 大厂支持 并发编程特点 语言层面关键字 csp并发模型 channel为一等公民 高效调度模型(调度器，资源占用小) O(1)的调度 一进程可支撑上百万例程,5kib/goroutine的开销, 变长栈存goroutine 编译 CGO_ENABLED=0 # 静态链接，不跨平台 配置 GOROOT # go安装目录 GOPATH # 包目录 # 默认要有go的bin目录 GOBIN # 当前bin目录 GO15VENDOREXPERIMENT # 依赖目录 例程原理 流程控制: csp 通信方式: promise-future, channel, event  命令 godoc -http=:6060 # 运行本地帮助网站 go build # 编译代码包 install # 编译安装 get # 下载依赖 # 默认目录是GOPATH下的pkg -u # update -v # 查看进度 clean # 清理build产生的文件 -c # 清理.</description>
    </item>
    
    <item>
      <title>Python</title>
      <link>https://example.com/docs/pl/python/</link>
      <pubDate>Tue, 09 Oct 2018 16:05:05 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/python/</guid>
      <description>介绍 虚拟机语言 虽然是脚本语言，可以预编译成pyc文件来执行  shell #! /usr/bin/python # -*- coding: utf8 -*-  语法 规范 pep8  内置函数 o-&amp;gt; input(&amp;quot;&amp;quot;) # x = int(input(&amp;quot;Please enter an integer:&amp;quot;)) print(&amp;quot;%s&amp;quot;, % s1) ## %.3s % (&amp;quot;abcdef&amp;quot;)取3字符 ## %.* s % (2, &amp;quot;abcd&amp;quot;)取2字符) # %r repr()显示字符串 # %c 单个字符 # %b 二进制整数 # %x 十六进制整数 # %d 十进制整数 # %i 十进制整数 # %o 八进制整数 # %e %E 指数(基底分别为e E) # %-10.3f %-10.3F 浮点数 ## 10位宽, 小数精确3位, 右对齐 # %g %G 指数(e E)或浮点数(根据显示长度决定) # %% 字符% print(&amp;quot;c is %s, e is %i&amp;quot; % (c, e) str(1) int(&amp;quot;1&amp;quot;) range(1, 10) # range(-2, -11, -3) exec(&#39;&#39;) # 执行字符串中的代码 execfile(r&#39;a.</description>
    </item>
    
    <item>
      <title>Clojure</title>
      <link>https://example.com/docs/pl/clojure/</link>
      <pubDate>Tue, 09 Oct 2018 16:00:21 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/clojure/</guid>
      <description>介绍  是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程 操作符知道自己的特征值(identity value), 如+是0, *是1 数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃 集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能 # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的 没有尾递归优化，不常用递归，要用loop.recur  语法  s-expressions (max 3 5) (+ 1 (* 2 3)) (def meaning-of-life 42) (if (&amp;lt; meaning-of-life 0) &amp;quot;negative&amp;quot; &amp;quot;non-negative&amp;quot;) (def droids [&amp;quot;Huey&amp;quot; &amp;quot;Dewey&amp;quot; &amp;quot;Louie&amp;quot;]) (count droids) (droids 0) (def me {:name &amp;quot;Paul&amp;quot; :age 45 :sex :male}) (:age me) (defn percentage [x p] (* x (/ p 100.0))) (percentage 200 10)  并发 o-&amp;gt; 原子变量 # 对一个值进行同步更新 (def my-atom (atom 42)) (deref my-atom) @my-atom (swap!</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>https://example.com/docs/pl/js/</link>
      <pubDate>Tue, 09 Oct 2018 10:31:30 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/js/</guid>
      <description>基础 特性 面向对象 动态语言(已超出脚本语言的范畴) first-class function的思想来自Scheme语言 prototype-based的思想来自Self语言 机制 弱类型，变量都是var 解释器有自己的内存管理机制(garbage collection) 自由数据类型转换 # 产生了==, ===的判断相等的不同定义 commonJs规范下的javascript node.js mongoDB ringojs v8引擎 直接生成机器码 分代式GC java jvm工程师参数了优化  词法 js是unicode字符集编写的 # unicode转义如, &#39;café&#39;表示为 &#39;caf\u00e9&#39; ## &#39;é&#39; 也可以表示为&#39;e\u0301&#39;, e后面跟一个语调符 区分大小写 # html中不区分大小写, 其要调用的函数在js中一律小写 注释如//, /**/ 标识符和保留字 要求 开头以字母、下划线、dollar符。 后续可以加数字 可以出现unicode字符集中的Mn类、Mc类、Pc类，如 # Mn表示非间距字符，Mc表示影响基字符标志位的间距字符, Pc是连接两个字符的连接符或标点符号。 é, π, 保留字 break, delete, function, return, typeof, case, do, if, switch, var, catch, else, in, this, void, continue, false, instanceof, throw, while, debugger, finally, new, true, with, default, for, null, try 未被使用的名保留字 class, const, enum, export, extends, import, super 严格模式下的保留字 implements, let, private, public, yield, interface, package, protected, static 严格模式下不能用做变量名 arguments, eval es6新增保留字 await ECMAScript3将所有java关键字列为保留字 全局属性和对象和函数 自定义全局对象和函数列表  直接量 直接量(numeric literal) 1 1.</description>
    </item>
    
    <item>
      <title>Java</title>
      <link>https://example.com/docs/pl/java/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/java/</guid>
      <description>命令与工具 bin目录 javac # 编译器 java # 解释器 javadoc # 生成HTML格式的帮助文档 javadoc -d docs -sourcepath src/ -subpackages com.ryx -author jdb # java调试器 javah # 反编译成c头文件 javap # 反编译成java文件 jar # 打包工具 打包标签 把包目录和class类放到jnb目录 jnb/META-INF/tld文件添加&amp;lt;uri&amp;gt;http:# www.xxx.com&amp;lt;/uri&amp;gt; jar cvf jnb.jar * jar cvfm ul.jar manifest.mf com native2ascii # 转换为unicode编码 serialver # 返回指定类的序列化号serialverUID appletviewer # 小程序浏览器，执行HTML文件上java小程序类 htmlconverter # 转换applet tags成java plug-in javap # 反编译 jad # 反编译 jad -o -a d.java Xxx.class jmap # 查看堆内存情况, 产生dump文件 工具 MAT (Memory Analyzer) # eclipse MAT插件分析dump文件  语法 基础 面向对象 继承 封装 多态 overload 编译时多态 override 运行时多态 抽象 对象关系 has-a # 关联 use-a # 依赖 is-a # 继承 类型 基本类型 # 作为面向对象语言，为了方便引入了基本类型 boolean 1或4字节 # 没有定义类型的字节码，跟据jvm实现有时用int代替 # 据说[]boolean是1个，boolean直接用int类型是4个 byte 1个字节 short 2个字节 char 2个字节 # gbk, gb2312这种2字节编码，一个汉字存一个char。utf-8一个字用3字节 int 4个字节 long 8个字节 float 4个字节 double 8个字节 包装类型 # 不可变(immutable)类 Boolean, Byte, Short, Character, Integer, Long, Float, Double 享元 Integer i1 = 120, i2 = 120, i3 = 130, i4 = 130; i1 == i2; i3 !</description>
    </item>
    
    <item>
      <title>JavaWeb</title>
      <link>https://example.com/docs/backend/javaweb/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/backend/javaweb/</guid>
      <description>基础 分层 视图层 jsp 控制层 servlet 业务层 过滤数据 manager层 封装第三方，service能力下沉，dao中间件 数据访问层对象 封装对象 数据库 java web 13种技术 JDBC Java Database Connectivty JNDI Java Name and Directory Interface EJB Enterprise JavaBean RMI Remote Method Invoke Java IDL/CORBA JSP Java Server Pages Java Servlet XML Extensible Markup Language JMS Java Message Service JTS Java Transaction Service JTA Java Transaction Architecture JavaMail JAF JavaBeans Activation Framework  jsp 基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层 域对象 pageContext # 当前页面有效 request # 一次请求范围 session # 会话 application context # 同一服务器 内置对象 Request Response Session Out # 输出流 PageContext # context Page # jsp的this Exception # &amp;lt;%@ page isErrorPage=&amp;quot;true&amp;quot;%&amp;gt; 时使用，显示异常信息 Application # 服务器 Config # 服务器配置  jsp-el表达式 ${ } 11个内置对象 pageContext // pageContext page // map （相当于pageScope，不过写法上省略了Scope） requestScope // map sessionScope // map applicationScope // map param // map ,用${param.</description>
    </item>
    
    <item>
      <title>算法思想</title>
      <link>https://example.com/docs/algorithm/thought/</link>
      <pubDate>Mon, 08 Oct 2018 22:21:21 +0800</pubDate>
      
      <guid>https://example.com/docs/algorithm/thought/</guid>
      <description>口诀 难题首选动归 受阻贪心暴力 考虑分治思想 配合排序哈希  递归(recursion) 介绍 利用递归，把状态的管理责任推给运行时 递归转迭代 可加上memory做优化  分治(divide and conquer) 介绍 广义分治法 例子 二分检索 找最大/最小元素 归并分类 快速分类 选择问题 斯特拉森矩阵乘法  贪心(greedy) 案例 Dijkstra最短路径 最小生成树Prim, Kruskal 背包问题 作业排序 最优归并模式  动态规划(dynamic planning) 方法 常用滚动数组降低空间复杂度 案例 多段图 结点间最短路径 最优二叉检索树 0/1背包问题 可靠性设计 货郎担问题(旅行商问题) 流水线调度问题  检索与周游(retrieval/travel) 案例 深度优先检索 广度优先检索 与/或图 对策树  回溯(backtracking) 案例 8皇后问题 图的着色 哈密顿环 背包问题  暴力(brute force) 介绍 分支限界条件加快效率 例子 DFS, BFS   分支-限界(branch and bound) 案例 LC检索 0/1背包问题 货郎担问题  并行 时间复杂度(time complexity) O()表示上界(&amp;lt;=), Ω() [omega]表示下界(&amp;gt;=), Θ() [Theta] 表示上下界相同, o()表示非Θ()的O() N &amp;gt;= n0时, T(N) &amp;lt;= cf(N), 记为T(N) = O(f(N)) N &amp;gt;= n0时, T(N) &amp;gt;= cg(N), 记为T(N) = Ω(g(N)) T(N) = Θ(h(N)) 当且仅当T(N) = O(h(N)) 和 T(N) = Ω(h(N)) 上界(upper bound) 下界(lower bound) 法则 # 约定, 不存在特定的时间单位 # 约定, 机器模型中, 1.</description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://example.com/docs/algorithm/data_structure/</link>
      <pubDate>Sun, 07 Oct 2018 13:46:46 +0800</pubDate>
      
      <guid>https://example.com/docs/algorithm/data_structure/</guid>
      <description>树 概念 tree free tree(自由树)，连通无回路的图 full tree(满树)，所有节点要么是树叶，要么是两个儿子 forest(森林)，无回路但不一定连通的图 root rooted tree(有根树)，确定根的树，常简称为树 node ancestor(祖先)，顶点本身也作为自己的祖先 proper ancestor(真祖先)，除了自己的祖先 parent(父母) child(子女) sibling(兄弟) leaf(叶节点), 没有子女的顶点 parental(父节点)，至少有一个子女的顶点 descendant(子孙)，以v为祖先的所有节点，包含v proper descendant(真子孙)，不包含本身 subtree(子树) depth(深度)，从根到v简单路径的长度 height depth 树中结点的最大级数 rank(秩) # 子女数 height(高度)，从根到叶节点最长简单路径的长度 # 按树的层的数量定义时，高度增加1 degree(度，一个节点子树的数目) level(root为1级, 结点为p级时，儿子在p+1级) state-space tree(状态空间树)，可用于分析回溯和分支界限 ordered tree(有序树)，有根树的每个顶点，所有子女有序 first child-next sibling representation(先子女后兄弟表示法) # 子女数不定，父节点只存第一个子女，该子女存兄弟链表 ## 以一种高效方式将有序树改造成关联二叉树 ## 关联二叉树中，左指针表示下层，右指针表示兄弟节点 binary tree(二叉树)，属于有序树 left child(左子女) right child(右子女) 左(右)子树 # 二叉树可以递归定义，所有可以用递归算法 binary search tree(二叉查找树)，父母顶点比左子树中所有数字大，右子树中小 效率，多取决于高度 logn &amp;lt;= h &amp;lt;= n - 1 # h 为高度, n为顶点数 multiway search tree(多路查找树) B树, B+树, B-树 边 树向边 回边 前向边 # 顶点到非子孙 交叉边 # 非前三都是交叉边 性质 |E| = |V| - 1 # 树的边数总比顶点数小1 # 图变树的必要不充分条件，连通图变树的必要充分条件 任意两个顶点间总存在简单路径，任选顶点可作根  二叉树 介绍 binary tree 常用顺序表或链表存储 概念 full binary tree(满二叉树) # 满子节点，且子节点在同一层上 heap(堆) # 根向下从大到小排序 binary search tree(二分检索树) # 左子节点小于父节点小于右子节点 left child(左子女) right child(右子女) 左(右)子树 # 二叉树可以递归定义，所有可以用递归算法 complete binary tree(完全二叉树) # 只有最大层节点不满且连续集中在左边 高是logN 可以用数组实现(从index = 1开始存储) 左儿子在2i, 右儿子在2i + 1, 父亲在i / 2 perfect binary tree(理想二叉树) # 满节点二叉树 full binary tree(满二叉树) # 同理想二叉树 skewed tree(斜树) # 一个节点不断左斜是左斜树，相反为右斜树 binary search tree(二叉查找树) # 父母顶点比左子树中所有数字大，右子树中小 AVL tree(Adelson-Velskii-Landis tree) # 带有平衡条件(balance condition)的二叉查找树 平衡条件: 左右子树最多差1 # 节点中存储高度信息 splay tree(伸展树) # 分析树的一种 效率，多取决于高度 logn &amp;lt;= h &amp;lt;= n - 1 # h 为高度, n为顶点数 树转换二叉树  堆 概念 binary heap(二叉堆、堆) # 一棵完全二叉树 结构性 heap-order property(堆序性) heap-order tree(堆序树) 已证明，平均一次插入需要2.</description>
    </item>
    
    <item>
      <title>数学</title>
      <link>https://example.com/docs/algorithm/math/</link>
      <pubDate>Sun, 07 Oct 2018 12:46:46 +0800</pubDate>
      
      <guid>https://example.com/docs/algorithm/math/</guid>
      <description>指数 X^A * X^B = X^(A + B) X^A / X^B = X^(A - B) (X^A)^B = X^(A * B) X^N + X^N = 2X^N &amp;lt;&amp;gt; X^(2N) 2^N + 2^N = 2^(N + 1)  对数 约定 计算机科学中, log默认为log(2) X^A = B, log(X)(B) = A log(A)(B) = log(C)(B)/log(C)(A) logAB = logA + logB  级数 ∑(i=0)(N)2^i = 2^(N + 1) - 1 ∑(i=0)(N)A^i = (A^(N + 1) - 1) / (A - 1) 如果0 &amp;lt; A &amp;lt; 1, 则 &amp;lt;= 1 / (1 - A) ∑(i=1)(∞)i/2^i = 2 ∑(i=1)(N)i = N(N + 1) / 2 ≈ N^2 / 2 ∑(i=1)(N)i^2 = N(N + 1)(2N + 1) / 6 ≈ N^3 / 3 ∑(i=1)(N)i^k ≈ N^(k + 1) / |k + 1| k &amp;lt;&amp;gt; -1 k = -1时, Hn = ∑(i=1)(N)1 / i ≈ log(e)(N), Hn是调和级数 该近似式误差趋向于 λ ≈ 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/architecture/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/architecture/performance/</guid>
      <description>原则 qps latency through put bottle-nect(first-principle) io 磁盘 iops: 2k 网络 带宽 iops: 3w  流量 小米论坛 pv 2000w 热门并发300 20k/页面 300k/图片(未压缩) 70k/无图帖子 500k-3M/有图帖子 动态服务器最小带宽: 48Mbps 静态服务器最小带宽: 1440Mbps 实际购买带宽: 800M 带宽费用: 8.7w/month 糗事百科 pv 1000w 热门并发150 10k/页面 70k/图 4图/页 90k-400k/综合页 动态服务器带宽: 12Mbps 静态服务器带宽: 336Mbps  带宽 建议 热门并发1.5倍到2倍购买  cdn 介绍 流量不大时带宽比cdn便宜, 流量大时cdn便宜。 界限为250Mbps左右，价格在9k/month 价格 50TB/月 100TB/月 阿里云 3.8w/月 6.9w/月 盛大云 9k/月 1.7w/月 网宿 蓝汛  服务 teamwork confluence teambition basecamp jira testlink shimo dropbox trello itsm/erp # IT Service Management, 信息技术服务管理 salesforce servicenow workday # hr平台 pay 支付宝 易宝 财付通 cti 天润 云之讯 容联 report/olap palo idc # infomation data corporation 互联网数据中心 cdn 七牛 ws 阿里云 青云 digital ocean vultr aws Linode azure # 微软开放平台 gce # google compute engine txCloud # 云柜，数据存储和计算 首都在线 paas gae # google app engine sae # sina app engine heroku im 环信 云片 jpush im sms.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/backend/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/backend/elasticsearch/</guid>
      <description>介绍 分布式实时lucene  使用 ./bin/elasticsearch curl http://localhost:9200  命令 elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name  概念存储 index type # document中加_type field实现 # 所以不同type中的field在index要唯一，否则冲突 # 对field排序会载入所有type的document document # 对应lucene中的key value倒排文档 # 对就一个请求的json对象 field mapping # 定义type的field，映射json到document field  设置 config/elasticsearch.yml action.auto_create_index: -l*, +z* # 自动创建，以z开头和非l开头的索引 action.destructive_requires_name: true # 允许通配删index http.cors.enables: true http.cors.allow-origin: &amp;quot;*&amp;quot; cluster.name: c1 node.name: n1 node.master: true node.data: true transport.host: localhost transport.tcp.port: 9300 network.host: 0.0.0.0 # 修改es监听地址，别的机器也可以访问。同时设置bind_host和publish_host # 需要设置transport.host:localhost network.bind_host # 节点绑定ip network.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/backend/hibernate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/backend/hibernate/</guid>
      <description>基础 优点 完全面向对象编程思想，无sql 减少代码 控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率 hibernate具有独立性（访问层随时可以更换） 特性 不写hbm.xml映射文件，而是基于注解的验证 对象、集合、属性的延迟加载 dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常 目录 . # hibernate程序包 documentation # 文档 lib # 所有依赖包 project # 源码文件 加载顺序 后面的覆盖前面的 hibernate.properties中的配置被覆盖 # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置 hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准） 开发流程 加载配置: jdbc参数，数据库方言，hbm映射 创建SessionFactory # 内有连接池 创建session 事务处理 关闭session 关闭连接池 对象状态 𣊬时态 # 没有OID(持久化标识), 没有关联session 持久态 # 有OID, 与session关联, 事务未提交 脱管态 # 有OID, 没有关联session 缓存机制 一级缓存(session) 事务级，事务结束缓存失效 # 请求同一对象，取得同一实例 总是打开 二级缓存 SessionFactory级别，session共享 缓存散装持久化实例, 有不同缓存策略 先设置策略，再设置过期时间与cache提供器 优点 提高速度、减小压力 缓存失效时，不立即查找，而是合并sql查找 查询方式 HQL QBC(命名查询) SQL get与load get立即加载，load延时加载 get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库 # 代理对象只存id get没有时返回null, load抛异常 检索策略 # 取关联对象 立即检索 # 一次全加载, select多 延迟检索 # 访问游离状态代理类，需要在持久化状态时已被初始化 迫切左外连接检索 # 用外连接取代select，全加载  优化 数据库设计调整 HQL优化 api正确使用 配置参数 # 日志、查询缓存，fetch_size, batch_size等 映射文件优化 # id生成策略，二级缓存，延迟加载，关联优化 一级缓存管理, 二级缓存策略 事务控制策略  基本概念： o-&amp;gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题 o-&amp;gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想) DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准 它们的区别在于 hibernate中不写sql语句 ibatis中写少量sql语句 DBUtils中写sql语句 它们的另一个相同点是 底层全都是jdbc o-&amp;gt; 结构对应 javabean中的 类，对象，属性 数据库中的 表，记录，字段 o-&amp;gt; hql hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用 o-&amp;gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean  使用 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/backend/principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/backend/principle/</guid>
      <description>非阻塞 阻塞指cpu等待io 非阻塞指调用io后立即返回，但要轮询事件状态 # 非阻塞指对cpu不阻塞，但业务线程阻塞 轮询(单线程) read 定时重复调用来检查 select 前后read, 中间select轮询检查文件描述符的事件状态 采用1024长度数组存储状态，只能同时检查1024个文件描述符 poll 前后read, 中间poll 用链表代替数组, 也避免了不必要的检查 epoll # linux 前后read, 中间epoll epoll检查不到事件，休眠epoll线程直到事件将它唤醒 kqueue # freeBSD中，类似epoll aio # async io, linux, 业务线程不阻塞 通过回调(信号)传递数据，不必像epoll线程(业务线程)阻塞等待 仅linux下有, 只O_DIRECT方式读取，不能利用系统缓存 IOCP # windows aio 模拟aio(io线程池) 业务线程的io操作, 起io线程, io线程完成通信到业务线程触发回调 库 glibc(有bug) libeio node.js的libuv封装 linux下自实现 windows下IOCP  事件 实现 回调 队列存事件, 单进程检测事件是否回调 库 libevent libev # bug比libevent少 工具 epoll(select, poll) libev(libevent)  并发并行 并发 为什么: 多任务能力，非阻塞 类比: 任务队列 并行 为什么: 提高执行效率 类比: 多核处理器 cpu交替任务 # EDSAC串行任务 协作式 # 可能独占，Windows3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/backend/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/backend/spring/</guid>
      <description>基础 特点 容器, 也容纳管理了第三方框架 # 目的是解耦框架api 轻量级，模块化，无(少)侵入 IOC(inversion of control) 容器用工厂装配对象并管理, 面向接口编程 优点 降低代码量 容易测试 最小侵入性松耦合 方式 Setter 构造器 静态工厂、实例工厂 DI(dependency injection) 容器向类添加属性 # 反射，用带参构造或set方法 AOP(aspect oriented programming) # 继承是纵向组织，AOP横切入业务 # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用） 动态代理实现切入代码 权限控制 事务管理 记录日志 概念 连接点:普通方法 切入点:名称满足条件的连接点 增强（通知）类:服务对象 # 切入点与增强是多对多的 切面:切入点 + 增强类 # 我们切入的是横切面 目标对象（服务对象）：要注入的对象 通知 before # 执行前 after # 执行后 after-returning # 正常退出 after-throwing # 异常退出 around # 执行前后 代理对象(业务对象)：被注入的对象 模块 dao orm aop jee web core 结构 核心容器(core container) Core # 最底层，资源访问，类型转换 Beans # IOC, DI, BeanFactory Context # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播 EL # 表达式语言 AOP, Aspects # Aspects对AspectsJ集成, 功能多于spring asp 数据访问/集成 JDBC ORM OXM # object xml 映射 JMS # 消息与异步通信 事务 Web/Remoting Web # ioc窗口，rmi, hessian,burlap, web service Web-Servlet Web-Struts Web-Porlet # portal认证 Test 设计模式 代理 目标对象实现接口，使用Proxy 未实现接口，使用CGLIB 单例 bean默认单例 模板, 解决代码重复问题 RestTemplate, JmsTemplate, JpaTemplate 控制器 DispatherServlet对请求分发 视图帮助(view helper) 提供jsp标签、高效宏 帮助在视图中写代码 依赖注入 BeanFactory, ApplicationContext核心理念 工厂 BeanFactory 版本 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/db/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/db/mysql/</guid>
      <description>基础 端口 3306 命令 mysql --max-relay-logs-size=300 # 中继日志大小(sql语句数) --relay-log-purge={0|1} # 中继日志自动清空 --relay-log-space-limit=0 # 限制中继日志大小,0表示无限制 services.msc mysql -h 127.0.0.1 -u root -p mysqldump -uroot -p day02&amp;gt;d:/backup.sql // 备份 mysql -uroot -p day02&amp;lt;d:/backup.sql // 导入 mysqladmin -uroot -proot status # 查看当前连接数 组件 mysql enterprise monitor documentation mysql enterprise monitor connector mysql enterprise monitor service manager mysql enterprise monitor agent mysql enterprise backup mysql connector 工具 mysql database mysql cluster # 创建集群，配置复杂 mysql cluster manager # cluster帮助软件，配置简单 mysql workbench # 据库建模工具 mysql utilities # 提供一组命令行工具用于维护和管理 MySQL 服务器 连接参数 root:123456@tcp(abcdefg:3306)/meiqia?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/db/oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/db/oracle/</guid>
      <description>基础 安装 运行services.msc 找到OracleServiceORCL 服务 （最后是数据库名）改为手动 sqlplus / as sysdba 运行oracle测试是否安装成功 解锁scott用户 sqlplus / as sysdba alter user scott account unlock; alter user scott identified by tiger; 启动 OracleServiceORCL OracleOraDb11g_home1TNSListener 端口 1521 # 停了以后再开会变 权限 系统权限：创建数据库，创建用户 对象权限：表操作 sys create database权限 system 没有create database权限 scott hr 角色 # 超管以角色进入，普通用户输入用户名密码 dba dbaoperator 服务器的组成 oracle数据库 存储位置 oracle安装位置/oradata/ 每个数据库文件夹中有多个二进制文件（*.dbf） oracle实例(内存概念) 一个数据库进程可以有多个实例 一个实例可以有多个数据库进程和一个内存池(缓存) # 不同于windows进程，每个进程对应一个用户访问 服务名为OracleService数据库名 集群(多实例) 连接失败转移 负载均衡 连接类型 normal sysdba sysoper 分布式 认证 开发技术认证 Java认证 数据库开发语言SQL和PL/SQL认证 数据库技术认证 OCM【大师】 OCP【专家】 OCA【初级】 中间件技术认证 OracleServer认证，WEB服务器认证 专业领域技术认证 ERP CRM HR OA 支持的事务隔离 只支持读提交与序列化两种 版本 8i 9i 10i # i是internet 11g # 基于jdk6, g是grid网格(一个请求多个服务器运行) 12c # c是cloud SQL99标准 # 不区分大小写 PLSQL是Oracle对SQl99标准的扩展 结构代查询语言 DML select,insert,update,delete DDL create table,alter table, drop table DCL grant, revoke TCL(杜撰) commit, rollback,rollback to savepoint 加载过程 启动oracle服务 oradim -startup -sid 数据库名 # 相当于windows服务中启动该服务，会从windows注册表中加载配置 oradim -shutdown -sid orcl -shuttype srvc # 停止oracle 服务 普通登录 sqlplus system/asdf # 从注册表中查找默认的数据库名称进行登录 sqlplus system/asdf@orcl # 指定数据库名登录，必须有监听的时候该命令可以执行，监听的进程是独立于oracle之外的进程 管理员登录 sqlplus / as sysdba # windows管理员的身份进行登录，不需要用户名密码，可以在配置文件中禁用它 无连接登录 sqlplus /nolog #用来设置sql/plus 启动实例 cmd&amp;gt; sqlplus / as sysdba # 连接到数据库的空闲实例 sql&amp;gt; select status from v$instance # 查看实例状态 sql&amp;gt; shutdown abort # 立即终止当前的实例,实例结束后用户仍然登录状态，但没有连接实例 sql&amp;gt; startup nomount # 启动默认实例（不加载数据库） sql&amp;gt; startup open # 启动、装载、打开默认的数据库 cmd&amp;gt; set oracle_sid=orcl # 在windows下设置oracle的默认登录数据库 启动过程 加载参数文件database/init数据库名 分配sga (system global area)到内存空间，用于缓存数据库信息 创建后台进程 挂载数据库 sql&amp;gt; startup mount 挂载过程 装载数据库文件夹中的文件 # sga中有已经初始化了ctl文件的路径，通过ctl文件装载数据库 ctl(从中得到数据库文件名) -&amp;gt; dbf # 3种数据库文件: .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/db/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/db/redis/</guid>
      <description>基础 remote dictionary server 特点 no-sql, c编写 内存数据库 # 请求不经过parser和optimizer key-value 单线程 可持久化 与memcache区别 memcache全在内存，不能持久化，redis部分硬盘 memcache类型支持简单 # memcache类型只有字符串，append字符串, blacklist删除麻烦 emecache多线程, redis单线程 底层模型，与客户端通信协议不同，redis自己实现vm机制(冷热数据分离) value, memcache只能存1MB, redis可存1GB redis可设置expire, 支持排行榜, 浮点数 类型 string 整个或一部分操作 整数、浮点数自增自减 list 两边推入或弹出 偏移量trim 读单个多个元素 值查找移除元素 set 增删查单个元素 单个元素是否存在 交集、并集、差集 随机取元素 hash 增删查单个键值对 获取所有键值对 zset # 有序集合, 排序根据score, score为双精度浮点数 增删查单个元素 根据range或成员获取元素 应用 会话缓存(session cache) 全面缓存(FPC) 队列 排行榜/计数器 发布/订阅 命令 文件命令 redis-server # 端口为6379 redis-server /etc/redis.conf 来加载配置文件 redis-cli redis-benchmark # 性能测试工具 redis-cli命令 ping # 成功时返回 PONG shutdown # 关闭redis-server服务 -p 端口号 quit  功能 性能高 # 100k次读写/s 数据类型丰富 所有操作有原子性 支持发布/订阅，通知，key过期 发布订阅 subscribe psubscribe # 订阅给定模式匹配的所有频道 unsubscribe punsubscribe publish sort # 列表、集合、有序集合排序，返回结果或生成存储 过期 persist # 移除键过期时间 ttl # 键距离过期时间还有多少秒 pttl # 多少毫秒 expire # 给定键指定数秒后过期 pexpire # 指定的毫秒后过期 expireat # unix时间戳过期 pexpireat # 毫秒unix时间戳 事务 # 事务期其他客户端命令阻塞 multi # 创建事务队列，开始记录命令 exec # 提交事务队列 watch # 对键加锁 unwatch discard # 取消事务 持久化 bgsave # fork线程创建快照, windows不支持 save # 停止响应创建快照 sync # 向主服务器要求复制时，主服务器bgsave，非刚bgsave过 bgrewriteaof # 重写aof文件使它缩小 复制 slaveof 客户端分片 不完全事务  性能 内存数据库，需要预估内存，使用key过期节约 完整重同步占资源，可以部分重同步 重启数据加载慢 master内存快照时，save命令调rdbSave阻塞主线程 master AOF持久化，追加文件大时影响master重启恢复速度 用slave AOF master调用BGREWRITEAOF重写AOF文件时，cpu和内存负载高 主从复制最好同局域网  数据 set mykey somvalue get mykey del mykey incr decr incrby decrby incrbyfloat append getrange setrange getbit setbit bitcount # 二进制位串位为1的数量 bitop # 二进制位串执行and, or, xor, not rpush list-key item lpush lrange list-key 0 -1 # -1为结束索引 lindex list-key 1 rpop lpop list-key lrange ltrim # 修剪 blpop # timeout秒内阻塞并等待弹出元素 brpop rpoplpush # 一个列表中右弹元素推入另一个列表左端，最后返回这个元素 brpoplpush sadd set-key item smembers set-key sismember set-key item srem set-key item # 删除，返回删除的数量 scard # 元素数 srandmember # 随机返回一个或多个元素。count正数时，返回的元素不重复, 负数时可重复 spop # 随机移除一个元素 smove # 一个集合中移除，并在一个集合中添加。返回移除的数量 sdiff # 差集 sdiffstore # 差集生成集合 sinter # 交集 sinterstore sunion # 并集 sunionstore hset hash-key sub-key value hget hash-key sub-key hdel hash-key sub-key hlen hexists hash-key sub-key hkeys hash-key hvals hgetall hash-key hincrbyfloat hincrby hash-key field -1 hmget hmset hash-key field1 &amp;quot;foo&amp;quot; field2 &amp;quot;bar&amp;quot; zadd zset-key 728 member zrange zset-key 0 -1 withscores zrevrange zset-key 0 -1 withscores zrangebyscore zset-key 0 800 withscores # 根据score范围查找 zrevrangebyscore zrem zset-key member zremrangebyrank zremrangebyscore zincrby zinterstore sum 3 sub1 sub2 sub3 # 生成交集, 重复值score相加, 3 指定可变参数的数量 zunionstore # 并集 zcard # 成员数量 zcount # 分值之间的成员数量 zrank # 返回排名 zrevrank zscore # 返回分值  client jedis # java, 支持redis sharding, 即ShardedJedis结合ShardedJedisPool Jedis jedis = new Jedis(&amp;quot;localhost&amp;quot;); # 连接redis数据库 jedis.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/ops/linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/ops/linux/</guid>
      <description>历史 40年代：汇编语言 60年代：汇编语言unux 70年代初：c语言、c语言unux、unux开源（美国反垄断法制裁AT&amp;amp;T） 70年代末：AT&amp;amp;T分裂，unix闭源 80年代：minix 90年代：linux # 80、90年代之间：gun计划  文件位置 /var /log /boot.log # 启动日志 /proc /[pid] /status # 任务虚拟地址空间的大小 VmSize, 应用程序正在使用的物理内存的大小 VmRSS /etc /sudoers /group /passwd /resolv.conf # dns nameserver 223.5.5.5 nameserver 223.6.6.6 # alidns /sysconfig /network-scripts/ifcfg-eth0 # 永久修改ip DEVICE=eth0 # 设备别名 BOOTPROTO=static # 网卡获得ip地址的方式，默认dhcp HWADDR=00:00:00:00:00:00 # mac IPADDR=192.168.0.100 # ip NETMASK=255.255.255.0 # netmask ONBOOT=yes # 系统启动时是否激活此设备 /network # 修改网关 NETWORKING=yes # 系统是否使用网络 HOSTNAME=abc # 设置本机主机名, 要与/etc/hosts中设置的主机名相同 GATEWAY=192.</description>
    </item>
    
    <item>
      <title>Register</title>
      <link>https://example.com/register/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/register/</guid>
      <description>连接 信息 石墨 processon vpntech
go go test -bench=. --cpuprofile=cpu.prof --memprofile=mem.prof -config ../conf/config_lc.toml -test.run TestCreateType go tool pprof service.test cpu.prof go-torch -b cpu.prof go test -cover -args -config config.toml -test.run &amp;quot;TestCreate&amp;quot;  linux dmesg journalctl 快捷键 ctrl alt f1/f2/...  系统配置 bin # 系统需要 yaourt network-manager awesome i3-wm ibus wireless-tools pkgfile os-prober ntfs-3g pepper-flash tree unzip alsamixer arandr xscreensaver virtualbox firefox chromium thunderbird tmux vim # 运维需要 openssh git expect wget sysdig # 程序需要 g++ python lua ruby cmake protobuf openjdk8 docker mysql nginx nginx-php nsq redis zipkin opt # ide webstorm datagrip eclipse-inst eclipse-birt eclipse-jee-neon goland intellij idea phpstorm pycharm vscode sublime mps android studio # 图形工具 wireshark filezilla postman robomongo emacs neoclipse # 数据库 elasticsearch elasticsearch-head elasticsearch-analysis-hanlp elasticsearch-ik elasticsearch-pinyin redis mongodb mariadb neo4j pgsql # 工具 go maven tomcat flame-graph jdk1.</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://example.com/about_me/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/about_me/</guid>
      <description> 介绍 outrun，男，1990.4 934260428@qq.com outrunJ.github.io  </description>
    </item>
    
    <item>
      <title>面试</title>
      <link>https://example.com/docs/interview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/interview/</guid>
      <description> 带笔记本 算法 目标 写bug free算法 o-&amp;gt; 链表反转 递归、非递归 o-&amp;gt; ArrayList, ThreeMap, HashMap 的原理和模拟 o-&amp;gt; 灵活运用栈与队列 o-&amp;gt; 9大排序代码，时间复杂度与空间复杂度，优缺点 o-&amp;gt; 矩阵加法、减法、乘法、100个矩阵乘法与最优结合次序 o-&amp;gt; 邻接表、邻接矩阵、深搜、广搜、拓扑排序、最短路径、最小生成树 o-&amp;gt; 单链表有没有超过5个字符的回文子串 o-&amp;gt; 单链表最长回文子串 o-&amp;gt; 浮点数组(会相等)二分查找 o-&amp;gt; 任意大整数类型,至少支持乘法  </description>
    </item>
    
  </channel>
</rss>