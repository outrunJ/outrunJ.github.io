<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>后端 on outrun的笔记</title>
    <link>https://example.com/docs/backend/</link>
    <description>Recent content in 后端 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 10 Oct 2018 14:36:50 +0800</lastBuildDate>
    
	<atom:link href="https://example.com/docs/backend/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JavaWeb</title>
      <link>https://example.com/docs/backend/javaweb/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/backend/javaweb/</guid>
      <description>基础 分层 视图层 jsp 控制层 servlet 业务层 过滤数据 manager层 封装第三方，service能力下沉，dao中间件 数据访问层对象 封装对象 数据库 java web 13种技术 JDBC Java Database Connectivty JNDI Java Name and Directory Interface EJB Enterprise JavaBean RMI Remote Method Invoke Java IDL/CORBA JSP Java Server Pages Java Servlet XML Extensible Markup Language JMS Java Message Service JTS Java Transaction Service JTA Java Transaction Architecture JavaMail JAF JavaBeans Activation Framework  jsp 基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层 域对象 pageContext # 当前页面有效 request # 一次请求范围 session # 会话 application context # 同一服务器 内置对象 Request Response Session Out # 输出流 PageContext # context Page # jsp的this Exception # &amp;lt;%@ page isErrorPage=&amp;quot;true&amp;quot;%&amp;gt; 时使用，显示异常信息 Application # 服务器 Config # 服务器配置  jsp-el表达式 ${ } 11个内置对象 pageContext // pageContext page // map （相当于pageScope，不过写法上省略了Scope） requestScope // map sessionScope // map applicationScope // map param // map ,用${param.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/backend/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/backend/elasticsearch/</guid>
      <description>介绍 分布式实时lucene  使用 ./bin/elasticsearch curl http://localhost:9200  命令 elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name  概念存储 index type # document中加_type field实现 # 所以不同type中的field在index要唯一，否则冲突 # 对field排序会载入所有type的document document # 对应lucene中的key value倒排文档 # 对就一个请求的json对象 field mapping # 定义type的field，映射json到document field  设置 config/elasticsearch.yml action.auto_create_index: -l*, +z* # 自动创建，以z开头和非l开头的索引 action.destructive_requires_name: true # 允许通配删index http.cors.enables: true http.cors.allow-origin: &amp;quot;*&amp;quot; cluster.name: c1 node.name: n1 node.master: true node.data: true transport.host: localhost transport.tcp.port: 9300 network.host: 0.0.0.0 # 修改es监听地址，别的机器也可以访问。同时设置bind_host和publish_host # 需要设置transport.host:localhost network.bind_host # 节点绑定ip network.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/backend/hibernate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/backend/hibernate/</guid>
      <description>基础 优点 完全面向对象编程思想，无sql 减少代码 控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率 hibernate具有独立性（访问层随时可以更换） 特性 不写hbm.xml映射文件，而是基于注解的验证 对象、集合、属性的延迟加载 dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常 目录 . # hibernate程序包 documentation # 文档 lib # 所有依赖包 project # 源码文件 加载顺序 后面的覆盖前面的 hibernate.properties中的配置被覆盖 # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置 hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准） 开发流程 加载配置: jdbc参数，数据库方言，hbm映射 创建SessionFactory # 内有连接池 创建session 事务处理 关闭session 关闭连接池 对象状态 𣊬时态 # 没有OID(持久化标识), 没有关联session 持久态 # 有OID, 与session关联, 事务未提交 脱管态 # 有OID, 没有关联session 缓存机制 一级缓存(session) 事务级，事务结束缓存失效 # 请求同一对象，取得同一实例 总是打开 二级缓存 SessionFactory级别，session共享 缓存散装持久化实例, 有不同缓存策略 先设置策略，再设置过期时间与cache提供器 优点 提高速度、减小压力 缓存失效时，不立即查找，而是合并sql查找 查询方式 HQL QBC(命名查询) SQL get与load get立即加载，load延时加载 get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库 # 代理对象只存id get没有时返回null, load抛异常 检索策略 # 取关联对象 立即检索 # 一次全加载, select多 延迟检索 # 访问游离状态代理类，需要在持久化状态时已被初始化 迫切左外连接检索 # 用外连接取代select，全加载  优化 数据库设计调整 HQL优化 api正确使用 配置参数 # 日志、查询缓存，fetch_size, batch_size等 映射文件优化 # id生成策略，二级缓存，延迟加载，关联优化 一级缓存管理, 二级缓存策略 事务控制策略  基本概念： o-&amp;gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题 o-&amp;gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想) DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准 它们的区别在于 hibernate中不写sql语句 ibatis中写少量sql语句 DBUtils中写sql语句 它们的另一个相同点是 底层全都是jdbc o-&amp;gt; 结构对应 javabean中的 类，对象，属性 数据库中的 表，记录，字段 o-&amp;gt; hql hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用 o-&amp;gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean  使用 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/backend/principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/backend/principle/</guid>
      <description> 事件 # 非阻塞 实现 回调 队列存事件, 单进程检测事件是否回调 工具 epoll(select, poll) libev(libevent)  并发并行 并发 为什么: 多任务能力，非阻塞 类比: 任务队列 并行 为什么: 提高执行效率 类比: 多核处理器 并行代码：编译代码顺序不确定，或执行顺序不确定 面临竞争问题 业务并行 解耦业务 业务满足幺半群性质 封闭性 # 业务运算结果是业务 结合律 # 业务a、b的结果后与c执行，等同b、c的结果与a执行 单位元 # 单位业务a与其它业务b执行，得b 系统应用 并发能力 吞吐量(并行) I/O多路复用(epoll) cpu&amp;quot;多路复用&amp;quot;(进程、线程) cpu机制(多发射、流水线、超标量、超线程) 进程线程应用 cpu对任务的M:N处理 进程切换处理任务 线程(通信，并行) 实现(异步, 并发，并行) 写法 回调(监听器), 链式(promise)，同步(async) 事件处理器 调度方式: 单线程循环 协程 为什么用户实现协程 POSIX线程模型累赘 进程/线程 切换开销大 空间资源占用大 os调度对go模型不合理 go gc需要内存处理一致状态(所有线程停止), os调度时，因gc时间不确定，期间大量线程停止工作 # go调度器知道什么时候内存处于一致性状态(只需正在核上运行线程) 本质 用户态，寄存器+栈, 让出 调度方式(线程模型) N:1 # N个用户空间线程运行在1个内核空间线程 上下文切换快 无法利用多核 1:1 # POSIX(pthread), java 利用多核 上下文切换慢，每次调度都在用户态和内核态间切换 M:N 任意内核模型管理任意goroutine 调度复杂性大 go M(machine)代表内核线程 G(goroutine)有自己的栈，程序计数器，调度信息(如正阻塞的channel) P(processor)调度上下文, $GOMAXPROCS设置数量 P中有G队列(runqueue, 队尾添加新G) 当前运行一个G, 到调度点时，队列弹出另一个G P周期检查全局G队列防止其中G饿死 P运行完，全局G队列拉取G P运行完，全局G队列空，从其它P拉取一半G P运行在M, M阻塞时P移到其它M, 阻塞M中保留阻塞的G 调度器创建足够多M跑P 阻塞M中G的syscall返回, M尝试偷一个P 没得到P时, 它的G加入全局G队列, M进线池睡眠 概念 过度竞争 过多线程尝试同时使用一个共享资源 同步 # 直接相互制约 互斥 # 间接相互制约 竞态条件(race condition) 异步 # 与同步相对。多线程是实现异步的一种手段 可见性 线程总可见到最后修改的数据, 脏读是反例 原子性 查看和修改同时发生 乱序执行 # java 中标记volatile的变量可以不乱序执行, 现多用原子变量 编译器或JVM的静态优化可以打乱代码执行顺序(java) 硬件可以通过乱序执行来优化性 死锁 # 多线程竞争资源而互相等待 条件 互斥 # 资源排他 不剥夺 # 资源不被外力剥夺 请求和保持条件 # 线程已保持一个资源，请求新资源。请求被阻塞而自己资源保持 循环等待 # 阻塞线程形成环 方案 锁按顺序获得 # a,b,c锁，要得c手中要有a, b # 使用锁的地方比较零散时，遵守此顺序变得不实际 # 可以用对象散列值作全局顺序减小死锁机率 阻塞加时限 # 外星方法中可能包含另一把锁，要避免在持锁时调用外星方法  多线程 线程池 作用 重复利用, 降低资源消耗 提高响应速度，不等线程创建 可管理，线程是稀缺资源，统一分配，调优和监控，提高系统稳定性  锁 锁 公平锁 # FIFO取锁 非公平锁 # 每次直接占有 乐观锁 # 假设最好，有冲突时重试 悲观锁 # 假设最坏，等所有线程释放成功 互斥锁(mutex) # 访问前加锁，访问后解锁 悲观锁 读加锁 乐观锁 读不加锁，写时判断数据版本是否修改，再重试 读写锁 rwlock 状态 读加锁状态 可个线程占用 阻塞写线程 # 导致写线程抢占不到资源，所以有写线程时，阻塞后进入的读线程 写加锁状态 一次只有一个线程占用 阻塞所有线程 不加锁状态 自旋锁 spinlock 互斥锁改，自己进入循环等待状态(忙等) # 适合锁持有时间较短 RCU锁 Read-Copy Update 读写锁改，一个写线程，读线程无限制 实现垃圾回收器 写线程copy副本修改，向垃圾回收器注册callback以执行真正的修改 垃圾回收器收到信号，所有读线程结束，执行callback 可重入锁 # 互斥锁改，允许同一线程多次获得写锁 管程(monitor) 临界区(critical section) 内置锁、显示锁 # 指java的synchronized与Reentrantlock 信号量 进程, 线程间通知状态  CAS # compare and swap，无锁算法(lock free), 非阻塞(non-blocking), 构成基本的乐观锁 # cpu实现的指令 3个操作数 # V的值为A时，原子更新成B，否则无操作。返回V的值 需要读写的内存位置V 进行比较的值A 拟写入的新值B  函数式 介绍 消除可变状态 概念 命令式语言中，求值顺序与源码的语句顺序紧密相关(有可能乱序执行) 函数式程序并不描述&amp;quot;如何求值以得到结果&amp;quot;，而是描述&amp;quot;结果应当是什么样的&amp;quot;。函数式编程中，如何安排求值顺序相对自由 引用透明性 # 任何调用函数的地方，都可以用函数运行结果来替换函数调用，而不会产生副作用 数据流式编程(dataflow programming) # (+ (+ 1 2) (+ 3 4))就是一个数据流，所有函数都可以用时执行 future模型  分离标识与状态 介绍 Clojure, 指令式编程和函数式编程混搭 clojure四种并发模型 vars (thread-local) atoms原子变量 agent代理 refs引用 与 ATM软件事务内存  actor模型 介绍 作为actor自己修改自己的数据，对外提供消息，处理对外消息 共享内存模型和分布式内存模型，适合解决地理分布型问题，强大的容错性 基于消息传递，侧重通道两端实体 每个actor有一个mailbox, mailbox中转消息  csp 介绍 通信顺序进程(communicating sequential processes) 基于消息传递，侧重信息通道  数据级并行 # 不可变数据  lambda架构 介绍 综合MapReduce和流式处理的特点，处理大数据问题的架构  状态保持 cookie 分域名, 客户端保存服务器定义数据, 请求时发送 session 服务器id数据，id下发到客户端 共享 # 同时多方案，动态切换 zookeeper切换环境变量与重启 # java中filter重写request getSession webSphere或JBoss可配置session复制或共享 # 不好扩展和移植 加密存cookie 服务 redis memorycache gemfire # 12306  认证 单点登录 sessionID存cookie, cookie禁用存头域 token 类型 access token # 标识唯一用户 user_id issue_time # token发放时间，单位秒 ttl # 有效时间，uint16,单位分钟 mask # int128, 按bit分组用户，用于批量封禁或其它功能 refresh token # 用来换access token，与access token同时发放 # 过期时间更长 实现 redis存储 token不要太长  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/docs/backend/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/docs/backend/spring/</guid>
      <description>基础 特点 容器, 也容纳管理了第三方框架 # 目的是解耦框架api 轻量级，模块化，无(少)侵入 IOC(inversion of control) 容器用工厂装配对象并管理, 面向接口编程 优点 降低代码量 容易测试 最小侵入性松耦合 方式 Setter 构造器 静态工厂、实例工厂 DI(dependency injection) 容器向类添加属性 # 反射，用带参构造或set方法 AOP(aspect oriented programming) # 继承是纵向组织，AOP横切入业务 # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用） 动态代理实现切入代码 权限控制 事务管理 记录日志 概念 连接点:普通方法 切入点:名称满足条件的连接点 增强（通知）类:服务对象 # 切入点与增强是多对多的 切面:切入点 + 增强类 # 我们切入的是横切面 目标对象（服务对象）：要注入的对象 通知 before # 执行前 after # 执行后 after-returning # 正常退出 after-throwing # 异常退出 around # 执行前后 代理对象(业务对象)：被注入的对象 模块 dao orm aop jee web core 结构 核心容器(core container) Core # 最底层，资源访问，类型转换 Beans # IOC, DI, BeanFactory Context # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播 EL # 表达式语言 AOP, Aspects # Aspects对AspectsJ集成, 功能多于spring asp 数据访问/集成 JDBC ORM OXM # object xml 映射 JMS # 消息与异步通信 事务 Web/Remoting Web # ioc窗口，rmi, hessian,burlap, web service Web-Servlet Web-Struts Web-Porlet # portal认证 Test 设计模式 代理 目标对象实现接口，使用Proxy 未实现接口，使用CGLIB 单例 bean默认单例 模板, 解决代码重复问题 RestTemplate, JmsTemplate, JpaTemplate 控制器 DispatherServlet对请求分发 视图帮助(view helper) 提供jsp标签、高效宏 帮助在视图中写代码 依赖注入 BeanFactory, ApplicationContext核心理念 工厂 BeanFactory 版本 2.</description>
    </item>
    
  </channel>
</rss>