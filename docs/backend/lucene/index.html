<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Lucene
  
 | Hugo Book</title>



<link rel="stylesheet" href="/book.min.1a0250256273fabf0f848ed9a3c50aae344d758339cad9725e656ac71546e6f5.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">Hugo Book</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f backend\2flucene\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/term">名词</a></li>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
<li><a href="/docs/algorithm/algorithm">算法</a></li>
<li><a href="/docs/algorithm/analysis">分析</a></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/term">名词</a></li>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
<li><a href="/docs/architecture/communication">通信</a></li>
<li><a href="/docs/architecture/governance">治理</a></li>
<li><a href="/docs/architecture/ha">高可用</a></li>
<li><a href="/docs/architecture/server">服务器</a></li>
<li><a href="/docs/architecture/store">存储</a></li>
<li><a href="/docs/architecture/heartbeat">heartbeat</a></li>
<li><a href="/docs/architecture/iscsi">iscsi</a></li>
<li><a href="/docs/architecture/jetty">jetty</a></li>
<li><a href="/docs/architecture/kafka">kafka</a></li>
<li><a href="/docs/architecture/lvs">lvs</a></li>
<li><a href="/docs/architecture/netty">netty</a></li>
<li><a href="/docs/architecture/nginx">nginx</a></li>
<li><a href="/docs/architecture/nsq">nsq</a></li>
<li><a href="/docs/architecture/protobuf">protobuf</a></li>
<li><a href="/docs/architecture/rabbitmq">rabbitmq</a></li>
<li><a href="/docs/architecture/squid">squid</a></li>
<li><a href="/docs/architecture/tomcat">tomcat</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/term">名词</a></li>
<li><a href="/docs/backend/backend">归纳</a></li>
<li><a href="/docs/backend/hardware">硬件</a></li>
<li><a href="/docs/backend/cxf">cxf</a></li>
<li><a href="/docs/backend/dwr">dwr</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/hadoop">hadoop</a></li>
<li><a href="/docs/backend/hexo">hexo</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
<li><a href="/docs/backend/hugo">hugo</a></li>
<li><a href="/docs/backend/jbpm">jbpm</a></li>
<li><a href="/docs/backend/jekyll">jekyll</a></li>
<li><a href="/docs/backend/lucene">lucene</a></li>
<li><a href="/docs/backend/mybatis">mybatis</a></li>
<li><a href="/docs/backend/nodejs">nodejs</a></li>
<li><a href="/docs/backend/shiro">shiro</a></li>
<li><a href="/docs/backend/socketio">socketio</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/struts2">struts2</a></li>
<li><a href="/docs/backend/tornado">tornado</a></li>
<li><a href="/docs/backend/interview">面试</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mycat">mycat</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/neo4j">neo4j</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">postgre sql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/language">语言</a></li>
<li><a href="/docs/design/media">媒体</a></li>
<li><a href="/docs/design/project">项目</a></li>
<li><a href="/docs/design/standard">规定</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/frontend">归纳</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/bigpipe">bigpipe</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/cocos2dx">cocos2dx</a></li>
<li><a href="/docs/frontend/createjs">createjs</a></li>
<li><a href="/docs/frontend/d3">d3</a></li>
<li><a href="/docs/frontend/extjs">extjs</a></li>
<li><a href="/docs/frontend/fis">fis</a></li>
<li><a href="/docs/frontend/grunt">grunt</a></li>
<li><a href="/docs/frontend/gulp">gulp</a></li>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
<li><a href="/docs/frontend/webpack">webpack</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/ops">运维</a></li>
<li><a href="/docs/ops/ant">ant</a></li>
<li><a href="/docs/ops/archlinux">archlinux</a></li>
<li><a href="/docs/ops/cron">cron</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
<li><a href="/docs/ops/git">git</a></li>
<li><a href="/docs/ops/kvm">kvm</a></li>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/maven">maven</a></li>
<li><a href="/docs/ops/pm2">pm2</a></li>
<li><a href="/docs/ops/ssh">ssh</a></li>
<li><a href="/docs/ops/svn">svn</a></li>
<li><a href="/docs/ops/virtualbox">virtualbox</a></li>
<li><a href="/docs/ops/vmware">vmware</a></li>
<li><a href="/docs/ops/vsftp">vsftp</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/language">归纳</a></li>
<li><a href="/docs/pl/principle">原理</a></li>
<li><a href="/docs/pl/parser">编译</a></li>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/javaweb">javaweb</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/lisp">lisp</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/c">c</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/cpp">cpp</a></li>
<li><a href="/docs/pl/elixir">elixir</a></li>
<li><a href="/docs/pl/erlang">erlang</a></li>
<li><a href="/docs/pl/lua">lua</a></li>
<li><a href="/docs/pl/perl">perl</a></li>
<li><a href="/docs/pl/php">php</a></li>
<li><a href="/docs/pl/prolog">prolog</a></li>
<li><a href="/docs/pl/r">r</a></li>
<li><a href="/docs/pl/ruby">ruby</a></li>
<li><a href="/docs/pl/rust">rust</a></li>
<li><a href="/docs/pl/scala">scala</a></li>
<li><a href="/docs/pl/scheme">scheme</a></li>
<li><strong><em>标记语言</em></strong>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
<li><a href="/docs/pl/markup_language/markdown">markdown</a></li>
<li><a href="/docs/pl/markup_language/ml">ml</a></li>
<li><a href="/docs/pl/markup_language/plantUML">plantUML</a></li>
<li><a href="/docs/pl/markup_language/xml">xml</a></li>
<li><a href="/docs/pl/markup_language/schema">schema</a></li>
<li><a href="/docs/pl/markup_language/dtd">dtd</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a>

<ul>
<li><a href="/docs/test/test">测试</a></li>
</ul></li>
<li><a href="/docs/tool"><strong>工具</strong></a>

<ul>
<li><a href="/docs/tool/tool">归纳</a></li>
<li><a href="/docs/tool/windows">windows</a></li>
<li><a href="/docs/tool/chrome">chrome</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
<li><a href="/docs/tool/firefox">firefox</a></li>
<li><a href="/docs/tool/intellij_idea">intellij idea</a></li>
<li><a href="/docs/tool/loadrunner">loadrunner</a></li>
<li><a href="/docs/tool/sublime">sublime</a></li>
</ul></li>
<li><a href="/docs/management">管理</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Lucene
  
</strong>
</header>

      
<article class="markdown">

<h1 id="原理">原理</h1>

<pre><code>block k-d tree
倒排索引
        词典
                排序数组
                        # 为了二分查找
                        # 实现简单，性能差
                哈希表
                        # 性能好，占内存大
                跳跃表
                        # 内存小且可调节, 模糊查询不好
                B/B+树
                        # 磁盘索引 ，更新方便，检索慢
                trie树
                        # 效率与字符串长度有关，只适合做英文词典
                dat
                        # 可做中文词典，内存占用小
                fst
                        # 共享前缀，内存占用小，要求输入有序，不易更新
                        内存存前缀索引、磁盘存后缀词块
        倒排表
        正向文件
                # 行式存储，原始文档
        doc-values
                # 列式存储，文档号到值的映射
文件指纹
</code></pre>

<h1 id="概念">概念</h1>

<pre><code>    index
            # 一个倒排表，对应一个目录
    segment
            # index的存储单元，包含多个文档
    document
            # 创建单位
    field
            # 文档里的键值对
    term
            # 分词后的字符串
    analyzer
            tokenizer
                    # 切分文本到索引单元
            tokenfilter
                    # 对token预处理
</code></pre>

<h1 id="常识">常识</h1>

<pre><code>    特性
            索引
            高亮
            命中率排序
            分词
    与数据库的区别：数据库注重存储、全文检索注重查询
    其它搜索：多媒体搜索
    索引库(文件夹 或 内存中)：
            只存储了商品的基本信息
             索引库与数据库定时同步
            索引库 -&gt; document -&gt; field                # field是键值对,值只能存数据
                    同步
            IndexWriter:addDocumnet(),delteDocument(),updateDocument()
                    查询
                            IndexSearch:search(),get()
            Field的内部结构
                        # 不存不索引会报错
        Store:控制此Field字段是否存储到索引库中
        Index:是否建立索引（索引不区分大小写,过滤词不创建索引）
            NO:不建立索引，可以通过field的key查到，但是不能通过关键字查询到
            NOT_ANALYZED:建立索引，但是不分词
            ANALYZEd:建立索引又分词
</code></pre>

<h1 id="使用到的对象">使用到的对象</h1>

<pre><code>    Directory
    Analyzer
            TokenStream tokenStream = analyzer.tokenStream(&quot;eldName&quot;,new StringReader(&quot;测试字符串&quot;))
            while(tokenStream.incrementToken()){
                    TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class);
                    System.out.println(termAttribute.term());
            }                # 使用分词器测试分词
    Document
            add(Field)
            document = indexSearcher.doc(ScoreDoc)
            get(String)                # 通过key查找value
    IndexWriter
            IndexWriter(directory,analyzer,MaxFieldLength.LIMITED);       # LIMITED限定Field的数量(源码中规定默认值)
            addDocument(Document)
            commit()
            close()                        # 自带commit()
            rollback()
    IndexSearcher
    QueryParser
            QueryParser(Version.LUCENE_30,&quot;name&quot;,analyzer)
    Query
            query = parser.parse(用户传递的字符串);
            query = parser.parseMultiField(String [], 用户传递的字符串);
    TopDocs
            topDocs = indexSearcher.search(query, 10);                # 10是期望的结果数
                                                                                                            ## 最终查询到的结果数是：期望结果数与实际结果数的最小值
            totalHits                # 命中的结果数
    ScoreDoc
            ScoreDoc [] scoreDocs = topDocs.scoreDocs;
            scoreDoc.score                # 命中率积分
            scoreDoc.doc                # 命中文档编号，该编号由lucene自动生成
    Term                # 索引项
            Term(&quot;field中的key&quot;,&quot;field中value解析出的关键字&quot;)
</code></pre>

<h1 id="索引的结构">索引的结构</h1>

<pre><code>    Term(&quot;key&quot;,&quot;value&quot;)[0,3,4]                        # key 为对应的field中的&quot;key&quot;,value对应的是解析field的&quot;value&quot;出的关键字
                                                                            ## []中的内容为匹配的文档编号，该编号为系统自动生成的
</code></pre>

<h1 id="注意">注意</h1>

<pre><code>    lucene创建索引时field的key都可以重复，没有主键方面的限制。但是实际应用时要求我们为document有唯一的标识“主键”field,便于对每个document进行更新与删除                        
</code></pre>

<h1 id="使用">使用</h1>

<pre><code>    包：IKAnalyzer,lucence-analyzer(英文分词，不需要),memory,core,highlighter
    工具：lukeAll 用来查看索引库
    添加、查询、删除、修改
    抽取配置类（构造方法私有化）
            Configuration
                    维护了directory与analyzer
            DocumentUtil
                    goodsToDocument(Goods)
                    documentToGoods(Document)
            LuceneUtil
                    维护了indexWriter与indexSearcher
                    注意
                            1.indexWriter在static代码块中初始化
                            2.getIndexWriter
            LuceneService
                    用indexWriter与indexSearcher处理业务逻辑
                    添加
                            indexWriter.addDocument(Document)
                            indexWriter.rollback()
                    删除
                            indexWriter.deleteDocument(Term)
                            indexWriter.optimize()                # 删除document的时候同步索引库，没有设置的话只是删除document，但是索引中还是可以查到
                    更新
                            indexWriter.updateDocument(Term,Document)
                            indexWriter.optimize()                # 更新是先删除再添加（所以如果updateDocument(Term,Document)中匹配多个Document时，会出现删除了多个Document,而添加了一个Document的情况）
                    查询
                            QueryParser parser = new QueryParser(Version.LUCENE_30, &quot;field中的key&quot;, analyzer);
                            Query query = IKQueryParser.parseMultiField(new String[]{&quot;name&quot;,&quot;remark&quot;}, &quot;ee&quot;);                # 多字段查询，IKAnalyzer特有
                                            #　多字段查询到的第二个字段的结果，在转换高管时（调用getBestFragment时）只会对该方法指定的一个字段进行匹配，如果该字段不匹配时（但是第二个字段匹配），则会返回空。
                                            ## 针对这一个bug,在getBestFragment处理匹配的结果返回空时，不使用空而直接返回没有高亮的字符串即可。
                            parser.parse(用户传递的字符串);
                            TopDocs topDocs = indexSearcher.search(query, 3);        # 3是期望结果数
                            ScoreDoc [] scoreDocs = topDocs.scoreDocs;
                            Document document = indexSearcher.doc(scoreDoc.doc);                scoreDoc.doc得到文档编号
                            分页查询：
                                    传递当前页码与一页记录数
                                    利用topDocs.totalHits得到总记录数
                                    查询本页与前面所有页的期望数据量，然后只截取本页的文档编号，得到document并返回数据
</code></pre>

<h1 id="分词器">分词器</h1>

<pre><code>    IKAnalyzer
            配置文件
                    src/IKAnalyzer.cfg.xml中配置
                            &lt;properties&gt;  
                                    &lt;entry key=&quot;ext_dict&quot;&gt;/mydict.dic&lt;/entry&gt;                 # 配置自己的字典（不分词）
                                    &lt;entry key=&quot;ext_stopwords&quot;&gt;/ext_stopword.dic&lt;/entry&gt;                 # 配置跳过的字
                            &lt;/properties&gt;
            Query query = IKQueryParser.parse(&quot;name&quot;,name);                # IKAnalyzer特有
</code></pre>

<h1 id="排序">排序</h1>

<pre><code>    Directory directory = FSDirectory.open(new File(&quot;d:/lucene&quot;));
    IndexSearcher indexSearcher = new IndexSearcher(directory);
    Query query = IKQueryParser.parse(&quot;name&quot;,&quot;cc&quot;);
    Sort sort = new Sort(new SortField(&quot;id&quot;, SortField.INT,true));                # 这里可以排序多个字段
            # 参数1：&quot;id&quot;是排序的field字段,参数2：是字段内容的类型,参数3 true代表降序排列
            ## 此时命中率不再计算（因为不按命中率排序）
            ## 排序的field必须建立索引
    indexSearcher.search(query, null,10,sort);
</code></pre>

<h1 id="高亮">高亮</h1>

<pre><code>    导入包:highlight与memory
    Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(&quot;&lt;font color='red'&quot;,&quot;&lt;/font&gt;&quot;),new QueryScorer(query));
    highlighter.setTextFragmenter(new SimpleFragmenter(10));                # 限制字符长度
    ..
    String result = highlighter.getBastFragment(analyzer,&quot;name&quot;,doc.get(&quot;name&quot;));
            # 返回高亮处理字符串
            ## 参数1：解析用户输入词的分词器,参数2：是要查询的field的key(没有用)，参数3：field的value
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/blog-hugo/commit/527b54f06fb1e4192f7f9c86cfded0cda859d1b3" title='Last modified Jun 17, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Jun 17, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/blog-hugo/tree/master/content/docs/backend/lucene.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#原理">原理</a></li>
<li><a href="#概念">概念</a></li>
<li><a href="#常识">常识</a></li>
<li><a href="#使用到的对象">使用到的对象</a></li>
<li><a href="#索引的结构">索引的结构</a></li>
<li><a href="#注意">注意</a></li>
<li><a href="#使用">使用</a></li>
<li><a href="#分词器">分词器</a></li>
<li><a href="#排序">排序</a></li>
<li><a href="#高亮">高亮</a></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
