<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Hibernate
  
 | Hugo Book</title>



<link rel="stylesheet" href="/book.min.1a0250256273fabf0f848ed9a3c50aae344d758339cad9725e656ac71546e6f5.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">Hugo Book</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f backend\2fhibernate\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/term">名词</a></li>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
<li><a href="/docs/algorithm/algorithm">算法</a></li>
<li><a href="/docs/algorithm/analysis">分析</a></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/term">名词</a></li>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
<li><a href="/docs/architecture/communication">通信</a></li>
<li><a href="/docs/architecture/governance">治理</a></li>
<li><a href="/docs/architecture/ha">高可用</a></li>
<li><a href="/docs/architecture/server">服务器</a></li>
<li><a href="/docs/architecture/store">存储</a></li>
<li><a href="/docs/architecture/heartbeat">heartbeat</a></li>
<li><a href="/docs/architecture/iscsi">iscsi</a></li>
<li><a href="/docs/architecture/jetty">jetty</a></li>
<li><a href="/docs/architecture/kafka">kafka</a></li>
<li><a href="/docs/architecture/lvs">lvs</a></li>
<li><a href="/docs/architecture/netty">netty</a></li>
<li><a href="/docs/architecture/nginx">nginx</a></li>
<li><a href="/docs/architecture/nsq">nsq</a></li>
<li><a href="/docs/architecture/protobuf">protobuf</a></li>
<li><a href="/docs/architecture/rabbitmq">rabbitmq</a></li>
<li><a href="/docs/architecture/squid">squid</a></li>
<li><a href="/docs/architecture/tomcat">tomcat</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/term">名词</a></li>
<li><a href="/docs/backend/backend">归纳</a></li>
<li><a href="/docs/backend/hardware">硬件</a></li>
<li><a href="/docs/backend/cxf">cxf</a></li>
<li><a href="/docs/backend/dwr">dwr</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/hadoop">hadoop</a></li>
<li><a href="/docs/backend/hexo">hexo</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
<li><a href="/docs/backend/hugo">hugo</a></li>
<li><a href="/docs/backend/jbpm">jbpm</a></li>
<li><a href="/docs/backend/jekyll">jekyll</a></li>
<li><a href="/docs/backend/lucene">lucene</a></li>
<li><a href="/docs/backend/mybatis">mybatis</a></li>
<li><a href="/docs/backend/nodejs">nodejs</a></li>
<li><a href="/docs/backend/shiro">shiro</a></li>
<li><a href="/docs/backend/socketio">socketio</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/struts2">struts2</a></li>
<li><a href="/docs/backend/tornado">tornado</a></li>
<li><a href="/docs/backend/interview">面试</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mycat">mycat</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/neo4j">neo4j</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">postgre sql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/language">语言</a></li>
<li><a href="/docs/design/media">媒体</a></li>
<li><a href="/docs/design/project">项目</a></li>
<li><a href="/docs/design/standard">规定</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/frontend">归纳</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/bigpipe">bigpipe</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/cocos2dx">cocos2dx</a></li>
<li><a href="/docs/frontend/createjs">createjs</a></li>
<li><a href="/docs/frontend/d3">d3</a></li>
<li><a href="/docs/frontend/extjs">extjs</a></li>
<li><a href="/docs/frontend/fis">fis</a></li>
<li><a href="/docs/frontend/grunt">grunt</a></li>
<li><a href="/docs/frontend/gulp">gulp</a></li>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
<li><a href="/docs/frontend/webpack">webpack</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/ops">运维</a></li>
<li><a href="/docs/ops/ant">ant</a></li>
<li><a href="/docs/ops/archlinux">archlinux</a></li>
<li><a href="/docs/ops/cron">cron</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
<li><a href="/docs/ops/git">git</a></li>
<li><a href="/docs/ops/kvm">kvm</a></li>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/maven">maven</a></li>
<li><a href="/docs/ops/pm2">pm2</a></li>
<li><a href="/docs/ops/ssh">ssh</a></li>
<li><a href="/docs/ops/svn">svn</a></li>
<li><a href="/docs/ops/virtualbox">virtualbox</a></li>
<li><a href="/docs/ops/vmware">vmware</a></li>
<li><a href="/docs/ops/vsftp">vsftp</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/language">归纳</a></li>
<li><a href="/docs/pl/principle">原理</a></li>
<li><a href="/docs/pl/parser">编译</a></li>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/javaweb">javaweb</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/lisp">lisp</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/c">c</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/cpp">cpp</a></li>
<li><a href="/docs/pl/elixir">elixir</a></li>
<li><a href="/docs/pl/erlang">erlang</a></li>
<li><a href="/docs/pl/lua">lua</a></li>
<li><a href="/docs/pl/perl">perl</a></li>
<li><a href="/docs/pl/php">php</a></li>
<li><a href="/docs/pl/prolog">prolog</a></li>
<li><a href="/docs/pl/r">r</a></li>
<li><a href="/docs/pl/ruby">ruby</a></li>
<li><a href="/docs/pl/rust">rust</a></li>
<li><a href="/docs/pl/scala">scala</a></li>
<li><a href="/docs/pl/scheme">scheme</a></li>
<li><strong><em>标记语言</em></strong>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
<li><a href="/docs/pl/markup_language/markdown">markdown</a></li>
<li><a href="/docs/pl/markup_language/ml">ml</a></li>
<li><a href="/docs/pl/markup_language/plantUML">plantUML</a></li>
<li><a href="/docs/pl/markup_language/xml">xml</a></li>
<li><a href="/docs/pl/markup_language/schema">schema</a></li>
<li><a href="/docs/pl/markup_language/dtd">dtd</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a>

<ul>
<li><a href="/docs/test/test">测试</a></li>
</ul></li>
<li><a href="/docs/tool"><strong>工具</strong></a>

<ul>
<li><a href="/docs/tool/tool">归纳</a></li>
<li><a href="/docs/tool/windows">windows</a></li>
<li><a href="/docs/tool/chrome">chrome</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
<li><a href="/docs/tool/firefox">firefox</a></li>
<li><a href="/docs/tool/intellij_idea">intellij idea</a></li>
<li><a href="/docs/tool/loadrunner">loadrunner</a></li>
<li><a href="/docs/tool/sublime">sublime</a></li>
</ul></li>
<li><a href="/docs/management">管理</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Hibernate
  
</strong>
</header>

      
<article class="markdown">

<h1 id="基本概念">基本概念：</h1>

<pre><code>    o-&gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题
    o-&gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想)
                    DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准
                    它们的区别在于
                            hibernate中不写sql语句
                            ibatis中写少量sql语句
                            DBUtils中写sql语句
                    它们的另一个相同点是
                             底层全都是jdbc
    o-&gt; 结构对应 javabean中的 类，对象，属性
                         数据库中的            表，记录，字段
    o-&gt; hql        hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用
    o-&gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean
</code></pre>

<h1 id="优点">优点</h1>

<pre><code>    1.完全面向对象编程思想，无sql
    2.减少代码
    3.控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率
    4.hibernate具有独立性（访问层随时可以更换）
</code></pre>

<h1 id="特性">特性</h1>

<pre><code>    不写hbm.xml映射文件，而是基于注解的验证
    hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准）
</code></pre>

<h1 id="目录">目录</h1>

<pre><code>    .                                        # hibernate程序包
    documentation                # 文档
    lib                                        # 所有依赖包
    project                                # 源码文件
</code></pre>

<h1 id="加载顺序">加载顺序</h1>

<pre><code>    后面的覆盖前面的
    hibernate.properties中的配置被覆盖        
            # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置
</code></pre>

<h1 id="使用">使用</h1>

<pre><code>1.导入核心包(10 + 1个)
        hibernate3.jar                                # 核心包
        c3p0-0.9.1.jar
        antlr-2.7.6.jar                                # 转换hql到sql
        commons-collections-3.1.jar        # apache的集合增强包
        dom4j-1.6.1.jar
        javassist-3.9.0.GA.jar                # 动态代理
        jta-1.1.jar                                        # java transaction api        处理事务用
        slf4j-api-1.5.8.jar
        log4j.jar
        slf4j-log4j12.jar                        # 三个日志
        +
        mysql-connector-java-5.1.7.bin.jar

2.建立目录
        hibernate.dao
                demo.java
        hibernate.db
                xx.sql
        hibernate.domain
                xx.java
        hibernate.util
                HibernateUtil.java
3.创建映射文件
        xx.java文件的同目录下，创建
                xx.hbm.xml
4.创建配置文件
        src/hibernate.cfg.xml        (可变)
        src/hibernate.properties
5.写提供hibernate session的工具类
        HibernateUtil
6.demo中用hibernate session创建事务进行数据库操作
        demo.java
</code></pre>

<h1 id="session">session</h1>

<pre><code>查询不需要事务，其它都需要事务

流程
    Session session = HibernateUtil.getSession();
    Transaction t = session.getTransaction();
    t.begin();
    session.update(hero);
    session.delete(hero);
    t.comment();

批量
    t.begin();
    session.save(hero);
    t.commit();
    session.clear();

    查询
    Query query = session.createQuery(hql);
    List&lt;Hero&gt; heroList = query.list();

    查询2
    Query query = session.createQuery(hql);
    query.setString(0,name);                // hql中参数从0开始
    query.setString(1,des);
    Hero hero = (Hero) query.uniqueResult();        // 只有一个结果时使用

    修改
    Query query = session.createQuery(hql);
    int i = query.executeUpdate();

结尾
    }catch(Exception e){
            e.printStackTrace();
            t.rollback();
    }finally{
            HibernateUtil.closeSession(); // session.close();
    }

session
    元素的状态
                    # oid: object id,hibernate 的id值唯一并且与表中的数据一一对应
                    ## hibernate中分辨数据只看oid
            临时（new），无oid,不在session中.生成sql语句                
                持久化（persistence object）：session.save(hero),有oid,在session中;(saveOrUpdate(hero))
                游离：session.evict(hero),有oid,不在session中,session.update(hero)重新持久化
                删除：sesssion.delete(hero),有oid,不在session中,不可恢复,提交后可修改数据库
                    # 隐含将po对象转成持久化状态，并生成delete语句。提交后成delete状态，执行语句
                    ## 临时、持久、游离都可以调用
                    ## 临时调用delete时会删除数据库中相应id的值 ，危险
    函数
            get 与 load
                    session.get(hero.class,1),从数据库得到持久状态对象
                        与数据库交互
                        查到时返回po
                        查不到时返回null
                    session.load(hero.class,1)
                        不与数据库交互,返回自己创建的po(只有id)
                    访问非id值的时候，与数据库交互
            session.clear() # session中的引用变量清空
        session.close() # clear() + 关闭session对象，回收资源，但session非空
        session.isOpen()
        session.flush() # 对session中的更改部分生成相应的sql语句,只在session中，不访问数据库
        session.update()    # 只是将游离重新持久化,不产生sql语句。（执行更新语句时加上它增加可读性）
                                                ## update()方法执行时会检验一级缓存（session）中是否有 oid相同的po
                                                ## ,同时会连接数据库，查询一级缓存中po与数据库中记录的一一对应关系
        session.commit()    # flush() + 提交事务
</code></pre>

<h1 id="hibernate-cfg-xml">hibernate.cfg.xml</h1>

<pre><code>必要性
        必须配置

目录与文件名
        任意，建议 src/hibernate.cfg.xml

源码中的案例文件：
        \project\tutorials\web\src\main\resources\hibernate.cfg.xml
        \project\etc\hibernate.cfg.xml
约束文件位置
        hibernate3.jar/org/hibernate/hibernate-configuration-3.0.dtd
数据库连接属性与方言属性的属性名和值可以查找
        \project\etc\hibernate.properties                # 由于xml文件中配置要覆盖的是hibernate.properties文件中的属性
                                                                                        ## 所以属性内容从hibernate.properties文件的属性中查找
        方言类的位置是：hibernate3.jar/org.hibernate/dialect/中查找到相应的类，
                这是最终的路径，（oracle的通用方言类的类路径 可以用这种方法找到，hibernate.properties配置文件中没有写）

加载
        该配置文件属于纯人为配置，需要在Configuration类的实例中调用addResource(&quot;&quot;)方法加载
        addResource()方法中的参数是本配置文件相对于src/目录的全限定名

作用
        1.映射数据库
        2.配置 类-表映射 资源xml文件的路径

内容
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;
&lt;hibernate-configuration&gt;
        &lt;session-factory&gt;
                &lt;!-- 配置访问数据库需要的属性 --&gt;
                &lt;property name=&quot;connection.driver_class&quot;&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;
                &lt;property name=&quot;connection.url&quot;&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/property&gt;
                &lt;property name=&quot;connection.username&quot;&gt;scott&lt;/property&gt;
                &lt;property name=&quot;connection.password&quot;&gt;tiger&lt;/property&gt;
                &lt;!-- 配置方言 通知hibernate访问哪种数据库的语法结构--&gt;
                &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt;
                &lt;!-- 类表映射文件 --&gt;
                &lt;mapping resource=&quot;hibernate/domain/Hero.hbm.xml&quot;/&gt;
        &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>

<h1 id="hibernate-properties">hibernate.properties</h1>

<pre><code>必要性
        不必须配置
位置：
        该文件的位置在src/目录下是不可以改变的，是hibernate加载配置的入口 

源码中的参考文件：
        /project/etc/hibernate.properties
                # oracle的通用驱动可以从hibernate3.jar/org.hibernate/dialect包中查找

作用
        1.配置连接的数据库，更换数据库只需要更改配置文件即可
        2.配置数据库方言
        3.其它控制开关

方言的作用
        更换数据库访问形式，实现通用性

内容
        hibernate.dialect org.hibernate.dialect.MySQLDialect
        hibernate.connection.driver_class com.mysql.jdbc.Driver
        hibernate.connection.url jdbc:mysql:///outrun
        hibernate.connection.username outrun
        hibernate.connection.password asdf
        hibernate.show_sql true                # 开关：显示实际操作数据库的sql语句
自动创建表
    hibernate.hbm2ddl.auto=create      # 每次都创建
    hibernate.hbm2ddl.auto=update      # 没有时再创建(有但是结构不同时会按照酌情增加列字段)
                                                                            ## 当更新或插入记录不满足条件时会出错
缓存
        hibernate.cache.provider_class                # 开启二级缓存中的普通区           
        hibernate.cache.use_query_cache                # 开启二级缓存中的查询区
</code></pre>

<h1 id="hibernateutil">HibernateUtil</h1>

<pre><code>目的
        对SessionFactory返回Session的方式进行了重构，通过调用该静态工具方法
        实现只有一个SessionFactory实例，由它产生和销毁很多Session的工厂机制。

缓存
        SessionFactory 是二级缓存
        Session 是一级缓存
                # 查询时，先在二级缓存中查找，没有数据时查找一级缓存，最后查询数据库
                # 缓存中的数据会用镜像联系着数据库，如果数据库有更新，缓存中的数据会自动更新

SessionFactory对象与Session对象
        SessionFactory:只创建一次，重量级对象，线程安全，可以共享，实例变量，开始时创建 
        Session:创建多次，轻量级对象，线程不安全，不可以共享，局部变量，临时创建 


实现代码
/**
* 提供hibernate session 
* 并且用threadLocal跟踪实现无参删除
* 
* @author Administrator
*
*/
public final class HibernateUtil {
        // 单例的SessionFactory工厂 
        private static SessionFactory sessionFactory;
        // 单例的ThreadLocal&lt;Session&gt;实例，但是每个调用者都有自己独有的方法？
        private static ThreadLocal&lt;Session&gt; threadLocal;
        /**
        * 解析配置文件（properties,xml）到hibernate 的配置JavaBean,常驻内存
        * 
        */
        static{
                // 在这里加载了hibernate.properties配置文件（这里可以配置数据库），执行其它配置
                // 相当于jdbc中的DriverManager类（如果配置了数据库，相当于也注册了连接数据库的类文件 【Class.forName(&quot;..Driver&quot;)语句 ..Driver 新建实例的时候自动向DriverManager注册自己】）
                Configuration config = new Configuration();
                // 这里写xml配置文件对于src/目录的相对路径,加载映射用xml文件
                config.addResource(&quot;hibernate.hbm.xml&quot;);
                // 加载src/目录下的hibernate.cfg.xml配置文件
                config.configure();                # configure(&quot;classpath:hibernate.cfg.xml&quot;);
                                                                        1.configure方法中可以加路径
                                                                        2.classpath:代表src/目录
                // 导入org.hibernate.SessionFactory类而非org.hibernate.classic.SessionFactory类
                sessionFactory = config.buildSessionFactory();
        }
        /**
        * 从单例工厂中得到被跟踪定位(每个调用者)的Session对象,没有就创建
        * 
        * @return
        */
        public static Session getSession(){
                /* 根据不同的调用者返回跟踪的不同的Session对象,如果是第一次调用，就创建新的session，绑定到单例的ThreadLocal对象中记录，返回给调用者
                * 如果不是第一次调用 ，也能返回让其得到原来为它创建的Session对象 
                */ 
                Session session = threadLocal.get();
                if(session == null){
                        session = sessionFactory.openSession();
                        threadLocal.set(session);
                }
                return session;
        }
        /**
        * 删除调用者在ThreadLocal实例中的跟踪记录，并且关闭该Session实例
        * 
        */
        public static void closeSession(){

                Session session = threadLocal.get();
                if(session != null){
                        session.close();
                        threadLocal.remove();
                }
        }
}
</code></pre>

<h1 id="hql">hql</h1>

<pre><code>hql特性
    1.hql是hibernate专用，有专用的技术转换hql到sql,但降低效率
    2.hql完全面向对象,只出现类，属性，操作符和关键字,例如sum(),order by
            而sql是面向关系的语言
使用语句
        Query query = session.createQuery(hql);
        Customer c = (Customer)query.uniqueResult();        # 只返回一条结果
        List&lt;Customer&gt; list = query.list();                        # 返回多条结果

常用 api
        session.createQuery()
        session.getNamedQuery()                # 从映射文件中加载&lt;query&gt;标签配置的与&lt;class&gt;标签同级的hql语句
        query.setString(&quot;&quot;,&quot;&quot;)
        Object o = query.uniqueResult();
        List list = query.list();
        分页
                query.setFirstResult(0);        # 开始标号
                setMaxResults(3);              # 最多显示的条数

query语句                习惯用别名替代类名
                # from后面出现的是类名，where中比较的是对象属性（已经在映射文件中映射到了表名与字段名）
        占位符
                冒号占位符
                        &quot;from Customer c where c.name = :cname&quot;
                        query.setString(&quot;cname&quot;,&quot;司马懿&quot;);
                问号占位符
                        &quot;from Customer c where c.name = ?&quot;
                        query.setString(0,&quot;司马懿&quot;);
        映射文件中分离hql语句
                        # &lt;query&gt;标签与&lt;class&gt;标签同级
                &lt;Query name=&quot;findCustomerByAge&quot;&gt;
        &lt;![CDATA[
            from Customer c where c.age &lt; ? 
        ]]&gt;
        Query query = session.getNamedQuery(&quot;findCustomerByAge&quot;);
        query.setInteger(0,60);
        查询
                &quot;from Customer where id = 1&quot;
            &quot;from Customer as c where c.name = '司马懿' &quot;
            &quot;from java.lang.Object&quot;    # 映射中没有，写类的全称。查找 src/hibernate.cfg.xml中加载到内存中的映射的类对应的表中的所有记录
            &quot;from Order o order by o.price desc&quot;
                投影查询
                        1.&quot;select c.name,c.age from Customer c &quot;
                        List&lt;Object[]&gt; list = query.list();        # Object[]中存储的是查询的select 语句中的数值
                        for(Object [] o : list){
                System.out.println(o[0]);
                System.out.println(o[1]);
            }
            2.&quot;select count(o), sum(o.price),min(o.price) from Order o&quot;                # count()中的是表类名，统计实例数，查询Order表记录对象的个数 
            3.&quot;select o.customer.id from Order o&quot;
用到过的hql
        级联抓取
                FROM Role r LEFT JOIN FETCH r.privilegeSet WHERE r.id = :id
        级联抓取顶级权限表（去重复）
                SELECT DISTINCT p FROM Privilege p LEFT JOIN FETCH p.childrenSet WHERE p.parent IS NULL
        级联抓取角色        
                FROM Account a LEFT JOIN FETCH a.roleSet WHERE a.id = :id
        三级级联抓取                # 对抓取的集合也可以直接抓取下一层
                FROM Account a LEFT JOIN FETCH a.roleSet r LEFT JOIN FETCH r.privilegeSet WHERE a.login = :login AND a.pass = :pass
</code></pre>

<h1 id="案例">案例</h1>

<pre><code>编码
    hibernate用用户操作系统的编码作为自己的编码

    mysql5.5中设置编码：根目录下my文件 default-character-set=gbk
</code></pre>

<h1 id="查询">查询</h1>

<pre><code>hibernate的查询方式
    1.session.get(字节码,1)
    2.session.load(字节码,1)
    3.HQL查询session.createQuery()        session.getNamedQuery()        # 后面是从配置文件中载入hql语句
    4.对象导航，如多表映射中
            # 以对象的形式操作数据库中的表，如
                ## p是person表的一个对象，c是card（身份证表）表的一个对象，p通过配置外键时定义的属性card得到自己的身份证表对象
                ## 1.从表对象中：Card c = p.getCard();
                ## 2.从hql语句中：select o.customer.id,o.customer.name,sum(o.price) from Order o group by o.customer.id
        5.createSQLQuery原生sql语句查询：        # 不要用，用了以后 hibernate跨平台的特性就没有了
                String sql = &quot;select {a.*} from sysgroup {a} where department regexp ?&quot;;
                Query query = session.createSQLQuery(sql).addEntity(&quot;a&quot;,SysGroup.class);
                        # addEntity将表的别名与类字节码关联起来（否则返回的表字段数据是Object类型,jsp页面读取时会出错）
连接查询的hql语法
                # 只能连接有外键关系的表类，用表类中的关系类来表示第二张表，不能用笛卡尔积查询
                ## 也就是说只能查一个表类
                注意
                        hql连接查询的语法中用where替代了sql语法中的on
                        外连接与 sql不同，只能查询与一个表类有关系的外连接表（from语句后面不能写两个表类）
        内连接
            from Customer c join c.orderSet o where c.id = o.customer.id
        外连接                # 这里与 sql不同，只能查询与一个表类有关系的外连接表
            select c.name,count(o.orderno) from Customer c left join c.orderSet o group by c.name;
        自连接
            select a.name, b.name from emp a, emp b where a.mgr=b.id;
</code></pre>

<h1 id="多表映射">多表映射</h1>

<pre><code>主控方                # 就是只有主控方的操作成立，非主控方的改变忽略
        inverse=&quot;true&quot;
                # false:主表管理，主表插入成功后，再发送n条更新语句来更新外键
        ## true:从表管理，自己插入时加上：自己javabean中存放的外键关联
            # 所以购物项中要关联购物车，由于购物车中已经一对多购物项，所以形成了双向关联
        有该属性的标签
                &lt;set&gt;
        缺少主控方出现的问题
                双向一对多中
                        1.hibernate生成的sql语句产生重复
                        2.主键冲突                # 插入操作时，由于“一”表级联插入“多”表，“多”表也要插入自己，它们的主键是相同的，会引起主键冲突

级联                # 数据库只有级联删除
        cascade=&quot;save-update&quot;  # 插入和更新
                        # 一般使用save-update，因为表一般软删除，（更新也没有，因为主键不更新，但是hibernate没有单save）
    cascade=&quot;delete&quot;;  # 删除订单，级联删上层客户
    cascade=&quot;none&quot;  # 什么都不做（默认）
    cascade=&quot;all&quot;  # save-update + delete
        有级联属性的标签
                class标签下的
                        &lt;set&gt;
                        &lt;one-to-one&gt;
                        &lt;many-to-one&gt;
        注意
                级联插入的子表的id内容要为空，否则会变成级联更新                # 这里和单个数据插入时设置对象的id属性不起作用【只有hibernate的主键增长策略起作用】是不同的

单向一对多                        # 集合映射的一种
        “一”的类中
                private Set&lt;Order&gt; orderSet = new LinkedHashSet&lt;Order&gt;();
        映射xml文件中
                &lt;!-- set标签用于映射单向一对多 
                    name表示单方的关联属性
                    table表示多方对应表的名字
                    key-column表示多方对应表的外健
                    one-to-many-class表示单方关联属性中的每个元素的类型
                --&gt;
                &lt;set name=&quot;orderSet&quot; table=&quot;ORDERS&quot; cascade=&quot;all&quot;&gt;
                        &lt;key column=&quot;CUSTOMERS_ID&quot;/&gt;
                        &lt;one-to-many class=&quot;Order&quot;/&gt;
                &lt;/set&gt;
单向多对一                        # 常用
        映射xml文件中
                &lt;!--
                many-to-one映射多方的关联属性
                name表示多方的关联属性名
                column表示多方对应表的外健(存储关联类对应表的主键)
                cascade 级联
                lazy表示“一”的类数据是否在一开始的时候就查询                # 如果lazy=&quot;proxy&quot;【相当于懒加载】，action类中加载“一”方数据时会出错，因为调用service类结束后线程中的session销毁,延迟加载找不到session会失败
                fetch表示抓取策略
                                # 这里产生了hibernate的n+1问题：一条查询语句查出&quot;一&quot;的集合，n条查询语句查出集合中每个元素的一
                        join代表用join语句查询(一条语句),但是hibernate在多对一的时候不支持fetch=&quot;join&quot;
                        默认是select，每次查询用一条select语句（多条语句）
                                解决：自己写新的查询方法查询,执行hql如：FROM Category c LEFT JOIN FETCH c.account
                --&gt;
                &lt;many-to-one 
                        name=&quot;customer&quot; 
                        column=&quot;CUSTOMERS_ID&quot; 
                        cascade=&quot;all&quot;
                /&gt;

双向一对多  # 双向映射就存在主控方的问题  
                ##　主表从表（外键【可以为空】）        
                ## 集合映射的应用
        1.同时配置单向一对多与单向多对一
        2.在&quot;一&quot;表中配置inverse=&quot;true&quot;,反转权力，“多”表为主控方
双向一对一      # 主表从表（从表id既是主键又是外键）
                ## 双方都是主控方 
    1.两表都配置&lt;one-to-one/&gt;
    2.主表配置cascade
        3.从表中constrained=true属性（主键是否同时为外键约束）

多对多（单向左到右，单向右到左，双向）                # 集合映射的应用
                                                                ## 多对多关系中一定要有主控方，否则主键冲突问题
        1.创建中间表  
                        # 中间表可以没有自己的JavaBean类文件对应，这时默认有联合主键（联合主键分别是保存的两个外键）
                students_id
                teachers_id 
                        # student_id 与 teachers_id为联合主键
            ## sql语句是primary key(student_id,teacher_id);
                创建中间表原因：
                        之所以中间表是因为两边的表中主键唯一，所以不能在一个记录中对对应另一个表的多个记录
                        中间表相当于把多对多分成两个一对多。
        2.表对象类中都有对方表的set集合 
        3.映射xml中      # 可以用inverse,cascade
                                ##  cascade=&quot;none&quot;时,middle表中的记录也会被删除
                ## 不配置主控方的话一边更新另一边，另一边也更新自己，会出错
        &lt;set table=&quot;MIDDLES&quot; name=&quot;teacherSet&quot;&gt;
            &lt;key columnet=&quot;STUDENTS_ID&quot;/&gt; 
            &lt;many-to-many class=&quot;Teacher&quot; column=&quot;TEACHERS_ID&quot;/&gt;
        4.dao中
                在cascade=&quot;all&quot;的配置下实现只删除老师与middle表中的教学关系          # 手工解除关系
                        # 不手工解除关系的话， 表记录对象：Teacher t1
                                ，t1删除时,级联删除middle表中数据，middle表中对应了学生的外键
                                ，由于多对一级联，会删除学生，由于该学生的主键可能会被middle表中的其它记录作为外键引用，所以不能删除，删除时会出错。 

                查询1号老师对应的学生,并解除关系 
                        Teacher t1
                        for(Student s: t1.getStudentSet()){
                            s.getTeacherSet().remove(t1);
                        }
                        1号老师解除关系
                        t1.setStudentSet(null);
                        session.delete(t1);
</code></pre>

<h1 id="缓存">缓存</h1>

<pre><code>缓存        
        1.一级缓存(session)中的数据是独享的，二级缓存(sessionFactory)中的数据是共享的
        2.一级缓存中的数据改变时会更新二级缓存(如果二级缓存设置为read-only时，会更新出错)
        3.二级缓存默认不能存po(持久化对象) ，只存放连接数据库的信息和映射文件 
                # 这时查询数据时的顺序是 一级缓存 -&gt; 数据库

启用二级缓存                # 开启的二级缓存中可以保存po
                                ## 二级缓存的两个空间：普通缓存区(get、load)、查询缓存区(query对象查询)
        普通缓存区
        hibernate.properties文件中配置
            hibernate.cache.provider_class 
                    org.hibernate.cache.HashtableCacheProvider                # 只能内存缓存
                    org.hibernate.cache.EhCacheProvider                                # 也能磁盘缓存ehcache的jar包中ehcache-failsafe.xml配置文件中可以查到默认缓存配置
                                                                            # 可以在hibernate的中文官方教程中查到缓存策略提供商的类
                                                                            ## hibernate3.2之前缓存类jar包是集成的，默认是EhCache
                                                                            ## hibernate3.2之后缓存类jar包要自己导入
                                                                            ## ...Provider类并不是实现类，而是桥接类
            cache.use_second_level_cache
                    true                                                # 开启二级缓存（默认是true,但是没有配置缓存提供商之前不开启）
        hibernate.cfg.xml文件中配置使用二级缓存的类              # 可以设置&lt;cache&gt;的标签&lt;class&gt;&lt;set&gt;
                                                                                        ## 设置&lt;set&gt;时，set对应表类的也要设置&lt;cache&gt;标签
                &lt;class-cache usage=&quot;read-write&quot; class=&quot;pojo.Goods&quot; /&gt;
                usage属性
                        read-only：二级缓存只读(只是不能进行修改，但是从表中读取数据时一级缓存可以向二级缓存中放入数据)
                        read-write:可读写
        查询缓存区（hql语句）：默认不开启
                        # 因为hql命中率低(要求hql语句相同才行，模糊查询每次基本不同),每次查找会到缓存，找不到再到数据库，查询完数据再存入缓存，效率低
            ## 不配置的话查询还会存到缓存，但只提供get使用，hql自己不用
                1.首先开启普通缓存区（设置了表类可以缓存）
                2.在query对象中开启查询缓存区
                        query.setCacheable(true);
        查询顺序：一级缓存 -&gt; 二级缓存 -&gt; 数据库

缓存提供商配置
        ehcache缓存提供商
                创建src/ehcache.xml配置文件，使用ehcache缓存时会自动加载其中的配置
                        &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;        # 设置缓存目录，java.io.tmpdir指操作系统的临时目录
                        diskPersistent
                        diskExpiryThreadIntervalSeconds                # 这两个集群中使用，上面是是否集群持久化，下面是设置持久化时间
                        maxElementsInMemory                                        # 内存支持最大对象数目(溢出的对象会存到硬盘中)
                        overflowToDisk                                                # 内在到最大数目时是否缓存到硬盘
                        eternal                                                                # 缓存是否永久有效，如果为true，则timeToIdleSeconds与timeToLiveSeconds不起作用
                        timeToLiveSeconds                                        # 内存中缓存最大存活时间，服务器启动的时间加入其中
                        timeToIdleSeconds                                        # 缓存不被访问时最大存活时间
                        memoryStoreEvictionPolicy                        # 内存中对象的替换算法FIFO(先进先出first in first out) 
                                                                                                ## LRU(最近最未使用算法,最久没有被访问的对象踢出) 
                                                                                                ## LFU(最少未被使用算法,考虑了对象的访问频率,踢出最近最少被访问的对象)      
                                                                                                ## 是windows自己的替换算法
清空缓存
        一级缓存：session.clear();
        二级缓存：sessionFactory.close();
</code></pre>

<h1 id="集合映射">集合映射</h1>

<pre><code>作用
        集合包含于表类中，对应其一个属性，相当于该类对应表的一个子表
        每种集合对应一张表，内容对应记录。
        把java类中经常使用的数据结构对应到表中

使用
        javaBean（User）中
                private Set&lt;String&gt; telSet = new LinkedHashSet&lt;String&gt;();
                private List&lt;String&gt; cityList = new ArrayList&lt;String&gt;();
                private Map&lt;String,String&gt; telCityMap = new LinkedHashMap&lt;String,String&gt;();
        xml文件中
                &lt;set name=&quot;telSet&quot; table=&quot;TELS&quot;&gt;
            &lt;key column=&quot;USERS_ID&quot;/&gt;        # 外键列：集合所创建的表的外键列名
            &lt;element column=&quot;TEL&quot; type=&quot;string&quot;/&gt;      # 内容列：这里必需要有type 
                    # set中也可以把&lt;element&gt;标签换成&lt;one-to-many class=&quot;Order&quot;/&gt;标签来对应JaveBean作为值，这就是一对多的映射
        &lt;list name table&gt;
            &lt;key column/&gt;
            &lt;list-index column=&quot;IDX&quot;/&gt;      # 索引列：表中的索引号列(对应在list中的索引)
            &lt;element column type/&gt;
        &lt;map name table&gt;
            &lt;key&gt;
            &lt;map-key type column&gt;                        # map对应key的列
            &lt;element column type&gt;
        dao中使用
                user.getTelSet().add(&quot;131&quot;);
</code></pre>

<h1 id="检索策略">检索策略</h1>

<pre><code>hibernate检索的两种类型
        立刻检索:session.get,query.list        &lt;class lazy=&quot;true&quot;&gt;标签中类的检索策略，get方法与list都不遵循
        延迟检索:session.load      # 初始时是代理对象,使用时查询  只有load方法遵循&lt;class lazy=&quot;true&quot;&gt;标签中类的检索策略
            检索方法是load时
                lazy属性出现在&lt;class&gt;与&lt;set&gt;标签中,两个标签中lazy属性的含义是不同的，两个lazy属性都是对load方法执行时是否查询数据库进行设置。
                        # &lt;class&gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中除了set集合之外的所有属性
                        ## &lt;set&gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中set集合的数据
                        ## &lt;class&gt;中默认lazy属性的值为true
                        ## &lt;set&gt;中默认lazy属性的值为true
                true true 时    查类时没有查集合
                false true 时    查类时没有查集合
                false false 时    查类时查集合
                true false 时    查类时没有查集合
</code></pre>

<h1 id="经验">经验</h1>

<pre><code>删除的两种方法 
        session.delete(session.get(Category.class,id));    # 先查询再删除，效率低
    session.createQuery(&quot;delete Categroy c where c.id=:id&quot;).setInteger(&quot;id&quot;,id).executeUpdate();
                    # 执行hql语句，效率高

hibernate注解
        hibernate3.6支持注解
                javaee5不支持，默认关闭
                javaee6支持，默认开启，此时不加载注解配置文件会报错，所以要关掉
                        hibernate.cfg.xml中
                        &lt;property name=&quot;javax.persistence.validation.mode&quot;&gt;none&lt;/property&gt;

DB Browser反射编译表的生成映射文件和类的时候，会生成项目目录下hibernate.reveng.xml的临时配置文件，可以删掉

映射文件class属性
        dynamic-update=&quot;true&quot;                # 动态更新，只有对相同的session有效，而且性能不好
                                                                ## 用字段设置中的update=&quot;false&quot;（对象中有字段值时更新，没有时不更新）属性来设置动态更新
映射文件set标签属性
        Order-by=&quot;id&quot;                                # set中级联对象按照&quot;id&quot;属性进行排序
</code></pre>

<h1 id="c3p0">c3p0</h1>

<pre><code>c3p0并不是hibernate默认的连接池（默认的是hibernate自带的连接池算法）
        配置c3p0以后自动关闭Hibernate自带的连接池，而使用c3p0连接池


hibernate.cfg.xml文件中
        &lt;!-- 最大连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;20&lt;/property&gt; 
        &lt;!-- 最小连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;5&lt;/property&gt; 
        &lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;120&lt;/property&gt; 
        &lt;!-- 最大的PreparedStatement的数量 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;100&lt;/property&gt; 
        &lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--&gt; 
        &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;120&lt;/property&gt; 
        &lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;2&lt;/property&gt; 
        &lt;!-- 每次都验证连接是否可用 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/property&gt; 
hibernate.properties文件中
        hibernate.c3p0.min_size=5 
        hibernate.c3p0.max_size=20 
        hibernate.c3p0.timeout=1800 
        hibernate.c3p0.max_statements=50 
</code></pre>

<h1 id="映射">映射</h1>

<pre><code>hbm.xml
    位置与名称：
            domain.xx.java 文件同级目录 xx.hbm.xml

    约束文件位置
            hibernate3.jar/org/hibernate/hibernate-mapping-3.0.dtd
            从其中复制约束头

    源码中的案例文件
            \project\tutorials\中搜索 hbm.xml

    类-表映射的特点
            1.映射JavaBean到表字段（动态占位符），可以使用面向对象的hql语名生成sql语句
            2.session中保存类对象，缓存查询过的表的内容
            3.在映射关系的xml文件中可以设置主键的改变方式（这样以后dao类中设置的主键内容被配置文件中的设置覆盖）

    主键
            表中的主键
                    自然主键：有业务逻辑含义的字段（如name）（多个自然主键：联合主键）
                    代理主键
            hibernate中id的增加类型
                    increment  整型,不依赖数据库自增,多线程不安全
                uuid        缺点：占空间
                identity    整型，依赖数据库自增,线程安全
                sequence    专用于oracle数据库,要用特定名字的序列，create sequence hibernate_sequence;线程安全
                native(重点)    根据情况判断是identity或sequence
                assigned    自然主键：&lt;id name=&quot;name&quot; column=&quot;name&quot;&gt;,线程不安全
                composite-id    多个自然主键,表的javaBean必须实现序列化(1.对象序列化到硬盘、数据库【其它JavaBean有id属性，hibernate自动实现序列化】2.线程间传递数据)
                    &lt;composite-id&gt;&lt;key-property name=&quot;firstname&quot; column=&quot;firstname&quot;/&gt;&lt;key-property name=&quot;firstname&quot; column=&quot;lastname&quot;/&gt;

    持久化对象的两种类型
            实体型：具有id属性的类，映射成一条含有id主键的完整记录
            值类型或组件：与上面相反(被实体型包含)，如
                            # 包含以后会把组件的属性添加到实体类属性的后面，一起当作一张表，仅此而已
            # Address   
                province
                city
                area
            映射组件型属性
            1.类中引用组件：private Address address
            2.映射 &lt;component name=&quot;address&quot; class=&quot;Address&quot;&gt;&lt;property name column/&gt;
            3.dao中    star.setAdrress(address);
    内容
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE hibernate-mapping PUBLIC 
        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;        
    &lt;hibernate-mapping package=&quot;hibernate.domain&quot;&gt;
            &lt;class name=&quot;Hero&quot; table=&quot;heros&quot; dynamic-insert=&quot;true&quot;&gt;
                                    # 设置动态插入为true:如果是null的值，不再插入
                                    ## 如果不设定动态插入，会插入数据库null值，数据库中设定的默认值不会起作用
                    &lt;!-- hibernate通过自己内部的类型type=&quot;&quot;,来转换java类型与sql类型之间的转换，一般不必写，自动反射 --&gt;
                    &lt;!-- id 是指主键，property是属性 --&gt;
                    &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;
                            &lt;!-- hibernate内部的主键生成器 --&gt;
                            &lt;generator class=&quot;increment&quot;/&gt;
                    &lt;/id&gt;
                    &lt;property name=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;gender&quot; column=&quot;gender&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;des&quot; column=&quot;des&quot;&gt;&lt;/property&gt;
            &lt;/class&gt;
    &lt;/hibernate-mapping&gt;
javaBean
    实现序列化接口
            在有名为id属性的JavaBean中，hibernate会自动实现序列化接口
            没有名为id属性的JavaBean中，需要我们自己实现序列化接口

    public class Hero implements java.io.Serializable{
                private Integer id;
                private String name;
                private String gender;
                private Integer age;
                private Date birthday;
                private String des;
    }
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/hugo-blog/commit/527b54f06fb1e4192f7f9c86cfded0cda859d1b3" title='Last modified Jun 17, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Jun 17, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/hugo-blog/tree/master/content/docs/backend/hibernate.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#基本概念">基本概念：</a></li>
<li><a href="#优点">优点</a></li>
<li><a href="#特性">特性</a></li>
<li><a href="#目录">目录</a></li>
<li><a href="#加载顺序">加载顺序</a></li>
<li><a href="#使用">使用</a></li>
<li><a href="#session">session</a></li>
<li><a href="#hibernate-cfg-xml">hibernate.cfg.xml</a></li>
<li><a href="#hibernate-properties">hibernate.properties</a></li>
<li><a href="#hibernateutil">HibernateUtil</a></li>
<li><a href="#hql">hql</a></li>
<li><a href="#案例">案例</a></li>
<li><a href="#查询">查询</a></li>
<li><a href="#多表映射">多表映射</a></li>
<li><a href="#缓存">缓存</a></li>
<li><a href="#集合映射">集合映射</a></li>
<li><a href="#检索策略">检索策略</a></li>
<li><a href="#经验">经验</a></li>
<li><a href="#c3p0">c3p0</a></li>
<li><a href="#映射">映射</a></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
