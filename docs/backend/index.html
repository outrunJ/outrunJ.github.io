<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    
    后端
  
 | outrun的笔记</title>



<link rel="stylesheet" href="/book.min.1a0250256273fabf0f848ed9a3c50aae344d758339cad9725e656ac71546e6f5.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="https://example.com/docs/backend/index.xml" title="outrun的笔记" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">outrun的笔记</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f backend\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/project">项目</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/markup_language"><strong><em>标记语言</em></strong></a>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
<li><a href="/docs/architecture/nodejs">nodejs</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/principle">原理</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/javaweb">javaweb</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">pgsql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/linux_tool">linux工具</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a></li>
<li><a href="/docs/tool"><strong>图形工具</strong></a>

<ul>
<li><a href="/docs/tool/vim">vim</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
</ul></li>
<li><a href="/docs/management">管理</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/interview">题目</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    
    后端
  
</strong>
</header>

      
<article class="markdown">

<h1 id="名词">名词</h1>

<pre><code>dom                文档对象模型
dao                数据访问对象
ucs                unicode character set
utf                ucs Transformation Format
bmp                Basic Multilingual plane
bom                Byte Order Mark
asp                Active Server Pages
iis                Internet Information services
validate code                 验证码
tld                 tag library description
jsp                 java server page
xsd                XML Schemas Definition
suffix              后缀
ide                Integrated Development Environment
RIA                Rich internet Applications                富互联网应用（富客户端）C/S架构是胖客户端，B/S架构是瘦客户端。比如 flash就是ria(其它如js, SilverLight，unity3d，flash3d,adobe air,HTML5/css3，adobe Flex等)
JPA                Java Persistence API                        java持久层api
JDBC                Java DataBase Connectivity
DHTML                DynamicHTML
cvs                Concurrent Version System
svn                subversion
uml                UnifiedModelingLanguage
AJAX            Asynchronous JavaScript and XML
bnf                命令书写格式规范: 巴科斯范式
desc            description
capacity        容量
component       组件
association         联合
aggregation         聚合
composition         组合
alpha           开端
inherit         继承
dhtml           dynamic html ,是 html css 客户端script                        不是规范，是现有技术、标准的整合运用
css             Cascading Style Sheet   级联样式表
associated                交互的
perspective                视图
adapter         适配器
jit             just in time (compilation)
webdav          Web-based Distributed Authoring and Versioning        Web 分布式创作和版本管理 (WebDAV) 扩展了 HTTP/1.1 协议，允许客户端发布、锁定和管理 Web 上的资源
CMS             Content Management System        内容管理系统        它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。
constraint      约束
JSON            javascript object notation(标记)
OGNL            Object-Graph Navigation Language 对象图导航语言
jmf               java media frame java 媒体框架 是一个jar 包
dwr                Direct Web Remoting 是一个ajax框架。它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数，就像它就在浏览器里一样。
CXF                 apache的 Celtix + XFire,用于实现 web services的发布的使用
oa                Office Automation 办公自动化
dml                data manipulation language        数据操作语言
ddl                data definition language        数据定义语言
dcl                data control language                数据控制语言
ioc                inversion of control        控制反转（spring）
di                 dependence injection        依赖注入 （spring）
crud               增加(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete)
ssh                Secure Shell,由IETF制定，为建立在应用层和传输层基础上的安全协议。
pojo                pure old java object
oop                object oriented programming
aop                aspect oriented programming                面向切面编程
hdfs                Hierarchical Data Format        层次型资料格式（分布式存储）
ftp                File Transfer Protocol
ssl                Secure Sockets Layer 安全套接层。端口40
tls                Transport Layer Security 传输层安全(ssl的继任者)
https            Hypertext Transfer Protocol Secure 应用ssl作为应用层子层对数据进行压缩与解压。端口443
jsf                JavaServer Faces 是sun开发的web框架，相当于ssh(spring + struts + hibernate)
sns                Social Network Services        社会性网络服务
uml                Unified modeling language 统一建模语言
jta                java transaction api (hibernate中) java事务处理api
asm                Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。
                    汇编语言(Assembly Language)的扩展名
jsr                Java Specification Requests 是Java规范请求，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。jsr303:基于注解的java bean 验证
dto                data transfer object 数据传输对象
antlr             another tool for language recognition        一个开源的语法分析器
soap              simple object access protocol 简单对象访问协议
uefi              unified extensible firmware interface 统一可扩展固件接口
sso                single sign on 单点登录
erp                enterprise resource plan 企业资源计划
sap                Systems Applications and Products in Data Procession 企业系列软件(全世界排名第一的erp软件)
ssi                Server Side Include 服务器端嵌入
jmx                Java Management Extensions java管理扩展，是一个为应用程序、设备、系统等植入管理功能的框架。
jaas                Java Authentication Authorization Service Java验证和授权API
jca(J2C， J2CA)        Java Connector Architecture java连接器架构
jms                    Java Message Service java消息服务，用于在两个应用程序之间，或分布式系统中发送消息
jaf                    JavaBeans Activation Framework JAF是一个专用的数据处理框架，它用于封装数据，并为应用程序提供访问和操作数据的接口。JAF的主要作用在于让java应用程序知道如何对一个数据源进行查看、编辑和打印等操作。
jta                    Java Transaction API Java事务API,和jts为J2EE平台提供了分布式事务服务
jts                    Java Transaction Service java事务服务
scm                    Supply chain management 一种集成的管理思想和方法，执行供应商到最终用户的物流计划控制职能
ctr                    click-through-rate 网络广告
ioc/di                    inversion of control/ dependency injection
o2o                    online to offline 网站提供平台, 用户线下交易
cas                    central authentication service 单点登录
foobar                FTP Operation Over Big Address Records(RFC1545文档)ftp命令列表
modular              模块化
enumeration         计数
navigate            导航
fragment             碎片
posix                可移植的
intersection        截断
categories          类别
encounter           遭遇
recursion           递归
evaluate            评价
indent                缩进
collation         校对
schema              模式、图表
generate            生成
Presentation         描述
hierarchical         垂直分层
stereotype         策略
numerous            许多
KISS                keep it simple, stupid
cross-origin         跨域
CORS             Cross-Origin Resourse Sharing
NIH             not invented here 自己造轮子
mis                 management information system
crm                 customer relationship management
erp             enterprise resource planning
webRTC          web Real-Time Communication
</code></pre>

<h1 id="写法">写法</h1>

<pre><code>traits-decorator
        # js mixin
q
        # js 流程控制
co
        # js generator to async
async
        # js 流程控制
thunkify
        # js函数Thunk化, 确保回调调用一次
step
        # async轻量库
wind
        # js定义的宏
streamline
        # 基于源代码编译来实现流程控制简化
eventproxy
        # js event回调
spring
        # java ioc
guice
    # google的java ioc轻量框架
castle
        # .net ioc
spring.net
        # .net ioc
anko
        # go 代码解释器
antlr
        # java dsl
</code></pre>

<h2 id="ejb">ejb</h2>

<pre><code>特点
    分布式，j2ee一部分

组成
    会话bean(session)
    实体bean(entity)
    消息驱动bean(message driven)
</code></pre>

<h1 id="套件">套件</h1>

<h2 id="接口">接口</h2>

<pre><code>luavit
    # lua实现, 类node
scotty
    # haskell
webapi
    # .net
meteor.js
    # 基于node.js + mongodb的网站开发平台，把这个基础构架延伸到浏览器端, 本地和远程数据通过DDP(Distributed Data Protocol)协议传输
restify
    # 基于nodejs的rest应用框架，去掉express中的 template, render等功能, 提供DTrace功能，方便调试
ssh
    # java
spring site
    # spring整合
tapestry
    # 基于servlet的mvc框架
jersey
    # java restful服务
naga
    # java nio
echo
    # go
beego
    # go
gin
    # go，类express
iris
    # go, fasthttp的一种实现
tornado
    # python nio
web.py
twisted
    # event driven
flask
django
bottle
    # python wsgi
rails
    # ruby的web mvc开发框架
ror
    # ror(ruby on rails)
sinatra
    # 微型web
grape
    # 运行在rack或rails/sinatra配合使用的restful风格的ruby微框架
yii
    # php
laravel
    # php
codelgniter
    # php
</code></pre>

<h3 id="connect">connect</h3>

<pre><code>介绍
    nodejs处理http中req、res的中间件框架
    中间件分类
        pre-request用来改写request原始数据
        request/response功能各异
        post-response全局异常处理，改写response数据等
内置中间件介绍
    logger
    csrf
    compress             # gzip压缩
    basicAuth            # basic认证
    body parser          # 请求内容解析
    json
    urlencoded           # application/x-www-form-urlencode请求解析
    multipart            # multipart/form-data请求解析
    timeout
    cookieParser
    session
    cookieSession
    methodOverride       # http伪造
    responseTime         # 计算响应时间
    staticCache          # 缓存
    directory            # 目录列表
    vhost                # 虚拟二级域名映射
    favicon
    limit                # 请求内容大小限制
    query                # url解析
    errorHandler         # 错误处理
使用
    var connect = require('connect');
    var app = connect()
        .use(connect.logger('dev'))
        .use(function(req, res){
            res.end('hello world\n');
        })
        .listen(3000);
</code></pre>

<h3 id="express">express</h3>

<pre><code>安装
    npm install -g express-generator
    npm install express -d                        # g代表安装到NODE_PATH的lib里面, d代表关联套件一起安装
cookie-parser
    使用
        var cookieParser = require('cookie-parser');
        app.use(cookieParser());

        JSON.stringify(req.cookies);
        req.cookies.yourCookie
cookie-session
    使用
        var cookieSession = require('cookie-session');
        app.use(cookieSession())
        req.session = null

express-session
    options可选参数
        name                        # 表示cookie中保存session的字段名称，默认为connect.sid
        store                        # session的存储方式，默认存放在内存中，也有redis、mongodb、等模块支持
        secret                        # 设置secrect来计算hash放在cookie中产生signedCookie，来防篡改
        genid                        # 规定产生一个新的session_id时所用的函数，默认用uid2这个包
        rolling                        # 每个请求都重新设置一个cookie，默认为false
        resave                        # 即使session没有被修改，也保存session的值
    使用
        var session = require('express-session');
        app.use(session(options));

connect-redis
    使用
        var express = require('express');
        var session = require('express-session');
        var redisStore = require('connect-redis')(session);

        app.use(session({
            store: new redisStore(),
            secret: 'somesecrettoken'
        }));
serve-static
    # 静态文件
passport
    介绍
        登录验证中间件
        支持connect express sails等web框架
        支持Basic, Digest, OAuth(1.0和2.0的三种实现), Bearer等
    安装
        npm i passport
        npm i passport-local
    o-&gt; 配置
    var express = require('express');
    var cookieParser = require('cookie-parser');
    var session = require('express-session');
    var flash = require('express-flash');
    var passport = require('passport');

    ...

    app.use(cookieParser());
    app.use(session({...}));
    app.use(passport.initialize());
    app.use(passport.session());
    app.use(flash())

    passport.serializeUser(function (user, done) {
            done(null, user.id)
    })
    passport.deserializeUser(function (id, done) {
            User.findById(id, function (err, user) {
                    done(err, user)
            })
    })

    app.post('/login', passport.authenticate('local', {
            # passport.authenticate是个登录中间件，通过就走后面回调，否则返回401
            # local是自定义的名称
            successRedirect: '/',
            failureRedirect: '/login',
            failureFlash: true,
    }, function (req, res) {
            res.redirect('/users/' + req.user.username)
    }))

    app.post('/login', passport.authenticate('local', function(err, user, info) {
            if (err) return next(err)
            if (!user) {
                    req.flash('errors', {msg: info.message})
                    return res.redirect('/login')
            }
            req.logIn(user, function (err) {})
    })(req, res, next))
    app.get('/logout', function(req, res) {
            req.logout()
            res.redirect('/')
    })
    app.get('/user', isAuthenticated, getUser)
    var isAuthenticated = function (req, res, next) {
            if (req.isAuthenticated()) {
                    return next()
            }
            res.redirect('/login')
    }


    o-&gt; local验证
    var LocalStrategy = require('passport-local').Strategy
    passport.use(new LocalStrategy(
            function(username, password, done) {
                    User.findOne({username: username}, function(err, user) {
                            if (err) {return done (err)}
                            if (!user) {return done(null, false, {message: 'no user'})}
                            if (!user.validPassword(password)) {...}
                            return done(null, user)
                    })
            }
    ))

    o-&gt; usernameField
    passport.use(new LocalStrategy({
            usernameField: 'email',
            passwordField: 'passwd'
    }, function (username, password, done) {...}
    ))

    o-&gt; OAuth
    介绍
        第三方登录协议
        三个步骤
            1. 获取未授权的request token
            2. 获取用户授权的request token
            3. 用授权的request token换取access token
    使用
        网页上申请开发github应用
        npm install passport-github
            # 安装passport的github扩展
        // app.js
        passport.use(new GithubStrategy({        // 增加github认证策略
            clientID: 'XXXX',
            clientSecret: 'YYYY',        // 已从github上申请
            callbackURL: 'http://localhost:3000/auth/github/callback'
        }, function(accessToken, refreshToken, profile, done){
            done(null, profile);
        }));
        // 定义路由
        app.all('/github', isLoggedIn);
        app.get('/github', user.github);
        app.get('/auth/github', passport.authenticate('github', {scope: 'email'}));
        app.get('/auth/github/callback', passport.authenticate('github', {
            successRedirect: '/github',
            failureRedirect: '/'
        }));
kraken
    介绍
        基于express之上的基于设置结构化代码工具
    功能
        post请求_csrf验证

    基本用法
        'use strict'
        var express = require('express'),
            kraken = require('kraken-js');
        var app = express();
        app.use(kraken());
        app.listen(8000);
</code></pre>

<h3 id="koa">koa</h3>

<pre><code>介绍
    express原班人马打造的，更小，更健壮，更有表现力的web框架
    免除重复繁琐的回调函数嵌套，提高错误处理效率
    不绑定任何中间件，只是提供一个轻量优雅的函数库
    &gt;=node0.11.16
配置
    app.name              # 应用名称
    app.env                  # 执行环境，默认是NODE_ENV 或 'development'
    app.proxy              # 决定哪些proxy header被加到信任列表中
    app.subdomainOffset      # 被忽略的.subdomains列表
    app.jsonSpaces          # 输出json时是否填充空格
    app.outputErrors        # 是否输出错误堆栈(err.stack)到stderr(app.env是'test'时，此值为false)

使用
    $ npm install koa
    $ node --harmony app.js                        # 必需使用harmony模式运行程序
    var koa = require('koa');
    var app = koa();
    app.use(function *(){
        this.body = 'Hello World';
    });        # function*  声明的generator function支持yield
               ## yield是ES6定义的新语法
    app.listen(3000);
使用(downstream &amp; upstream)
    var koa = require('koa');
    var app = koa();

    // x-response-time
    app.use(function *(next){
    // (1) 进入路由
    var start = new Date;
    yield next;
    // (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间
    var ms = new Date - start;
    this.set('X-Response-Time', ms + 'ms');
    // (6) 返回 this.body
    });

    // logger
    app.use(function *(next){
    // (2) 进入 logger 中间件
    var start = new Date;
    yield next;
    // (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间
    var ms = new Date - start;
    console.log('%s %s - %s', this.method, this.url, ms);
    });

    // response
    app.use(function *(){
    // (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream
    this.body = 'Hello World';
    });

    app.listen(3000);

    this
        request
            header
            headers
            url
            accepts
        response
            header
            headers
            status
        cookies
            set('name', 'tobi', {signed: true})
                signed
                expires
                path
                domain
                secure
                httpOnly
            get
        type
        length
        path
        method
        state
        throw
        assert
    app
        use
        listen
        callback
        keys
        context
            db
中间件
    koa-router
    trie-router
    route
    basic-auth
    etag
    compose
    static
    static-cache
    session
    compress
    csrf
    logger
    mount
    send
    error
</code></pre>

<h2 id="实时">实时</h2>

<pre><code>sockjs
        # node websock
postal
        # nodejs 在内存上构建的发布订阅框架
pusher
        # 发布订阅模式socketio框架
juggernaut
        # 基于socketio
datachannel.io
        # 基于socket.io和html5 webRTC的实时聊天室框架
faye-websocket-node
        # 扩展faye项目开发的websocket的一个实现, 非常简单，而且不依赖其他库
websocket-node
        # 一个简单的websocket库，支持draft-10及之前的各种版本, 支持同样是node的c/s交互模式
ejabberd
        # 基于erlang/OTP 的xmpp im 开源框架
singalR
        # .net sock服务
nsq
        # go
openfire
        # java, 性能较差, 最多单机10w并发
webrtc
        # c++实现的web视频聊天
</code></pre>

<h3 id="socket-io">socket.io</h3>

<pre><code># 介绍
    socket.io: 基于任何浏览器, mobile设备的&quot;webSocket&quot;
# 安装
        npm install socket.io
# 使用
        var socketIo = require('socket.io');
        socketIo.listen(app).on('connection', function (socket) {                # require('socket.io')(app);
                                                                        ## var io = require('socket.io')(80);
        socket.emit('news', { hello: 'world' });
        socket.on('my other event', function (data) {
                console.log(data);
        });
        });
# api
    server
            io.on('connection', function(socket){});
            io.on('disconnect', function(){});
            socket.on('message', function(msg){});
    client-js
            socket = io.connect(url);
            socket.on('', function(json){});
            socket.send(json);
    io
            on('connection', function(socket){});
                    # disconnect
    socket
            on('disconnect', function(){ });
            socket.on('say to someone', function(id, msg){
                    socket.broadcast.to(id).emit('my message', msg);
            });
                    # Socket#id为内部指定的
    遍历用户
            var roster = io.sockets.clients('chatroom');
            roster.forEach(function(client){
                    console.log('Username: ' + client.nickname);
            });                        // 1.0之前版本可用
# 方案
    namespace
            server
                    var nsp = io.of('/my-namespace');
                    nsp.emit('hi', 'everyone!');                # ns广播
            client
                    var socket = io('/my-namespace');
    room
            server
                    socket.join('some room');
                    io.to('some room').emit('some event'):        # room广播
                    socket.leave('some room');
# 子模块
    socket.io-redis
        介绍
                用于从外部发消息，与socket.io-emitter一起使用
        使用
                var io = require('socket.io')(3000);
                var redis = require('socket.io-redis');
                io.adapter(redis({ host: 'localhost', port: 6379 }));
    socket.io-emitter
        介绍
                用于从外部发消息，与socket.io-redis一起使用
        使用
                var io = require('socket.io-emitter')();
                io.emit('time', new Date);
    socket.io-client
        介绍
                用于创建客户端来连接socket.io
        使用
                var iocl = require('socket.io-client');
                var socket = iocl.connect('127.0.0.1:5555');
                socket.on('connect', function(){

                });
</code></pre>

<h2 id="展示">展示</h2>

<pre><code>titles
    # java apache的标签库
</code></pre>

<h3 id="spring-mvc">spring mvc</h3>

<pre><code>原理
    DispatchServlet捕获请求
    解析url, 调用HandlerMapping映射到处理类HandlerExcutionChain, 根据Handler选择HandlerAdapter
    数据处理后，返回ModelAndView对象给DispatchServlet
        # ModelAndView是逻辑视图，DispatchServlet转化成视图View
    返回View
与struts2区别
    spring mvc方法对应请求, struts2是类
    spring mvc请求是方法调用，struts2创建Action实例
    spring mvc用aop处理请求，struts2用独有的拦截器(interceptor)
    spring mvc入口是servlet, struts2入口是filter
    spring mvc集成ajax(@ResponseBody), struts2需要插件
    spring mvc验证支持JSR303, struts2不支持
    spring mvc与spring无缝
    spring mvc不需要配置
注解
    @RequestMapping             # url映射
    @RequestBody                # 转换参数到对象
    @ResponseBody               # 返回对象转json

    开启注解处理器
        springmvc.xml
            &lt;mvc:annotation-driven&gt;
乱码问题
    post
        web.xml中配置CharacterEncodingFilter
    get
        tomcat配置文件修改项目编码
        new String(Request.getParameter(&quot;a&quot;).getBytes(&quot;ISO8859-1&quot;), &quot;utf-8&quot;)
</code></pre>

<h3 id="struts2">struts2</h3>

<pre><code># 基础
    介绍
        struts1和WebWork的发展
        引入值栈的概念     # 一次请求的参数和处理数据放在一个map结构中
    原理
        基于拦截器, 解耦servlet, 再提供自己的拦截器(interceptor)操作数据, 反射调用业务类
        FilterDispatcher通过配置文件来映射设置请求地址与处理类
            ActionMapper判断请求是否struts处理
            ActionProxy扩展实现方式(如web service)
            ConfigurationManager对应struts.xml配置文件
            ActionInvocation执行Action与拦截器
            Action处理请求，封装数据
                # Action是非单例的，效率低
    过滤器与拦截器
        过滤器基于回调，拦截器基于反射
        过滤器依赖servlet, 拦截器在struts中处理action

# 思想
    Action类中的无侵入设计（新技术中不出现旧技术）：map代替了作用域
        ActionContext actionContext = actionContext.getContext()
        actionContext.getApplication()
        actionContext.getSession()

        好处
            map是java中的api，不出现旧技术
            测试方便（ servlet不能测试，只能发布测试）
                # 注意：Action类中用到作用域map的方法也不能测试


# 结构
    apps: 例子程序
    docs:帮助文件
    lib:程序包
    src:源码
# 使用
    要求
        jdk5
        jsp2
        servlet api2.4

    导入核心的8个包
        struts2-core-2.3.1.1.jar        # struts的过滤器
        xwork-core-2.3.1.1.jar                # 验证工具
        freemarker-2.3.18.jar                # 标签
        javassist-3.11.0.GA.jar                # 动态代理
        commons-fileupload-1.2.2.jar
        commons-io-2.0.1.jar                # 文件处理
        commons-lang-2.5.jar                # 基础包
        ognl-3.0.3.jar                                # 表达式语言
    web.xml文件中配置过滤器
        &lt;filter&gt;
            &lt;filter-name&gt;struts&lt;/filter-name&gt;
            &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
        &lt;/filter&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;struts&lt;/filter-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;/filter-mapping&gt;
    写jsp页面，get或post路径为struts2的名称空间、扩展名，被配置的struts2过滤器处理
    写Action类（继承ActionSupport类）
    配置src/struts.xml文件与src/struts.properties文件，映射类、方法等到请求路径，映射返回字符串到任何方式


# 核心包：8个
    struts2-core-2.3.1.1.jar        # struts的过滤器
    xwork-core-2.3.1.1.jar                # 验证工具
    freemarker-2.3.18.jar                # 标签
    javassist-3.11.0.GA.jar                # 动态代理
    commons-fileupload-1.2.2.jar
    commons-io-2.0.1.jar                # 文件处理
    commons-lang-2.5.jar                # 基础包
    ognl-3.0.3.jar                                # 表达式语言

# 配置
    struts2以包的形式管理action 包名必须唯一，包里的每个action唯一
    使用步骤
        导入lib包
        写jsp
        编写Action方法
        web.xml中配置
            &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter
            &lt;url-pattern&gt;/*
        ../xx_struts.xml中配置请求响应
        src/struts.xml 中引入配置文件
            &lt;include file=&quot;cn/itcast/javaee/cal/cal_struts.xml&quot;/&gt;

    配置文件（配置包）路径
        重要路径：4个
            1./struts-default.xml[框架]
                # 是框架自带的abstract包（包括上传，下载，验证等），继承它以后可以用其中的功能
            2./org/apache/struts2/default.properties[框架]
            3.src/struts.xml # 必有
            4.src/struts.properties # 可选
        验证返回消息的配置文件
            struts2-core-2.3.1.1.jar包中的
                /org/apache/struts2/struts-messages.properties文件

    xml 中配置的简化
        *
            o-&gt; 只能在name 中写*_* 等
            o-&gt; 引用第一个* 用{1}        引用第二个用{2} 以此类推


    类路径
        com.opensymphony.xwork2.ActionSupport  默认关联到的类

    处理请求的扩展名配置
        # 扩展名配置只有一个会生效
        1./org/apache/struts2/default.properties
                struts.action.extension=action,,
                # 框架中初始的默认扩展名，最后的','代表了无扩展名
        2.src/struts.xml中
                &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do,,&quot;&gt;
                        # 必需配置
        3.src/struts.properties中
                        struts.action.extension=xx,yy
                        # 选择配置，优先级高

    默认配置
        struts2内置了请求字符串与基本类型的相互转换，不用手工转换

        /org/apache/struts2/default.properties文件中
                struts.i18n.encoding=UTF-8        # post方式请求响应的编码方式
                                                                        ## get方式的没有默认值，需要自己转码
                struts.action.extension=action,,  # 框架中初始的默认扩展名,最后的','代表了无扩展名

        每个&lt;package&gt;标签中配置
        &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; 为默认的拦截器

    src/struts.xml配置文件

    src/struts.properties配置文件

# 原理流程
    请求/qq.action -&gt; StrutsPreparedAndExecuteFilter（核心过滤器）-&gt; 匹配扩展名 -&gt; 匹配命名空间
        #（ 全限定名：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.class）
            -&gt; src/struts.xml                -&gt; name
                class
                method
            -&gt; name
                type
                内容
            -&gt; 响应
            -&gt; 拦截器 -&gt; ConfigAction类

        # 1.部署时读取src/struts.xml和src/struts.properties文件，形成JavaBean对象
                # 两个文件同时存在时src/struts.properties文件为准
        ## 2.请求/*路径时，StrutsPreparedAndExecuteFilter过滤
        ## 3.获取JavaBean中的actionName ,actionClass, actionMethod, 执行方法
        ## 4.执行的返回值与resultName, resultType, resultContent进行比较
        ## 5.按resultType类型返回resultContent（路径和内容）

# 缺点
    8个jar包，慢，servlet 快
    配置繁琐
# 编码
    struts2默认编码方式:utf-8

    返回的图片相对路径中有中文时设置tomcat
        tomcat/conf/server.xml
            &lt;Connector port=&quot;8080&quot; .. URIEncoding=&quot;utf-8&quot;/&gt;

        这时点击下载的请求路径中有中文时在以post方式提交 ,struts自动转码。若以get方式提交，需要在Action类的相应的get方法中转换url编码（iso8859-1）到u8

        原理
                改了tomcat的内部编码以后，struts中的编码是u8，放在session 中，jsp支持u8,解释后发送的html中的编码没问题，查看没问题。
                下载post发送请求，浏览器请求的是url编码的u8,struts中也是u8执行下载

                如果不改编码，struts 中是u8,如果以List方式放入session的话,session存储的是u8
                如果直接放入数据的话,session中存储的是8859-1,jsp取出数据需要转码为u8并设置自己的编码是u8,再发送给浏览器。
                浏览器这时获取图片正常,post方式提交的是u8,经过tomcat转换为8859-1,struts中自动转换编码到u8
                如果是以get方式提交请求，get中的中文在浏览器时进行url编码到8859-1,经过tomcat，再到struts,struts不对get方式的请自动进行转码
                向action类中注入参数时是8859-1编码,需要手动在action类中的属性的get方法中进行8859-1到u8的转码操作
# 内置对象
    struts中的6个内置对象
        # request请求进入struts中时创建，request请求结束时销毁。
        requestMap
        sessionMap
        applicationMap
        parameters
        attr                        # page -&gt; request -&gt; session -&gt; application 的顺序查找
        valueStack                # 定义实例变量，直接放入valueStack的 list（栈） 中,map（值）很少向内存储数据
            # 定义的实例变量必须提供相应的get方法,否则ognl标签中取其数据时没有方法调用，就得不到它的值
            # list 中的值优先访问 ，但是map 中的值起决定作用
            # map中存放着一个大map,其中注入了所有页面的请求信息
                # requestMap sessionMap applicationMap 并不是真正的域对象，但最后通过拦截器放入到域对象中

# 异常处理
    配置src/strut.xml 文件
        &lt;global-results&gt; 全局结果（用来跳转全局异常等）
        &lt;global-exception-mappings&gt; 全局异常
        &lt;exception-mapping result=&quot;nullJsp&quot;        exception=&quot;java.lang.NullPointerException&quot; /&gt;
            # &lt;action&gt;标签中的局部异常
            ## &lt;action&gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&quot;nullJsp&quot;的字符串交给本&lt;action&gt;标签中相应的&lt;result&gt;标签来处理


    处理机制
        o-&gt; 多个异常时走子异常，父异常被忽略
        o-&gt; 先处理小范围异常，大范围忽略
        o-&gt;  如果异常没有处理，抛出到web服务器处理,web.xml的&lt;error-page&gt;&lt;error-code&gt;&lt;location&gt;
    全局异常
        xml文件中
            &lt;global-results&gt;
                &lt;result name=&quot;error&quot;&gt;
                    /error.jsp
                &lt;/result&gt;
            &lt;/global-results&gt;
            &lt;global-exception-mappings&gt;
                &lt;exception-mapping result=&quot;error&quot; exception=&quot;java.lang.Exception&quot;/&gt;
            &lt;/global-exception-mappings&gt;
        error.jsp页面中
            &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;
            异常信息：&lt;s:property value=&quot;exception.message&quot;/&gt;&lt;br/&gt;
            详细信息：&lt;s:property value=&quot;exceptionStack&quot;/&gt;&lt;br/&gt;


# 转递方式
    chain                        # action类之间转发
    dispatcher                # 转发到jsp
    freemarker
    httpheader
    redirect                # 重定向到页面
    redirectAction        # action 类之间重定向
    stream                        # 返回 InputStream流
    velocity
    xslt
    plainText
# Action类
    注意
        1.所有Action类都要继承ActionSupport类，否则execute方法返回的字符串不会回到struts拦截器再根据xml文件的配置进行转发
        2.action类是非单例的。        # 所有多实例的对象全部是因为有私有属性，否则全部应该是单例的
        3.action类放在栈的顶端，用于注入数据

    传统方式得到request,response,servletContext,pageContext
        ServletActionContext.getPageContext()
        HttpServletRequest request = ServletActionContext.getRequest()
        ServletActionContext.getResponse()
        ServletActionContext.getServletContext();

    优势
        实现与servlet的解耦

    验证
        验证分类
                前台验证：javascript等
                后台验证：服务器
        struts2验证
                    后台验证
            1.代码式验证
            2.声明式验证:xml文件

    ActionContext类
        调用方法
        ActionContext actionContext = ActionContext.getContext();
        得到内置对象        # 这几种得到作用域的方法均可以得到作用域中原有的值，也可以放入值
        request
                actionContext.put(&quot;&quot;,&quot;&quot;);
        application
                Map&lt;String,Object&gt; applicationMap = actionContext.getApplication();
        session
                Map&lt;String,Object&gt; sessionMap = actionContext.getSession();
                        # 或 actionContext.get(&quot;session&quot;)得到，因为actionContext中存储着大map
        parameters
                Map&lt;String,Object&gt; parametersMap = actionContext.getParameters();
        valueStack
                ValueStack valueStack = actionContext.getValueStack()
                valueStack.getRoot()                        # 得到当前值栈的顺序

    参数
        1.action类中可以直接创建属性与其get方法得到客户端get方法或post表单请求的参数(由struts2自动注入)
        2.action类中可以创建 JavaBean的属性来接收struts注入的参数，这时用户请求的参数名字要写成JavaBean名.JavaBean中的属性名（这样struts2会自动调用JavaBean的set方法来注入其中相应的参数 ）
## BaseAction
    作用
        权限管理
        存放常驻内存数据
        抽取常用的方法
# web.xml配置
    &lt;filter&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;filter-class&gt; org.apache.struts2.dispatcher.FilterDispatcher &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;struts.action.extension&lt;/param-name&gt;
            &lt;param-value&gt;do&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;url-pattern&gt;*.json&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
        # 设置全局过滤器，并且修改过滤扩展名
# default.properties
    src/struts.properties配置文件
        struts.custom.i18n.resources=struts    # 使自己的普通配置生效。如：/org/apache/struts2/struts-messages.properties文件的
            ## struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} &quot;{1}&quot; &quot;{2}&quot; {3}  属性，&quot;{1}&quot; &quot;{2}&quot; &quot;{3}&quot;是显示消息的占位符
            ## struts.action.extension=action,,可以不配置
            # 由于只加载properties文件，所以省略.properties
            ## =后面的是相对于src目录的文件
# ognl标签
    注意
        # jquery中不能定位ognl标签，而要用标签自己生成的id定位（看源码得到）
    使用：
        &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt;
        tld映射文件路径
            struts2-core-2.3.1.1.jar包中
            /META-INF/struts-tags.tld

    '#'出现的地方
        o-&gt; 除ValueStack 之外的所有struts内置对象的取值前面都要加
        o-&gt; 取JavaBean中的属性时要加 '#'，如&quot;#user.username&quot;,ValueStack中也不例外
        o-&gt; 构造Map对象，Map：#{'male':'[男]','female':'[女]'}，构造radio和select标签，如
                        # &lt;s:radio list=&quot;#{'male':'aa','bb':'cc'}&quot; name=&quot;gender2&quot; /&gt;
        o-&gt; 迭代数组或list集合
            集合的投影：userList.{username}
            集合的过滤：userList.{?#this.age&gt;22}

    主题与模板
        主题：为多个模板提供风格
            struts2-core-2.3.1.1.jar包中
                template中的四个主题
                    archive                # 其中是.vm文件，其它是.ftl文件。vm与ftl是两种视图技术
                        ajax        # 除此之外其它都不支持ajax
                        simple
                        xhtml
                    xhtml                # 默认主题,default.properties配置文件中定义
                    css_xhtml
                    simple
            修改主题
                1.struts.properties 中修改
                    struts.ui.theme=simple          # 针对当前webapp
                2.&lt;s:form theme=&quot;xhtml&quot;&gt;            # 只针对当前表单
                3.&lt;s:textfield name=&quot;username&quot; theme=&quot;simple&quot;&gt;  # 修改某个标签的属性
        模板：为标签提供样式
                做模板的技术freemarker

    ognl标签的优点：自动排版、验证数据回显、国际化

    所有标签：
        逻辑标签
            对 Map 集合的迭代：
                &lt;s:iterator value=&quot;#session.fileMap&quot; var=&quot;entry&quot; status=&quot;stat&quot;&gt;
                    &lt;s:property value=&quot;#entry.key&quot;/&gt;
                &lt;s:if test=&quot;#stat.count%4==0&quot;&gt;&lt;/s:if&gt;
                &lt;/s:iterator&gt;
            对 List 集合的迭代  List&lt;User&gt; userList
                普通迭代
                    &lt;s:iterator var=&quot;user&quot; value=&quot;userList&quot;&gt;      # 投影语法List&lt;user&gt;中的所有username
                    &lt;s:property value=&quot;#user.username&quot;/&gt;
                        投影语法
                    &lt;s:iterator var=&quot;username&quot; value=&quot;userList.{username}&quot;&gt;
                    &lt;s:property/&gt;                        # 这里不用写属性value=&quot;username&quot;就可以对page域中的username进行显示
                过滤语法
                    &lt;s:iterator var=&quot;user&quot; value=&quot;userList.{?#this.age&gt;9}&quot;&gt;
                        # this代表当前被迭代的元素 ?#是所有 ^#是第一个 $#是最后一个  ?#...[0]按标记取
                    &lt;s:property value=&quot;#user.username&quot; /&gt;
        显示标签（UI标签）
            普通字符串中使用ognl
                jsp中用%{}      xml中用${}
                例如
                jsp中：&lt;s:textfield label=&quot;%{#attr.testValueStack}&quot;/&gt;
                xml中：&lt;param name=&quot;min&quot;&gt;4000&lt;/param&gt;
                                            &lt;message&gt;${min}&lt;/message&gt;
            普通信息
                &lt;s:text name=&quot;&quot;/&gt;
            输出值
                迭代器中
                        &lt;s:property/&gt;        # 直接输出被迭代的内容（简单）
                        &lt;s:property value=&quot;aa&quot;/&gt;
                        &lt;s:property value=&quot;#aa&quot;/&gt;
                普通
                        &lt;s:property value=&quot;username&quot;/&gt;      # 输出标签,得到valueStack中属性
                        &lt;s:property value=&quot;#request.name&quot;/&gt;                # 得到request域对象中的值
                                # request #session #application #parameters #attr
                                # '#attr'优先级：page,request,valueStack,session,application
            显示验证拦截器的验证信息集合中的数据：
                &lt;s:fielderror/&gt;                                                        # 显示所有错误信息
                &lt;s:fielderror fieldName=&quot;&quot;/&gt;                        # 显示验证返回的错误信息
            单选
                &lt;s:radio list=&quot;#{'male':'男','female':'女'}&quot; name=&quot;gender2&quot; value='男'&gt;
                                # 自动加class id &lt;label for=&quot;gender2male&quot;&gt;等
                                # list键值对中male是实际值,男是显示值
                                # name是&lt;input radio &gt;的name属性
                                # value中是选中的项
            多选
                &lt;s:select multiple=&quot;true&quot; list=&quot;#{'bj':'北京','sh':'上海','gz':'广州'}&quot; name=&quot;select1&quot; value=&quot;{'sh','bj'}&quot;/&gt;
            表单                        # 在ognl的标签中， struts的验证消息自动回显，不用加&lt;s:fielderror/&gt;标签
                &lt;s:form action=&quot;&quot;&gt;                # 默认中加上了 method=&quot;post&quot; action中加上了当前网站了contextPath路径
                        &lt;s:textfield label=&quot;用户名&quot; name=&quot;username&quot; /&gt;
                        &lt;s:password label=&quot;密码&quot; name=&quot;password&quot; /&gt;
                        &lt;s:submit value=&quot;登录&quot; /&gt;
            国际化                # 国际化一般放在整个网站的最后写
                                ##　伪国际化：将不同语言的页面放在不同文件夹中分别访问
                        # 国际化是通过i18n拦截器实现的
                1.创建国际化信息文件
                        message_zh_CH.properties      # 基名_语言名_国家名.properties
                                username=xxx
                                password=xxxx
                                submit=xx
                        message_en_US.properties
                        ..
                        message.properties                # 默认的显示语言
                                # 找伊拉克没有的话找本地区语言，本地语言没有的话找其它(默认的或美国等)
                2.struts.properties中引入国际化配置的属性文件
                        struts.custom,i18n.resources=struts2/tag/i18n/message        # 从src文件夹路径开始，只写基名
                3.验证消息国际化
                        message.properties文件中配置属性validationRequiredUsername=用户名错误
                        validation.xml文件中
                        &lt;message key=&quot;validationRequiredUsername&quot;&gt;&lt;/message&gt;
                4.jsp文件中用key属性代替 label属性(或其它在页面上显示信息的属性),key中写国际化信息文件中的key
                        &lt;s:form action=&quot;taglogin&quot;&gt;
                                &lt;s:textfield key=&quot;username&quot; name=&quot;username&quot; /&gt;
                                &lt;s:password key=&quot;password&quot; name=&quot;password&quot; /&gt;
                                &lt;s:submit key=&quot;submit&quot;/&gt;
                        &lt;/s:form&gt;
                5.普通信息的国际化
                        message.properties中配置属性 normalMessage:普通信息
                        jsp中&lt;s:text name=&quot;normalMessage&quot;/&gt;
                6.测试
                        intername选项 -- 语言 改地区访问

    xml文件中的ognl标签
            o-&gt; ${aa}
                    1.调用转到该标签类的getAa()方法得到aa的值替换${aa}
                    2.本标签中name=&quot;aa&quot;的标签的文本节点的内容
            o-&gt; {1}{2}{3}..{n}
                    匹配本标签中name=&quot;*a*&quot; 中的第n个‘*’,用于通配传递过来的参数的一部分的值
# ognl表达式
    ognl 开源，java写的免费标签,是struts2特有的

    xml文件中
        ${Xxx}                取值栈中栈中的东西，如action类中的属性
        ${#Xxx}                取值栈中值的东西，如request,session域中的数据（其实就是老师说的内置对象【valueStack就是值栈】）

    jsp文件中
        &lt;s:iterator value=&quot;#session.fileMap&quot; var=&quot;entry&quot; status=&quot;stat&quot;&gt;
            &lt;s:property value=&quot;#entry.key&quot;/&gt;
            &lt;s:if test=&quot;#stat.count%4==0&quot;&gt;&lt;/s:if&gt;
        &lt;/s:iterator&gt;
# strut.xml配置
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE struts PUBLIC
            &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
            &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;

    &lt;struts&gt;
        &lt;constant name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constant&gt;
        &lt;include file=&quot;&quot;&gt;&lt;/include&gt;
        &lt;package name=&quot;&quot;&gt;
                &lt;interceptors&gt;
                        &lt;interceptor name=&quot;&quot; class=&quot;&quot;&gt;&lt;/interceptor&gt;
                        &lt;interceptor-stack name=&quot;&quot;&gt;
                                &lt;interceptor-ref name=&quot;&quot;&gt;&lt;/interceptor-ref&gt;
                        &lt;/interceptor-stack&gt;
                &lt;/interceptors&gt;
                &lt;default-interceptor-ref name=&quot;&quot;&gt;&lt;/default-interceptor-ref&gt;
                &lt;global-results&gt;
                        &lt;result name=&quot;&quot;&gt;&lt;/result&gt;
                &lt;/global-results&gt;
                &lt;global-exception-mappings&gt;
                        &lt;exception-mapping result=&quot;&quot; exception=&quot;&quot;/&gt;
                &lt;/global-exception-mappings&gt;
                &lt;action name=&quot;&quot;&gt;
                        &lt;param name=&quot;&quot;&gt;&lt;/param&gt;
                        &lt;result&gt;&lt;/result&gt;
                        &lt;result name=&quot;input&quot;&gt;&lt;/result&gt;
                        &lt;exception-mapping result=&quot;&quot; exception=&quot;&quot;/&gt;
                        &lt;interceptor-ref name=&quot;&quot;&gt;&lt;/interceptor-ref&gt;
                &lt;/action&gt;
        &lt;/package&gt;
    &lt;/struts&gt;

    设置
        &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;/&gt;                # 开启debug模式
                                                                # debug模式，不用重启调试(添加新的方法要重启，方法中改代码不用重启)
        &lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;utf-8&quot;/&gt;
                                                                # 配置struts的编码
        &lt;constant name=&quot;struts.configuration.xml.reload&quot; value=&quot;true&quot;/&gt;
                                                                # 配置本属性，可以使得改动struts配置文件不用重启应用服务器
        &lt;constant name=&quot;struts.multipart.saveDir&quot; value=&quot;/upload&quot;/&gt;
                                                                # 配置上传存储路径
        &lt;constant name=&quot;struts.action.extension&quot; value=&quot;action,do&quot; /&gt;
                                                                    # 配置过滤路径
    详细解释
        o-&gt; 存放路径src/
        o-&gt; 可以在struts-2.3.15.1的src\apps\blank\src\main\resources\struts.xml中参考配置文件
        o-&gt; &lt;include file=&quot;struts2/cal/cal_struts.xml&quot;/&gt;标签包含其它路径的xml配置文件
                        #　被include的文件不能再include其它文件
        o-&gt; &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do,,&quot;&gt;
                默认值
                        default.properties中配置了默扩展名：struts.action.extension=action,,
                # 配置匹配到框架处理的扩展名，空逗号代表匹配没有扩展名
        o-&gt; &lt;package name=&quot;xxPackage&quot; extends=&quot;struts-default&quot; namespace=&quot;/xx/&quot;&gt;
                默认值
                        namespace=&quot;/&quot;
                        extends=&quot;struts-default&quot;        # 不可省略
                # name是包的唯一标识，不可以写路径
                ## namespace 访问路径如/xx/a.do会匹配到该包执行其中的映射，按照域命名空间链的方式匹配，如：
                                                        /xx/yy/a.do也会匹配到该包，但是它优先匹配到/xx/yy的命名空间
                                                        /a.do 不会匹配到该包
                        注意：匹配/sys/*的名称空间是/sys 而非 /sys/
                ## struts的包有抽象包，普通包两种，通过继承可以加入包内容，相当于复制、粘贴
                ## 继承的包是struts-default，其路径是/struts-default.xml
                ## ，它定义了核心的bean和拦截器
        o-&gt; &lt;interceptors&gt;
                        &lt;interceptor name=&quot;&quot; class=&quot;&quot;/&gt;
                        &lt;interceptor-stack name=&quot;&quot;&gt;
                                &lt;interceptor-ref name=&quot;/&quot;&gt;
                                # 定义拦截器、定义拦截器栈（加入拦截器）
                                ## 拦截器栈中可以加栈
        o-&gt; &lt;default-interceptor-ref name=&quot;&quot;&gt; 默认拦截器（可以用于验证用户登录）
        o-&gt; &lt;global-results&gt; 全局结果（用来跳转全局异常等）
        o-&gt; &lt;global-exception-mappings&gt; 全局异常
        o-&gt; &lt;action name=&quot;&quot; class=&quot;&quot; method=&quot;&quot;&gt;
                默认值
                        class=&quot;com.opensymphony.xwork2.ActionSupport&quot;
                        method=&quot;execute&quot;
                # name=&quot;aa&quot;时 .../aa.do的请求匹配到该方法执行
                ## class 是类字节码路径，method是其中的方法名
        o-&gt; &lt;param name=&quot;aaa&quot;&gt;bbb&lt;/param&gt;
                调用 &lt;action&gt;标签中对象的实例的方法：setAaa(&quot;bbb&quot;);
        o-&gt; &lt;result name=&quot;&quot; type=&quot;&quot;&gt;/ok.jsp
                默认值
                        name=&quot;success&quot;
                        type=&quot;dispatcher&quot;
                # name=&quot;success&quot;时，映射的method返回&quot;success&quot;时进入该result处理
                ## type是返回方式 ，如dispatcher redirect等
                        type的返回类型
                                dispatcher : 转发到jsp页面
                                redirect : 重定向到 jsp html 等页面
                                chain : Action 类之间的转发
                                redirectAction : Action 类之间的重定向
                                stream : 以 inputStream 的数据类型返回
                                        stream的参数                        # 可以从struts-default.xml文件中对应的stream参数对应的类的源码中查看其中的set方法找到要写参数的名称
                                                &lt;param name=&quot;contentType&quot;&gt;image/pjpeg&lt;/param&gt;                # 下载文件的类型                  另外如text/html; charset=utf-8返回给ajax异步数据
                                                &lt;param name=&quot;bufferSize&quot;&gt;2048&lt;/param&gt;                # 缓冲byte[]的大小，单位字节
                                                &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${uuidFileName}&lt;/param&gt;                # 设置下载响应头，只的下载时才设置。${uuidFileName}是一个OGNL表达式
                                                &lt;param name=&quot;inputName&quot;&gt;imageStream&lt;/param&gt;        # 框架调用传递给result标签结果字符串的对象中的getImageStream()方法，来获取InputStream流对象
                                                # 返回stream类型不指定返回的路径
                ## 标签间的内容：/ok.jsp 是响应的路径
        o-&gt; &lt;result name=&quot;input&quot; type=&quot;&quot;&gt;/ok.jsp
                type中的参数                        # 可以从struts-default.xml配置文件中查到
                        dispatcher        # 转发
                        redirect        # 重定向
                        chain                # Action类之间转发，需要加参数，参数的名字
                                                ## ：struts-default.xml文件中找到&quot;chain&quot;对应的类，按快捷键ctrl + shift + T 关联类的源码文件，查找set方法改名即可
                                &lt;param name=&quot;actionName&quot;&gt;to&lt;/param&gt;
                                        # action标签的 name属性值
                                &lt;param name=&quot;namespace&quot;&gt;/&lt;/param&gt;
                                        # action的名称空间
                        redirectAction                # Action类之间重定向

                # 各种拦截器不通过时默认的返回input，同时向request作用域中加入了相关错误信息供struts2的jsp标签进行显示
                ## 处理 返回值是input的返回信息跳转，就是处理拦截器拦截后的信息跳转
        o-&gt; &lt;exception-mapping result=&quot;nullJsp&quot;        exception=&quot;java.lang.NullPointerException&quot; /&gt;
                # &lt;action&gt;标签中的局部异常
                ## &lt;action&gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&quot;nullJsp&quot;的字符串交给本&lt;action&gt;标签中相应的&lt;result&gt;标签来处理
        o-&gt; &lt;interceptor-ref name=&quot;loginInterceptor&quot;/&gt;
                默认值
                        name=&quot;defaultStack&quot;
                # 指定在本&lt;action&gt;标签中使用的拦截器或拦截器栈
                ## 当指定了拦截器或拦截器栈以后，默认的defaultStack将会没有,此时defaultStack中的18个拦截器将不再执行

    使用：OGNL对象图导航语言对标签中的路径进行动态设置

# 验证
    struts2验证
        1.代码式: validate(),validateXxx()方法
                        # 单个验证与全部验证都存在时先单个验证，再全部验证，验证信息都加入验证信息集合
        2.声明式: Action类名-validation.xml
                                Action类名-&lt;action标签的name属性&gt;-validation.xml
                            # 单个验证与全部验证都存在时先全部验证，再单个验证，验证信息都加入验证信息集合
                    # 先声明验证，后代码验证
    参数驱动
        1.属性驱动: action中用属性收集表单参数
        2.模型驱动: javaBean收集参数

    代码式（属性驱动）：
        步骤
        1.需要验证的Action类  继承 ActionSupport 类
                        # ActionSupport 类 实现了Validateable接口，该接口是验证接口

        2.写验证方法
                1&gt; public void validate()
                                # 方法重写（通用验证方法，本类中的所有其它方法执行前都执行）

                2&gt; public void validateXxxMethod()
                                # 或者自定义专用验证方法 xxxMethod为要验证的方法名，首字母要大写

                        # 注意，通用、专用验证方法同时存在时，先执行专用验证方法，再执行通用验证方法
                        ## ，但是通用验证方法的错误消息无法加入到返回的错误集合中

                3&gt; this.addFieldError(&quot;password&quot;,&quot;密码必填&quot;);

                        # 验证方法中添加错误信息到错误信息集合
                        ## addFieldError(&quot;&quot;,&quot;&quot;)是从ActionSupport父类中继承的方法

        3.jsp文件中通过验证标签：
                        &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt;
                        &lt;s:fielderror/&gt;                # 显示所有错误信息
                        &lt;s:fielderror fieldName=&quot;password&quot;/&gt;
                显示验证出错信息

        4.xml配置
            &lt;!-- 验证错误信息处理 --&gt;
                &lt;result name=&quot;input&quot; type=&quot;dispatcher&quot;&gt;
                        /error.jsp
                &lt;/result&gt;
                        # 写在需要验证的方法对应的标签中，验证错误时验证方法会优先返回&quot;input&quot;字符串


    声明式（属性驱动）：
        1.验证Action类继承ActionSupport
        2.验证Action类目录下配置文件
            Action类名-validation.xml
            Action类名-&lt;action标签的name属性&gt;-validation.xml
                # 放入此名字的配置文件就相当于加了验证，不需要做其它事情
                ## ，相当于分别向Actioin类中加入了validate()validateXxx()方法进行了相应验证
                文件内容
                &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
                    &lt;!DOCTYPE validators PUBLIC
                    &quot;-//Apache Struts//XWork Validator 1.0.3//EN&quot;
                    &quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&quot;&gt;
                    &lt;validators&gt;
                            &lt;field name=&quot;username&quot;&gt;                # 要验证的属性
                                    &lt;field-validator type=&quot;requiredstring&quot;&gt;
                                            &lt;message&gt;用户名必填&lt;/message&gt;
                                    &lt;/field-validator&gt;
                            &lt;/field&gt;
                            &lt;field-validator type=&quot;regex&quot;&gt;
                                    &lt;param name=&quot;expression&quot;&gt;^[\u3447-\uFA29]+$&lt;/param&gt;
                                    &lt;message&gt;UserAction2-validation==&gt;必须写中文&lt;/message&gt;
                            &lt;/field-validator&gt;
                    &lt;/validators&gt;

                            # xml文件的头在 xwork-core-2.3.1.1.jar包的
                                    xwork-validator-1.0.3.dtd中复制
                            ## 关联约束在
                                    \struts-2.3.15.1\src\xwork-core\src\main\resources\xwork-validator-1.0.3.dtd文件
                            ## &lt;field-validator type=&quot;&quot;&gt;的约束类型在xwork-core-2.3.1.1.jar包的
                                            /com/opensymphony/xwork2/validator/validators/default.xml文件中
                                                    # 16个规则
                                                    ## type=&quot;regex&quot;相当于调用了default.xml文件中配置的
                                                        ## RegexFieldValidator类的 setExpression方法
        3.jsp文件中通过验证标签（同上）
        4.xml配置（同上）
            # 出错信息
                1.验证文件名写错，无提示，不验证
                2.&lt;field-validator type=&quot;&quot;&gt;写错，有明显提示
                2.&lt;field name=&quot;salaryy&quot;&gt;写错，获取的salaryy为空。

    声明式（模型驱动）
            1.创建bean对象，bean对象中封装属性
            2.验证Action类继承ActionSupport类，声明bean对象实例
            3.action类同目录 中  ：Action类名-&lt;action标签的name属性&gt;-validation.xml
                            # &lt;field-validator type=&quot;visitor&quot;&gt;
                    # bean类同目录中：bean类名-validation.xml配置验证文件
            4.jsp文件请求参数改为：action类中bean对象名.bean对象封装的属性名。用&lt;s:fielderror/&gt;标签得到返回的错误信息
            5.xml配置（同上）

    原理
    StrutsPreparedAndExecuteFilter
        1.注入参数
                setUsername()
            setPassword()
        2.验证方法：validate()或validateXxx()
                        验证配置文件中验证：Action类名-validation.xml
        3.转发：根据验证成功或失败返回消息
                        验证集合无错误消息成功Action --&gt; execute或同签名的方法
                        验证集合有错误消息失败&lt;result name = &quot;input&quot; type=&quot;dispatcher&quot;
                                            register.jsp/login.jsp
# 过滤器
    StrutsPrepareAndExecuteFilter
        中查看Dispathcer类，从中找到配置struts-default.xml,struts-plugin.xml,struts.xml值的属性DEFAULT_CONFIGURATION_PATHS
        查找引用该属性的方法为init_TraditionalXmlConfigurations
        查看引用该方法的方法为init
        回头看StrutsPrepareAndExecuteFilter中初始化dispatcher对象的方法initDispatcher
                其中调用了dispatcher.init();方法来配置dispatcher
        由此可以知道struts在启动时加载了struts-default.xml,struts-plugin.xml,struts.xml配置文件
# 拦截器
    struts-core-2.3.1.1.jar包中的
        struts-default.xml文件中
                定义了32个interceptor（拦截器）
                        i18n    # 国际化
            token  # 表单重复提交
            validation  # 验证
            params  # 参数拦截器,向Action类中注入参数
            cookie
        interceptor-tack    # 拦截栈
                # 拦截栈中的拦截器的先后顺序有影响
                basicStack
            defaultStack    # 每个http请求都会经过该拦截栈
                            ## 其中的18个拦截器, &lt;default-interceptor-ref&gt;中定义
    原理
            拦截器仿照过滤器建立，内部实现原理是完全相同的
    执行流程
            拦截器构构造函数 -&gt; action构造函数 -&gt; 拦截器1 in -&gt; 拦截器2 in -&gt; demo -&gt; 拦截器2 out -&gt; 拦截器1 out
        exception拦截器最先进，最后出
    自定义拦截器
        1.定义Action类，继承Interceptor接口，重写生命周期方法
            public LoginInterceptor() {
            }
            public void destroy() {
            }
            public void init() {
            }
            public String intercept(ActionInvocation invocation)  {
            }
        2.配置struts.xml文件
            1&gt; 定义拦截器、拦截器栈
                &lt;interceptors&gt;
                    &lt;interceptor name=&quot;loginInterceptor&quot; class=&quot;interceptor.LoginInterceptor&quot;/&gt;
                    &lt;interceptor name=&quot;roleInterceptor&quot; class=&quot;interceptor.RoleInterceptor&quot;/&gt;
                    &lt;interceptor-stack name=&quot;crmStack&quot;&gt;
                        &lt;interceptor-ref name=&quot;loginInterceptor&quot;&gt;&lt;/interceptor-ref&gt;
                        &lt;interceptor-ref name=&quot;roleInterceptor&quot;&gt;&lt;/interceptor-ref&gt;
                    &lt;/interceptor-stack&gt;
                &lt;/interceptors&gt;
            2&gt; &lt;action&gt;标签中声明用到的拦截器或拦截器栈
                    &lt;interceptor-ref name=&quot;loginInterceptor&quot; /&gt;                # 此时默认的defaultStack拦截器栈会被替代掉
    自定义方法过滤拦截器
        # MethodFilterInterceptor继承AbstractInterceptor继承Interceptor，前两个是struts自己实现的自己的包装类
        ## 原理：自己实现intercept方法，实现对方法名的过滤。如果符合通过条件，则执行自己的doIntercept方法。所以要求用户重写doIntercept方法实现业务逻辑
        &lt;interceptor name=&quot;aloginInterceptor&quot; class=&quot;cn.it.shop.interceptor.AloginInterceptor&quot;&gt;
            &lt;param name=&quot;excludeMethods&quot;&gt;*$&lt;/param&gt;                # 除了*$匹配的方法都执行此拦截器
                    ## includeMethods为包含匹配的方法执行拦截器
        &lt;/interceptor&gt;
    生命周期
        部署时初始化，每次符合&lt;action&gt;的请求时，执行拦截器
    拦截器Action 类
        o-&gt; 继承Interceptor 接口
        o-&gt; 重写生命周期方法
            String intercept(ActionInvocation invocation)方法中调用
                invocation.invoke() 放行
                invocation.getAction()得到当前的Action类
                invocation.getStack()得到值栈中的栈
                    # invocation用于调试18个拦截器
    具体拦截器
        struts-default.xml 文件中定义了32种拦截器
                alias
        autowiring
        chain
        conversionError
        cookie
        clearSession
        createSession
        debugging
        execAndWait
        exception
        fileUpload                                # 只用来验证已经注入的文件是否合格，合格则通过，不合格则不执行action类中对应请求的方法
        i18n
        logger
        modelDriven                                # 用于检查action类是否实现ModelDriven&lt;T&gt;接口，然后调用getModel()方法注入得到的对象到栈的项端。
        scopedModelDriven
        params                                        # 注入参数用，包括注入文件（级联注入文件的ContentType与FileName）
        actionMappingParams
        prepare
        staticParams
        scope
        servletConfig                                # 向自定义的实现RequestAware等接口的Action类（一般是BaseAction类）中注入request等相应的map对象
        timer
        token                                                # 防止重复提交
        tokenSession
        validation                                # 验证
        workflow
        store
        checkbox
        profiling
        roles
        annotationWorkflow
        multiselect
    数据传递
        o-&gt; 拦截器不会向其它拦截器中注入参数，所以自定义拦截器中了参数要从request中获取
        o-&gt; 如果想 显式的引用了自己的拦截栈，默认的拦截栈就不引用了，要自己引用，其中的注入参数拦截器向action类中注入参数
    技巧
        &lt;interceptor-stack name=&quot;defaultStack&quot;&gt;    # 对defaultStack进行替换，在它前面添加自定义的拦截器
        &lt;interceptor-ref name=&quot;aloginInterceptor&quot;/&gt;
        &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;
    拦截器中的ActionInvocation对象
        可以得到ActionContext

# 文件处理
## 上传
    struts2文件上传步骤
        1.编写jsp文件
                1&gt; post方式提交
                2&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot;/&gt; 要添加name属性
                3&gt; post表单上传的编码方式是enctype=&quot;multipart/formdata&quot;
        2.创建Action类，不必继承任何类(但是如果不继承ActionSupport类的话，拦截器将不会返回提示消息)
                1&gt; 定义参数        # 如果不接收上传文件名字符串数组而从文件对象中获取文件名的话，得到的文件名将会是乱码
                        private File[] image;                                                # 字段名
                        private String[] imageContentType;                        # 文件类型
                        private String[] imageFileName;                                # 文件名
                        private String uploadPath;
                                        # 前三个参数可以不是数组，在 struts-default.xml配置文件fileUpload拦截器对应的源码中可以找到定义规则：
                                                &lt;li&gt;[File Name] : File - the actual File&lt;/li&gt;
                                                &lt;p/&gt; &lt;li&gt;[FileName]ContentType : String - the content type of the file&lt;/li&gt;
                                                &lt;p/&gt;&lt;li&gt;[File Name]FileName : String - the actual name of the file uploaded(not the HTML name)&lt;/li&gt;
                                        # uploadPath是我们自定义的配置文件中注入过来的文件存储位置

                2&gt; 写execute方法保存文件到路径，返回成功消息
        3.Action类的配置文件，include到src/struts.xml文件中
                        1&gt; &lt;action&gt;标签中配置name=&quot;input&quot;的标签&lt;result&gt;来返回出错消息
                        2&gt; &lt;action&gt;标签中用param标签注入文件存储路径：uploadPath 底层执行setUploadPath()方法
                        3&gt; &lt;action&gt;标签中通过&lt;interceptor-ref name=&quot;fileUpload&quot;&gt;标签对上传文件进行参数上的限定
                                1&gt; &lt;param name=&quot;maximumSize&quot;&gt; 单个文件的最大尺寸(字节)
                                2&gt; &lt;param name=&quot;allowedExtensions&quot;&gt; 文件扩展名
                                3&gt; &lt;param name=&quot;allowedTypes&quot;&gt; 文件实际类型，如image/jpeg，可从tomcat配置文件web.xml中查找
        4.配置返回消息的信息
                ：src/struts.properties文件中
                        struts.custom.i18n.resources=struts                # 解锁自/org/apache/struts2/default.properties总配置文件
                                        # 加载自己，=后面是参照src/目录的相对路径 ，省略掉.properties扩展名
                        struts.multipart.maxSize=2097152                #  解锁自/org/apache/struts2/default.properties总配置文件
                                        # 设置上传文件总量的大小
                        struts.messages.error.file.too.large=\u6587\u4EF6\u592A\u5927\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                        struts.messages.error.content.type.not.allowed=\u6587\u4EF6\u7C7B\u578B\u4E0D\u6B63\u786E\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                        struts.messages.error.file.extension.not.allowed=\u6269\u5C55\u540D\u4E0D\u6B63\u786E\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                                        # 覆盖/org/apache/struts2/default.properties总配置文件的响应消息,=后面是中文的unicode编码的iso8859-1的表示形式，通过视图可以直接配置，也可以用java/bin目录下的native2ascii.exe工具进行转码

    多文件上传
        出现有多个文件共同上传时，文件拦截器会出现一错全错的情况，这时我们利用struts的一个
                小bug---文件拦截不成功也调用action类的setXxx方法传入文件，从set函数中对文件进行筛选和转存
                这时文件拦截器已经形同虚设，一点作用也不起了。

    原理过程
        1.上传请求经过struts2的过滤器匹配扩展名
        2.按src/struts.xml文件中声明的配置包映射的名称空间映射到配置包
        3.根据action标签的name属性匹配名称空间与扩展名之间的“文件名”,映射到该action标签
                1&gt; 经过多层拦截器
                2&gt; 用param标签注入文件存储路径
                3&gt; 通过&lt;interceptor-ref name=&quot;fileUpload&quot;&gt;标签对上传文件进行参数上的限定
                2&gt; 执行action标签对应类的方法，该方法返回的返回的字符串进行响应

    默认配置
        1.defaultStack拦截栈中的fileUpload拦截器进行处理
        2.default.properties配置文件中 对multipart的上传方式进行了配置
                struts.multipart.parser=jakarta                  # struts使用了第三方的jakerta来给上传文件解码
                struts.multipart.saveDir=                      # 缓存文件的临时目录，不填默认是
                                                                                        ## work/catalina/localhost/web工程名/upload_.....00000..tmp
                struts.multipart.maxSize=2097152      # 默认支持的上传文件的大小 (字节，2m)，是总大小
        3.多数服务器自己删除缓存文件
## 下载
    用传递类型为stream 来返回要下载的文件
    写法
        &lt;result name=&quot;success&quot; type=&quot;stream&quot;&gt;
            &lt;!-- 下载文件的类型 --&gt;
            &lt;param name=&quot;contentType&quot;&gt;image/pjpeg&lt;/param&gt;
            &lt;!-- byte[]的大小，单位字节 --&gt;
            &lt;param name=&quot;bufferSize&quot;&gt;2048&lt;/param&gt;
            &lt;!-- 设置下载响应头，${uuidFileName}是一个OGNL表达式，不是EL表达式 --&gt;
            &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${uuidFileName}&lt;/param&gt;
            &lt;!-- 框架调用getXxx()方法，来获取InputStream流对象 --&gt;
            &lt;param name=&quot;inputName&quot;&gt;imageStream&lt;/param&gt;
        &lt;/result&gt;
            # 与其它同样，要注入的参数从stream类型对应的类中可以进行查看
    显示与下载的编码问题
        o-&gt; 设置tomcat/conf/server.xml
            &lt;Connector port=&quot;8080&quot; .. URIEncoding=&quot;utf-8&quot;/&gt;
        o-&gt; 提交下载请求用post方式，struts框架自动给post请求编码解码
</code></pre>

<h3 id="cleaver">cleaver</h3>

<pre><code># 基于node幻灯片
</code></pre>

<h3 id="hexo">hexo</h3>

<pre><code>介绍
    简单轻量，基于node的静态博客框架
    可以部署在自己node服务器上，也可以部署在github上
目录结构
    scaffolds                                        # 脚手架
    scripts                                            # 写文件的js, 扩展hexo功能
    source                                            # 存放博客正文内容
            _drafts                                    # 草稿箱
            _posts                                        # 文件箱
    themes                                            # 皮肤
    _config.yml                                        # 全局配置文件
    db.json                                            # 静态常量
使用
    npm install -g hexo
    hexo version
    hexo init nodejs-hexo
    cd nodejs-hexo &amp;&amp; hexo server
    hexo new 新博客                            # 产生 source/_posts/新博客.md
    hexo server                                        # 启动server
    hexo generate                                    # 静态化处理
    github中创建一个项目nodejs-hexo, 在_config.yml中找到deploy部分，设置github项目地址
    hexo deploy
            # 部署以后，分支是gh-pages, 这是github为web项目特别设置的分支
    上github，点settings找到github pages, 找到自己发布的站点
    无法访问静态资源
            设置域名
                    申请域名
                    dnspod 中 绑定ip
</code></pre>

<h3 id="hugo">hugo</h3>

<pre><code>简介

    hugo由go编写，开源，特点为编译快
    本文基于hugo0.49

help
    hugo help
    hugo help server    # server代表任何子命令

 生成站点
    hugo new site blog1 # 站点命令在blog1中执行

 生成文章
    hugo new about.md
    hugo new post/first.md

 主题
    git clone https://github.com/spf13/hyde.git themes/hyde # 更多主题在https://themes.gohugo.io


 本地服务器
    hugo server
        # 自带watch
        -s /path/to/codes
        --theme=hyde
        --buildDrafts
        -p 1315
            # 默认端口1313

 发布
    hugo --theme=hyde --baseUrl=&quot;https://outrunJ.github.io&quot;

 文章
    开头
        ---
        用YAML写内容
        --- # +++标记可写TOML

        Description = &quot;&quot;
        Categories = [&quot;a1&quot;, &quot;a2&quot;]
        Tags = [&quot;b1&quot;,&quot;b2&quot;]
        draft = true    # 文章隐藏
        menu = &quot;&quot;
        title = &quot;a&quot; # 文章标题

 配置
    打开config.toml   # 可以是config.yaml、config.json
    baseURL = &quot;&quot;
    title = &quot;&quot;
    theme = &quot;&quot;
    [permalinks]
        post = &quot;/:year/:month/:title/&quot;  # 生成list页面

    [taxonomies]
        category = &quot;categories&quot;
        tag = &quot;tags&quot;

    [params]
        description = &quot;&quot;
        author = &quot;&quot;

    ignoreFiles = []

    [blackfriday]   # 设置markdown库
</code></pre>

<h3 id="jekyll">jekyll</h3>

<pre><code>介绍
    ruby静态站点生成器，根据网页源码生成静态文档文件
    提供模板、变量、插件等功能
    生成的站点可以直接发布到github上
使用
    curl http://curl.haxx.se/ca/cacert.pem -o cacert.pem
        # 移动到ruby安装目录
    安装devkit
    gem install jekyll
    git clone https://github.com/plusjade/jekyll-bootstrap.git jekyll
        # 下载jekyll-bootstrap模版
    cd jekyll &amp;&amp; jekyll serve
    rake post title = 'Hello'
        # 生成文章
        ## 编辑_posts下面生成的文章
    修改convertible.rb文件编码为utf-8
    jekyll serve
    发布到github
        github上创建新仓库
        git remote set-url origin git@新仓库
        git add .
        git commit -m 'new'
        git push origin master
        git branch gh-pages
            # 新建一个分支，用于发布项目
        git checkout gh-pages
        修改_config.yml
            production_url: http://outrun.github.io
            BASE_PATH: /jekyll-demo
</code></pre>

<h2 id="搜索">搜索</h2>

<pre><code>分类
    垂直搜索引擎
        针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。
    通用搜索引擎
        通过关键字的方式实现的，是语义上的搜索，返回的结果倾向于知识成果，比如文章，论文，新闻等
        通用搜索引擎的信息量大、查询不准确、深度不够
        通用搜索引擎的海量信息无序化

部分
    １.索引
    ２.分词
    ３.搜索

compass
    # 基于lucene
nutch
    # 基于lucene
elasticsearch
    # 基于lucene
sunspot
    # 基于Rsolr，以dsl结构用ruby调solr
sphinx
    # 基于sql的全文检索引擎
</code></pre>

<h3 id="lucene">lucene</h3>

<pre><code># 原理
    block k-d tree
    倒排索引
        词典
            排序数组
                # 为了二分查找
                # 实现简单，性能差
            哈希表
                # 性能好，占内存大
            跳跃表
                # 内存小且可调节, 模糊查询不好
            B/B+树
                # 磁盘索引 ，更新方便，检索慢
            trie树
                # 效率与字符串长度有关，只适合做英文词典
            dat
                # 可做中文词典，内存占用小
            fst
                # 共享前缀，内存占用小，要求输入有序，不易更新
                内存存前缀索引、磁盘存后缀词块
        倒排表
        正向文件
            # 行式存储，原始文档
        doc-values
            # 列式存储，文档号到值的映射
    文件指纹

# 概念
    index
        # 一个倒排表，对应一个目录
    segment
        # index的存储单元，包含多个文档
    document
        # 创建单位
    field
        # 文档里的键值对
    term
        # 分词后的字符串
    analyzer
        tokenizer
            # 切分文本到索引单元
        tokenfilter
            # 对token预处理
# 常识
    特性
        索引
        高亮
        命中率排序
        分词
    与数据库的区别：数据库注重存储、全文检索注重查询
    其它搜索：多媒体搜索
    索引库(文件夹 或 内存中)：
        只存储了商品的基本信息
         索引库与数据库定时同步
        索引库 -&gt; document -&gt; field                # field是键值对,值只能存数据
                同步
        IndexWriter:addDocumnet(),delteDocument(),updateDocument()
                查询
                        IndexSearch:search(),get()
        Field的内部结构
                    # 不存不索引会报错
        Store:控制此Field字段是否存储到索引库中
        Index:是否建立索引（索引不区分大小写,过滤词不创建索引）
            NO:不建立索引，可以通过field的key查到，但是不能通过关键字查询到
            NOT_ANALYZED:建立索引，但是不分词
            ANALYZEd:建立索引又分词
# 使用到的对象
    Directory
    Analyzer
        TokenStream tokenStream = analyzer.tokenStream(&quot;eldName&quot;,new StringReader(&quot;测试字符串&quot;))
        while(tokenStream.incrementToken()){
                TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class);
                System.out.println(termAttribute.term());
        }                # 使用分词器测试分词
    Document
        add(Field)
        document = indexSearcher.doc(ScoreDoc)
        get(String)                # 通过key查找value
    IndexWriter
        IndexWriter(directory,analyzer,MaxFieldLength.LIMITED);       # LIMITED限定Field的数量(源码中规定默认值)
        addDocument(Document)
        commit()
        close()                        # 自带commit()
        rollback()
    IndexSearcher
    QueryParser
        QueryParser(Version.LUCENE_30,&quot;name&quot;,analyzer)
    Query
        query = parser.parse(用户传递的字符串);
        query = parser.parseMultiField(String [], 用户传递的字符串);
    TopDocs
        topDocs = indexSearcher.search(query, 10);                # 10是期望的结果数
                                                                                                        ## 最终查询到的结果数是：期望结果数与实际结果数的最小值
        totalHits                # 命中的结果数
    ScoreDoc
        ScoreDoc [] scoreDocs = topDocs.scoreDocs;
        scoreDoc.score                # 命中率积分
        scoreDoc.doc                # 命中文档编号，该编号由lucene自动生成
    Term                # 索引项
        Term(&quot;field中的key&quot;,&quot;field中value解析出的关键字&quot;)
# 索引的结构
    Term(&quot;key&quot;,&quot;value&quot;)[0,3,4]                        # key 为对应的field中的&quot;key&quot;,value对应的是解析field的&quot;value&quot;出的关键字
                                                                                ## []中的内容为匹配的文档编号，该编号为系统自动生成的
# 注意
    lucene创建索引时field的key都可以重复，没有主键方面的限制。但是实际应用时要求我们为document有唯一的标识“主键”field,便于对每个document进行更新与删除
# 使用
    包：IKAnalyzer,lucence-analyzer(英文分词，不需要),memory,core,highlighter
    工具：lukeAll 用来查看索引库
    添加、查询、删除、修改
    抽取配置类（构造方法私有化）
        Configuration
            维护了directory与analyzer
        DocumentUtil
            goodsToDocument(Goods)
            documentToGoods(Document)
        LuceneUtil
            维护了indexWriter与indexSearcher
            注意
                    1.indexWriter在static代码块中初始化
                    2.getIndexWriter
        LuceneService
            用indexWriter与indexSearcher处理业务逻辑
            添加
                indexWriter.addDocument(Document)
                indexWriter.rollback()
            删除
                indexWriter.deleteDocument(Term)
                indexWriter.optimize()                # 删除document的时候同步索引库，没有设置的话只是删除document，但是索引中还是可以查到
            更新
                indexWriter.updateDocument(Term,Document)
                indexWriter.optimize()                # 更新是先删除再添加（所以如果updateDocument(Term,Document)中匹配多个Document时，会出现删除了多个Document,而添加了一个Document的情况）
            查询
                QueryParser parser = new QueryParser(Version.LUCENE_30, &quot;field中的key&quot;, analyzer);
                Query query = IKQueryParser.parseMultiField(new String[]{&quot;name&quot;,&quot;remark&quot;}, &quot;ee&quot;);                # 多字段查询，IKAnalyzer特有
                    #　多字段查询到的第二个字段的结果，在转换高管时（调用getBestFragment时）只会对该方法指定的一个字段进行匹配，如果该字段不匹配时（但是第二个字段匹配），则会返回空。
                    ## 针对这一个bug,在getBestFragment处理匹配的结果返回空时，不使用空而直接返回没有高亮的字符串即可。
                parser.parse(用户传递的字符串);
                TopDocs topDocs = indexSearcher.search(query, 3);        # 3是期望结果数
                ScoreDoc [] scoreDocs = topDocs.scoreDocs;
                Document document = indexSearcher.doc(scoreDoc.doc);                scoreDoc.doc得到文档编号
                分页查询：
                    传递当前页码与一页记录数
                    利用topDocs.totalHits得到总记录数
                    查询本页与前面所有页的期望数据量，然后只截取本页的文档编号，得到document并返回数据

# 分词器
    IKAnalyzer
        配置文件
            src/IKAnalyzer.cfg.xml中配置
                &lt;properties&gt;
                    &lt;entry key=&quot;ext_dict&quot;&gt;/mydict.dic&lt;/entry&gt;                 # 配置自己的字典（不分词）
                    &lt;entry key=&quot;ext_stopwords&quot;&gt;/ext_stopword.dic&lt;/entry&gt;                 # 配置跳过的字
                &lt;/properties&gt;
        Query query = IKQueryParser.parse(&quot;name&quot;,name);                # IKAnalyzer特有
# 排序
    Directory directory = FSDirectory.open(new File(&quot;d:/lucene&quot;));
    IndexSearcher indexSearcher = new IndexSearcher(directory);
    Query query = IKQueryParser.parse(&quot;name&quot;,&quot;cc&quot;);
    Sort sort = new Sort(new SortField(&quot;id&quot;, SortField.INT,true));                # 这里可以排序多个字段
        # 参数1：&quot;id&quot;是排序的field字段,参数2：是字段内容的类型,参数3 true代表降序排列
        ## 此时命中率不再计算（因为不按命中率排序）
        ## 排序的field必须建立索引
    indexSearcher.search(query, null,10,sort);
高亮
    导入包:highlight与memory
    Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(&quot;&lt;font color='red'&quot;,&quot;&lt;/font&gt;&quot;),new QueryScorer(query));
    highlighter.setTextFragmenter(new SimpleFragmenter(10));                # 限制字符长度
    ..
    String result = highlighter.getBastFragment(analyzer,&quot;name&quot;,doc.get(&quot;name&quot;));
        # 返回高亮处理字符串
        ## 参数1：解析用户输入词的分词器,参数2：是要查询的field的key(没有用)，参数3：field的value
</code></pre>

<h3 id="solr">solr</h3>

<pre><code>介绍
    基于lucene
    搜索服务器，http请求提交和返回xml
功能
    丰富了查询语言
    实现可配置、可扩展
    优化了性能
    提供了管理界面
    缓存功能
    垂直搜索
    高亮
    data schema定义字段
</code></pre>

<h2 id="数据">数据</h2>

<h3 id="日志">日志</h3>

<pre><code>scribe
    facebook出品
    特点
        支持nfs存储
    结构
        scribe agent
            向scribe发送数据
        scribe
            接收数据，不同topic 的数据发送给不同的store中
        存储系统(store)
            file, buffer, network, bucket, null, thriftfile, multi

chukwa
    # apache出品，hadoop系列产品
flume
    cloudera出品
    特点
        可靠性(节点故障时，日志传送到其他节点)
            三种级别
                end-to-end 发送前写磁盘，成功时删除
                store on failure 失败返回时写磁盘
                best effort 不确认数据是否成功
        可扩展性
            agent collector storage三层架构，每层可扩展。
                agent: 将数据源数据发送给collector
                collector: 将多个agent数据汇总后, 加载到storage中
                storge: 存储系统, 可以是file, hdfs, hive, hbase等
            agent collector 由master统一
logstash
    # 分布式日志收集，需结合kafka
</code></pre>

<h3 id="爬虫">爬虫</h3>

<pre><code>cheerio
    # node解析html，如jquery
scrapy-redis
    # python 分布式爬虫框架
phantomjs
    # js浏览器模拟框架
</code></pre>

<h3 id="分析">分析</h3>

<pre><code>pandas
    # python数据分析
</code></pre>

<h3 id="计算">计算</h3>

<h4 id="hadoop">hadoop</h4>

<pre><code># 发展
    google
        gfs
        mapReduce
            # 并行计算框架
        big-table
    hadoop1.0
    hdfs
        mapReduce
    hadoop2.0
        hdfs
            # Hadoop Distributed File System　
        yarn
            # Yet Another Resource Negotiator资源管理调度系统
            # 在hdfs上运行计算框架(如mapReduce, storm, spark)
# 原理
    hdfs
        模块
                client
                nameNode                                                # 用于注册文件
                                                                        ## 2.0后可以有多个nameNode
                        metadata                                        # 数据的描述信息
                dataNode                                                # 数据在dataNode间水平传递
        关系
                client rpc nameNode
        结构
                metadata
                        /test/a.log, 3, {blk_1,blk_2}, [{blk_1:[h0,h1,h3]},{blk_2:[h0,h2,h4]}]
    mapReduce
        Map: 切分，并行计算
        Reduce: 从map中取多个计算结果，进行合并

# 组件
    ambari
            # 安装、部署、配置和管理
    hdfs
            # 分布式文件系统
    hive
            # 数据仓库
    pig
            # 数据流处理
    mahout
            # 数据挖掘
    mapreduce
    flume
            # 日志收集
    hbase
            # 实时分布式, bigtable数据库
    sqoop
            # etl
    zookeeper
# 框架
    CDH
        cloudera
    HDP
        hortonworks data platform
    应用框架
        sqoop
            在hdfs(hive)与关系型数据库之间数据相互转移
        phoenix
            介绍
                    打造更快的sql查询，面向hbase与hdfs之上的其它nosql数据库
            特征
                    通过jdbc进行交互
        shark
            介绍
                    hive on spark
            特点
                    并行job处理比mapReduce快100倍
        ganglia
            分布式监控系统，用于监视和显示集群中节点的各种状态信息，如cpu, mem, 硬盘利用率, i/o负载, 网络流量等，历史数据生成曲线图，通过php页面显现。
    存储框架
        hive
            功能
                    将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为mapReduce运行。
            缺点
                    底层使用mapReduce引擎，是一个批处理过程，难以满足查询的交互性
        hbase
            特征
                    分布式的，面向列的开源nosql数据库，列可以动态增加
                    基于hadoop的bigTable
                    不同于一般关系数据库，是一个适合于非结构化数据存储的数据库
                    自动切分数据
                    并发读写
            缺点
                    只能按照row key来查询
                    master宕机，整个系统挂掉
    计算框架
        mr
            离线计算框架
        spark
            介绍
                    内存计算框架
                    apache托管UC Berkeley AMP lab开源的类hadoop 通用并行框架
                    mapreduce中间输出结果可以保存在内存中，不再需要读写hdfs
                    是scala语言实现的
            特点
                    准实时，收集成rdd后处理
                    不支持事务
            技术
                    spark rdd
                    spark streaming
                    spark sql
        drill
            google dremel 的开源版本
        storm
            介绍
                    实时视图计算框架
                    纯实时
                    支持事务
            特点
                    结合kafka
        impala
            介绍
                    实时视图计算框架
                    纯实时
                    支持事务
            特点
                    结合kafka
# 部署
    本地模式
    伪分布模式(学习用)
    集群模式
    例子
        软件结构
                0        jdk, hadoop                        NameNode, DFSZKFailoverController
                1        jdk, hadoop                        NameNode, DFSZKFailoverController
                2        jdk, hadoop                        ResourceManager
                3        jdk, hadoop, zookeeper        DataNode, NodeManager, JournalNode, QuorumPeerMain
                4        jdk, hadoop, zookeeper        DataNode, NodeManager, JournalNode, QuorumPeerMain
                5        jdk, hadoop, zookeeper        DataNode, NodeManager, JournalNode, QuorumPeerMain
        zookeeper
            配置conf/zoo.cfg
                    tickTime=2000                        # 心跳间隔(ms)
                    initLimit=10                        # 初始化时最多容忍心跳次数
                    syncLimit=5                        # 同步失败最多容忍心跳次数
                    dataDir=/usr/local/zookeeper/data        # 运行时文件目录
                    clientPort=2181                # 运行端口号
                    server.1=主机名或ip:2888:3888        # 服务运行端口与选举端口
                    server.2=主机名或ip:2888:3888
                    server.3=主机名或ip:2888:3888
            命令
                    ./bin/zkServer.sh start
                    ./bin/zkServer.sh status
                    jps                                        # 显示名为QuorumPeerMain
        hadoop
            hadoop-env.sh
                export JAVA_HOME=
            core-site.xml
                &lt;configuration&gt;
                    &lt;property&gt;
                            &lt;name&gt;fs.defaultFS&lt;/name&gt;
                            &lt;value&gt;hdfs://ns1&lt;/value&gt;
                    &lt;/property&gt;
                    &lt;property&gt;
                            &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
                            &lt;value&gt;/usr/local/hadoop-2.2.0/tmp&lt;/value&gt;
                    &lt;/property&gt;
                    &lt;property&gt;
                            &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;
                            &lt;value&gt;192.168.56.13:2181, 192.168.56.14:2181, 192.168.56.15:2181&lt;/value&gt;
                    &lt;/property&gt;
                &lt;/configuration&gt;
            hdfs-site.xml
                &lt;property&gt;
                    &lt;name&gt;dfs.nameservices&lt;/name&gt;
                    &lt;value&gt;ns1&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.ha.namenodes.ns1&lt;/name&gt;
                    &lt;value&gt;nn1,nn2&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.namenode.rpc-address.ns1.nn1&lt;/name&gt;
                    &lt;value&gt;192.168.56.10:9000&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.namenode.http-address.ns1.nn1&lt;/name&gt;
                    &lt;value&gt;192.168.56.10:50070&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.namenode.rpc-address.ns1.nn2&lt;/name&gt;
                    &lt;value&gt;192.168.56.11:9000&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.namenode.http-address.ns1.nn2&lt;/name&gt;
                    &lt;value&gt;192.168.56.11:50070&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;
                    &lt;value&gt;qjournal://192.168.56.13:8485;192.168.56.14:8485;192.168.56.15:8485&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;
                    &lt;value&gt;/usr/local/hadoop-2.2.0/journal&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;
                    &lt;value&gt;true&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.client.failover.proxy.provider.ns1&lt;/name&gt;
                    &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;
                    &lt;value&gt;sshfence&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;
                    &lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;
                &lt;/property&gt;
            mapred-site.xml
                &lt;property&gt;
                    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
                    &lt;value&gt;yarn&lt;/value&gt;
                &lt;/property&gt;
            yarn-site.xml
                &lt;property&gt;
                    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
                    &lt;value&gt;192.168.56.12&lt;/value&gt;
                &lt;/property&gt;
                &lt;property&gt;
                    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
                    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
                &lt;/property&gt;
            etc/hadoop/slaves
                192.168.56.13
                192.168.56.14
                192.168.56.15
        收尾
            o-&gt; ssh免登录(0到1,2,3,4,5)
                    ssh-keygen -t rsa
                    ssh-copy-id -i 192.168.56.11                # 这样就可以免登录访问192.168.56.11了
                                                            ## ssh-copy-id -i localhost 免登录自己

            o-&gt; 复制hadoop2.2.0(从0到1,2,3,4,5)

            o-&gt; 添加hadoop_home到环境变量
                    etc/profile
                            export HADOOP_HOME=/usr/local/hadoop-2.2.0
                            export PATH=$PATH:$HADOOP_HOME/bin
        启动
            0 上启动
                    ./sbin/hadoop-daemons.sh start journalnode
            0 上格式化namenode
                    hadoop namenode -format
# 相关
    bigTable
    gfs
    dremel
        介绍
                google的交互式数据分析系统，构建于gfs上
        特点
                嵌套型数据的列存储
                多层查询
                减少查询的处理数据量，提升查询效率
</code></pre>

<h2 id="权限">权限</h2>

<h3 id="shiro">shiro</h3>

<pre><code>功能
    认证
    授权
    加密
    会话管理
    Web集成
    缓存
组件
    Subject     # 当前用户,绑定到SecurityManager
    SecurityManager     # 门面模式，管理组件
    Realms      # 连接认证数据(用户、角色、权限)
    Authenticator   # 认证principals和credentials
    Authorizer  # 校验权限
    SessionManager      # 异构客户端
控制方式
    url
    注解
    代码
    页面标签
模块
    Authenticator
        # SecurityManager继承Authenticator
        public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  throws AuthenticationException;
    permission
        概念
            subject
            resource
            permission
            role
                隐式角色
                显示角色
        配置
            shiro.ini
                [users]
                zhang=123, role1, role2                # 用户名=密码, 角色1, 角色2
        判断角色
            o-&gt;
                subject.hasRole(&quot;admin&quot;);
            o-&gt;
                @RequiresRoles(&quot;admin&quot;)
                @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)
                    # 表示当前Subject需要角色admin和user。
            o-&gt;
                &lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;/shiro:hasRole&gt;
        权限注解
            @RequiresAuthentication
                # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。
            @RequiresUser
                # 表示当前Subject已经身份验证或者通过记住我登录的。
            @RequiresGuest
                # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。
            @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)
                # 表示当前Subject需要权限user:a或user:b。
    credential
        散列
            String str = &quot;hello&quot;;
            String salt = &quot;123&quot;;
            //内部使用MessageDigest
            String simpleHash
        密码生成工具
            //输入明文密码得到密文密码
            String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;
            //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）
            boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);
    filter
        NameableFilter                        ＃根据名字找到相应的拦截器实例
        OncePerRequestFilter                # 控制开启、关闭拦截器实例
        ShiroFilter                        # 安全控制
        AdviceFilter                        # aop
            preHandle                        # 前置增强
            postHandle                        # 后置增强
            afterCompletion                # 后置最终增强(异常也执行，相当于finally的概念)
        PathMatchingFilter                # 匹配请求路径
        AccessControlFilter                # 允许或拒绝访问，拒绝时如何处理
    jsp标签
        &lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;

        &lt;shiro:guest&gt;
        欢迎游客访问，&lt;a href=&quot;${pageContext.request.contextPath}/login.jsp&quot;&gt;登录&lt;/a&gt;
        &lt;/shiro:guest&gt;

        &lt;shiro:user&gt;
        欢迎[&lt;shiro:principal/&gt;]登录，&lt;a href=&quot;${pageContext.request.contextPath}/logout&quot;&gt;退出&lt;/a&gt;
        &lt;/shiro:user&gt;
            # 用户已经身份验证/记住我登录后显示相应的信息。

        &lt;shiro:authenticated&gt;
            用户[&lt;shiro:principal/&gt;]已身份验证通过
        &lt;/shiro:authenticated&gt;
            # 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。

        &lt;shiro:notAuthenticated&gt;
            未身份验证（包括记住我）
        &lt;/shiro:notAuthenticated&gt;
            # 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证。

        &lt;shiro: principal/&gt;
            # 显示用户身份信息，默认调用Subject.getPrincipal()获取
            &lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;
            &lt;shiro:principal property=&quot;username&quot;/&gt;

        &lt;shiro:hasRole name=&quot;admin&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有角色admin&lt;br/&gt;
        &lt;/shiro:hasRole&gt;

        &lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt;
        &lt;/shiro:hasAnyRoles&gt;

        &lt;shiro:lacksRole name=&quot;abc&quot;&gt;
            用户[&lt;shiro:principal/&gt;]没有角色abc&lt;br/&gt;
        &lt;/shiro:lacksRole&gt;
                        # 如果当前Subject没有角色将显示body体内容。

        &lt;shiro:hasPermission name=&quot;user:create&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt;
        &lt;/shiro:hasPermission&gt;

        &lt;shiro:lacksPermission name=&quot;org:create&quot;&gt;
            用户[&lt;shiro:principal/&gt;]没有权限org:create&lt;br/&gt;
        &lt;/shiro:lacksPermission&gt;
    session
        得到会话
            login(&quot;classpath:shiro.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);
            Subject subject = SecurityUtils.getSubject();
            Session session = subject.getSession();
        api
            Session
                getId()
                getHost()                # 调用HostAuthenticationToken.getHost(), 得到主机地址
                getTimeout()
                setTimeout(1000)
                getStartTimestamp()
                setLastAccessTime()
                touch()                        # 更新会话最后访问时间
                stop()                        # 销毁会话, Subject.logout()与HttpSession.invalidate()会自动调用该api
                setAttribute(&quot;key&quot;, &quot;123&quot;)
                getAttribute(&quot;key&quot;)
                removeAttribute(&quot;key&quot;)
            SecurityManager
                Session start(SessionContext context)
                Session getSession(SessionKey key) throws SessionException
            WebSessionManager
                boolean isServletContainerSessions();                # 是否使用Servlet容器的会话
            ValidatingSessionManager
                void validateSessions();                                # 验证所有会话是否过期
    cache
        接口
            Cach&lt;K, V&gt;
            CacheManager
            CacheManagerAware
        ini配置
            userRealm.cachingEnabled                        # 启用缓存，默认false
            userRealm.authenticationCachingEnabled        # 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false
            userRealm.authenticationCacheName                # 缓存AuthenticationInfo信息的缓存名称
            userRealm. authorizationCachingEnabled        # 启用授权缓存，即缓存AuthorizationInfo信息，默认false
            userRealm. authorizationCacheName                # 缓存AuthorizationInfo信息的缓存名称
            securityManager.realms=$userRealm

            cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager
            cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml
            securityManager.cacheManager=$cacheManager

            sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager
            securityManager.sessionManager=$sessionManager
    rememberme
    ssl
        o-&gt; keytool -genkey -keystore &quot;D:\localhost.keystore&quot; -alias localhost -keyalg RSA
            # jdk自带的生成证书工具(包含证书/公钥/私钥）
        o-&gt; 设置tomcat server.xml
            &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;
            maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
            clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;
            keystoreFile=&quot;D:\localhost.keystore&quot; keystorePass=&quot;123456&quot;/&gt;
        o-&gt;
    jasig cas
api
    Subject: 主体, 如用户
    SecurityManager: 安全管理器, 管理subject
    Realm: 权限数据域

    授权
        对象流程
            Subject.isPermitted -&gt; SecurityManager -&gt; Authorizer
        对象
            ModularRealmAuthorizer        # 多realm授权
            PermissionResolver                # 解析权限字符串到Permission实例
            RolePermissionResolver                # 从角色得到权限集合
配置
    参数
        filterChainDefinitions
            rest：比如/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user：method] ,其中method为post，get，delete等。

            port：比如/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal：//serverName：8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。

            perms：比如/admins/user/**=perms[user：add：*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，比如/admins/user/**=perms[&quot;user：add：*,user：modify：*&quot;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。

            roles：比如/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，比如/admins/user/**=roles[&quot;admin,guest&quot;],每个参数通过才算通过，相当于hasAllRoles()方法。

            anon：比如/admins/**=anon 没有参数，表示可以匿名使用。

            authc：比如/admins/user/**=authc表示需要认证才能使用，没有参数

            authcBasic：比如/admins/user/**=authcBasic没有参数表示httpBasic认证

            ssl：比如/admins/user/**=ssl没有参数，表示安全的url请求，协议为https

            user：比如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查
                    # remember me可登录
</code></pre>

<h2 id="企业资源计划">企业资源计划</h2>

<pre><code># erp
activiti
    # 工作流
YAML
    # 工作流
bossa
    # 工作流引擎
azkaban
    # 开源oa
grav
    # 开源cms
nopCommerce
    # .net开源电商
</code></pre>

<h3 id="jbpm">jbpm</h3>

<pre><code># 常识
    适用对象：业务逻辑不复杂，业务流程会变化
        # s2sh适合业务逻辑复杂，但是业务流程不会变化的项目
    jbpm封装hibernate
    包含对象
        模型
        实例（由活动组成，包括活动、箭头等）
        任务（需要人办理的活动）


# 使用
    myeclipse添加jbpm xml画图插件
        MyEclipse -&gt; MyEclipse Configuration Center -&gt; Software -&gt; Browse Software(add site) -&gt; add from archive file找到jbpm-gpd-site.zip,取名为jbpm4.4 -&gt; Browse Software(Personal Sites -&gt; jbpm4.4下8个选项)右键add to Profile -&gt; 右下角apply changes -&gt; 重启myeclipse -&gt; 新建文件中找到新建jbpm xml文件
        画图
            test.jpdl.xml文件用jbpm工具打开
            打开Properties视图
    配置
        jbpm.hibernate.cfg.xml                # mysql方言要配置InnoDB的方言（因为jbpm建表时对表指定了type=InnoDB约束）
        配置hibernate的5个映射文件（导入的jbpm.jar包中有）
            &lt;mapping resource=&quot;jbpm.repository.hbm.xml&quot; /&gt;
            &lt;mapping resource=&quot;jbpm.execution.hbm.xml&quot; /&gt;
            &lt;mapping resource=&quot;jbpm.history.hbm.xml&quot; /&gt;
            &lt;mapping resource=&quot;jbpm.task.hbm.xml&quot; /&gt;
            &lt;mapping resource=&quot;jbpm.identity.hbm.xml&quot; /&gt;
        jbpm.cfg.xml:

    api
        hibernate的api:org.hibernate.cfg.Configuration()
            .configure(&quot;jbpm.hibernate.cfg.xml&quot;).buildSessionFactory();进行hibernate配置文件加载测试
        delete_deployment       # 有实例时不能删除
                                # 级联删除时出现constraintViolationException的原因：
                                ## jbpm4.4下载包中/install/src/db/create/下有创建jbpm各个数据库时用到的sql文件
                                ##　如果是mysql数据库，其中表有type=InnoDB约束。该约束的方言类为hibernate-core.jar包下/org.hibernate.dialect.MySQLInnoDBDialect的类文件
                                ## ，在hibernate的配置文件中配置该方言就可以解决问题
# 表结构
    表
        模型
            jbpm4_deployment
            jbpm4_lob
            jbpm4_deployprop
        实例
            jbpm4_execution
            jbpm4_hist_procinst
            jbpm4_task
            jbpm4_hist_task
        活动
            jbpm4_hist_actinst
        变量
            jbpm4_variable

    id关联
</code></pre>

<h2 id="游戏">游戏</h2>

<pre><code>pomelo
    # node.js上网易开源的实时性好的游戏类服务器
</code></pre>

<h2 id="地理信息">地理信息</h2>

<pre><code>ide
        skylive
        arcGIS
        mapInfo
        mapGIS
        superMap

webglobe
arcpy
</code></pre>

<h2 id="人工智能">人工智能</h2>

<pre><code>tensorflow
        # 神经网络计算
convnet.js
        # js深度学习
scikit-learn
        # python机器学习
</code></pre>

<h2 id="领域语言">领域语言</h2>

<pre><code>lex
        # 生成词法分析程序
yacc
        # 生成自底向上语法分析程序
antlr
</code></pre>

<h1 id="组件">组件</h1>

<pre><code># 数件物品组合成一体，每一件没有独立使用价值
</code></pre>

<h2 id="高可用-性能">高可用 | 性能</h2>

<pre><code>retry
    # js retry
ehcache
    # 缓存
tagg
        # node线程池
cluster
        # node单机集群
fiber
        # node协程
</code></pre>

<h2 id="pc控制">pc控制</h2>

<pre><code>later
    # nodejs corntab
glob
    # nodejs 匹配获得文件
rd
    # node 遍历文件
commander
    # node制作命令
mkdirp
    # node 递归makedir
fs-extra
    # node扩展fs包
</code></pre>

<h2 id="生成-加密-计算特征">生成 | 加密 | 计算特征</h2>

<pre><code>simhash
        # google 文档hash
pygments
        # python 生成高亮html
mako
        # python 模板
jinja2
        # python 模板
freemarker
        # java 模板
proguard
    # java 混淆
</code></pre>

<h2 id="日志-1">日志</h2>

<pre><code>log4j
    # java
log4js
    # js
</code></pre>

<h2 id="客户端">客户端</h2>

<pre><code>c3p0
    # java rds 连接池
dbcp
    # java rds 连接池
druid
    # java rds 连接池
jdbc
    # java rds client
dbutil
hibernate
ef
    # .net orm
NHibernate
    # .net orm
peewee
    # python orm
node-mysql
mongoose
httpClient
    # java http
request
    # js http
superagent
    # js http
</code></pre>

<h3 id="mybatis">mybatis</h3>

<pre><code># 基础
    #与$
        #相当于解析成引号, 防止sql注入
        $变量引用, 不能防止sql注入，用于传入表名之类
    特点
        sql易维护，传参方便
        orm
    Mapper接口
        方法名与配置id相同
        输入输出参数类型对应定义的parameterType类型和resultType类型
        类路径是配置的namespace
    缓存
        # 基于PerpetualCache的HashMap
        一级缓存
            存在本地
            作用域为session, session flush后清空
        二级缓存
            可定义存储服务
            作用域为namespace
            配置
                &lt;cache/&gt;
                    readOnly=&quot;true&quot; 时，缓存实例单例，false时返回缓存拷贝
        更新
            create, update, delete后，作用域下所有select缓存clear
# 与hibernate区别
    都通过SessionFactoryBuilder从配置生成SessionFactory, 再生成Session
    都支持jdbc和jta
    mybatis可细致优化sql, hibernate移植性好
    mybatis学习成本低
    mybatis本身缓存不好，hibernate对象维护和缓存好
    hibernate dao层封开发简单(不用维护映射)，crud方便



# 使用
    编程
        创建SqlSessionFactory
        创建SqlSession
        执行数据库操作
        session.commit()
        session.close()


    导入ibatis jar包
    配置文件
        SqlMap.properties        # 属性名可以修改
            driver=oracle.jdbc.driver.OracleDriver
            url=jdbc:oracle:thin:@127.0.0.1:1521:orcl
            username=root
            password=root
        SqlMapConfig.xml                # 总配置文件
            &lt;sqlMapConfig&gt;
                &lt;properties recource=&quot;SqlMap.properties&quot;/&gt;
                &lt;transactionManager type=&quot;JDBC&quot;&gt;
                        &lt;dataSource type=&quot;SIMPLE&quot;&gt;
                                &lt;property value=&quot;${driver}&quot; name=&quot;JDBC.Driver&quot;/&gt;
                                &lt;property value=&quot;${url}&quot; name=&quot;JDBC.ConnectionURL&quot;/&gt;
                                &lt;property value=&quot;${username}&quot; name=&quot;JDBC.Username&quot;/&gt;
                                &lt;property value=&quot;${password}&quot; name=&quot;JDBC.Password&quot;/&gt;
                        &lt;/dataSource&gt;
                    &lt;sqlMap resource=&quot;Student.xml&quot;/&gt;
                &lt;/transactionManager&gt;
            &lt;/sqlMapConfig&gt;
        Student.xml                                # 映射xml文件
            &lt;sqlMap&gt;
                &lt;typeAlias alias=&quot;Student&quot; type=&quot;com.Student&quot;/&gt;
                    &lt;select id=&quot;selectAllStudent&quot; resultClass=&quot;Student&quot;&gt;
                        select * from Student
                    &lt;/select&gt;
                &lt;/typeAlias&gt;
            &lt;/sqlMap&gt;
        辅助类Student.java                 # 要求有无参构造方法
            private sid = 0;
            private String name = null;
            private String major = null;
            private Date birth = null;
            private float score = 0;
    Xxx.java
        private static SqlMapClient sqlMapClient = null;
        static{
            Reader reader = Resources.getResourceAsReader(总配置文件);
            sqlMapClient = SqlMapClientBuilder.buildSqlMapClient(reader);
            reader.close();
        }
        public List&lt;Student&gt; queryAllStudent(){
            List&lt;Student&gt; studentList = sqlMapClient.queryForList(&quot;selectAllStudent&quot;);
            return studentList;
        }
        @Test
        public void testHere(){
            for(Student student: this.queryAllStudent()){
                System.out.println(student.getName);
            }
        }
# 配置
    sqlMapConfig.xml
        mybatis加载属性顺序
                properties中property中的属性
                properties中resource或url中的属性
                parameterType中传递一属性
                        # properties中配的属性会影响到mapper.xml中${}的sql拼接，因为都是ognl
        配置标签
                properties
                settings
                        # ibatis有性能优化的参数，mybatis会自动调优，不用设置了
                typeAliases
                        # 针对parameterType和resultType指定的类型定义别名
                        # java.lang.Integer在mybatis中默认别名为int
                typeHandlers
                        # 类型处理器，jdbc类型和java类型的转换
                        ## 一般mybatis提供的类型处理器够用了
                objectFactory
                plugins
                environments
                mappers
    mapper.xml
        内容
                #{}接收简单类型, pojo的ognl属性注入
                ${}是字符串的拼接

        SELECT * FROM USER WHERE id=#{id}
        SELECT * FROM USER WHERE username LIKE '%${value}%'
                                        # sql 注入
    输入输出映射
        parameterType
                java类型
                hashmap
                        # #{key}来取value
                pojo
                包装类型
        resultType
                        # 指定一条数据的类型，在java方法的返回类型中list或pojo来体现数据条数
                        # mybatis判断mapper代理中使用selectOne或者selectType
                pojo
                        # 返回字段可以是别名，但要与pojo中的属性名相同
                        ## 如果有记录返回但没有pojo中匹配的属性名对应，则直接不创建该对象
                java类型
                        # 在返回结果只有一行一列时，可以是简单类型
                hashmap
                        # key是字段的字，value是字段的值
                        ## 多条数据时，list里面存hashmap
        resultMap
                        # 查询出来的字段名与pojo属性名不一致
                定义resultMap
                使用resultMap
    动态sql
        &lt;where&gt;
        &lt;if&gt;

        sql片段&lt;sql&gt;

        &lt;foreach&gt;
    高级映射
    缓存
    逆向
        要求
                1. mapper.xml中namespace 写mapper接口
                        &lt;mapper namespace=&quot;com.otr.tea.mapper.UserMapper&quot;&gt;
                2. mapper.java中方法名与mapper.xml的statementid一致
                3. mapper.java中方法的输入类型与mapper.xml中的parameterType一致
                        # 由于传入的参数只有一个，所以用包装类型的pojo来传多个参数，不利于业务层的可扩展性
                4. mapper.java中方法的返回类型与mapper.xml中的resultType一致
        机制
                如果Mapper中返回类型为pojo, 则调用selectOne, 如果是List, 则调用selectList
# api
    sqlSessionFactory
    sqlSession                        # 是线程不安全的，因为它的类中有数据和属性
                                            ＃ 是多例的，在方法中局部变量使用
            Executor                # 执行器操作数据库（基本执行器，缓存执行器）
    mapped statement                # 封装sql语句、输入参数、输出结果类型

    例子
        InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
                # Resources是mybatis提供的资源加载类
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = factory.openSession();
        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);
                ＃ selectList()
                # insert(&quot;test.insertUser&quot;, user)
                ## sqlSession.commit();
                ## user.getId() 会主键返回
                ### mysql中LAST_INSERT_ID()在insert语句后接着执行可以得到刚刚自成的id
        sqlSession.close();
# 案例
    返回id
        mysql
            &lt;insert id=&quot;insert&quot; parameterType=&quot;com.test.User&quot; keyProperty=&quot;userId&quot; useGeneratedKeys=&quot;true&quot; &gt;
        oracle
            &lt;insert id=&quot;insert&quot; parameterType=&quot;com.test.User&quot;&gt;
                &lt;selectKey resultType=&quot;INTEGER&quot; order=&quot;BEFORE&quot; keyProperty=&quot;userId&quot;&gt;
                    SELECT SEQ_USER.NEXTVAL as userId from DUAL
                &lt;/selectKey&gt;

                insert into user (user_id, user_name, modified, state)
                values (#{userId,jdbcType=INTEGER}, #{userName,jdbcType=VARCHAR},
                #{modified,jdbcType=TIMESTAMP}, #{state,jdbcType=INTEGER})
            &lt;/insert&gt;
</code></pre>

<h2 id="格式">格式</h2>

<pre><code>moment
        # js格式化时间
iconv
        # nodejs调用c++ libiconv库来转码
iconv-lite
        # nodejs实现的转码，比调用c++ 的iconv更高效
poi
        # java 文件处理
jFreeChart
        # java图表库
jackson
        # java json序列化
xstream
        # java xml序列化
</code></pre>

<h2 id="邮件">邮件</h2>

<pre><code>javamail
nodemailer
</code></pre>

<h2 id="前端">前端</h2>

<h3 id="dwr">dwr</h3>

<pre><code>介绍
    java函数通过ajax映射到前端js调用
使用
    ajax框架
    1.导入jar包 dwr.jar
    2.web-inf/下的配置文件
        web.xml文件
            &lt;servlet&gt;
                &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt;
                &lt;servlet-class&gt;org.directwebremoting.servlet.DwrServlet&lt;/servlet-class&gt;
                        # 固定写法
                &lt;init-param&gt;
                        &lt;param-name&gt;debug&lt;/param-name&gt;
                        &lt;param-value&gt;true&lt;/param-value&gt;
                &lt;/init-param&gt;
                &lt;init-param&gt;
                        &lt;param-name&gt;scriptCompressed&lt;/param-name&gt;        # 允许在javascript中执行
                        &lt;param-value&gt;false&lt;/param-value&gt;
                &lt;/init-param&gt;
                &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;        # web工程启动时加载
            &lt;/servlet&gt;
            &lt;servlet-mapping&gt;
                &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt;
                &lt;url-pattern&gt;/dwr/*&lt;/url-pattern&gt;
            &lt;/servlet-mapping&gt;
        dwr.xml文件
            &lt;dwr&gt;
                &lt;allow&gt;
                    &lt;create creator=&quot;new&quot; javascript=&quot;DWRUserAccess&quot;&gt;        # 生成js文件的名（页面中引用）
                            &lt;param name=&quot;class&quot; value=&quot;outrun.dwr.DWRUserAccess&quot; /&gt;                # 曝露的类
                    &lt;/create&gt;
                    &lt;convert converter=&quot;bean&quot; match=&quot;outrun.dwr.User&quot; /&gt;        # 注册实体类，可以在js中进行实例化
                &lt;/allow&gt;
            &lt;/dwr&gt;
    3.写outrun.dwr.DWRUserAccess中的方法
    4.页面调用
        test.html
            &lt;script src=&quot;/outrun/dwr/engine.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;/outrun/dwr/util.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;/outrun/dwr/interface/DWRUserAccess.js&quot;&gt;&lt;/script&gt;
            &lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;
                DWRUserAccess.方法(参数,执行完运行的js函数)
                    # 参数可以是一个map,如
                        var userMap = {};
                        userMap.id = regForm.id.value;
                        userMap.password = regForm.password.value;
                        userMap.name = regForm.name.value;
                        userMap.email = regForm.email.value;
                        DWRUserAccess.save(userMap, saveFun);
                                # 其中的regForm是页面中的表单（的name属性,dom支持直接使用名字引用表单）
            &lt;/SCRIPT&gt;
</code></pre>

<h2 id="图形">图形</h2>

<pre><code>ccap
        # 基于c++的图形CImg库，就是一个CImg.h文件
canvas
        # node canvas
tesseract
        # node 验证码
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/hugo-blog/commit/37e76d5e09e9780b64056ab9c8a3827a2628f8fb" title='Last modified Jul 19, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Jul 19, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/hugo-blog/tree/master/content/docs/backend/_index.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#名词">名词</a></li>
<li><a href="#写法">写法</a>
<ul>
<li><a href="#ejb">ejb</a></li>
</ul></li>
<li><a href="#套件">套件</a>
<ul>
<li><a href="#接口">接口</a>
<ul>
<li><a href="#connect">connect</a></li>
<li><a href="#express">express</a></li>
<li><a href="#koa">koa</a></li>
</ul></li>
<li><a href="#实时">实时</a>
<ul>
<li><a href="#socket-io">socket.io</a></li>
</ul></li>
<li><a href="#展示">展示</a>
<ul>
<li><a href="#spring-mvc">spring mvc</a></li>
<li><a href="#struts2">struts2</a></li>
<li><a href="#cleaver">cleaver</a></li>
<li><a href="#hexo">hexo</a></li>
<li><a href="#hugo">hugo</a></li>
<li><a href="#jekyll">jekyll</a></li>
</ul></li>
<li><a href="#搜索">搜索</a>
<ul>
<li><a href="#lucene">lucene</a></li>
<li><a href="#solr">solr</a></li>
</ul></li>
<li><a href="#数据">数据</a>
<ul>
<li><a href="#日志">日志</a></li>
<li><a href="#爬虫">爬虫</a></li>
<li><a href="#分析">分析</a></li>
<li><a href="#计算">计算</a>
<ul>
<li><a href="#hadoop">hadoop</a></li>
</ul></li>
</ul></li>
<li><a href="#权限">权限</a>
<ul>
<li><a href="#shiro">shiro</a></li>
</ul></li>
<li><a href="#企业资源计划">企业资源计划</a>
<ul>
<li><a href="#jbpm">jbpm</a></li>
</ul></li>
<li><a href="#游戏">游戏</a></li>
<li><a href="#地理信息">地理信息</a></li>
<li><a href="#人工智能">人工智能</a></li>
<li><a href="#领域语言">领域语言</a></li>
</ul></li>
<li><a href="#组件">组件</a>
<ul>
<li><a href="#高可用-性能">高可用 | 性能</a></li>
<li><a href="#pc控制">pc控制</a></li>
<li><a href="#生成-加密-计算特征">生成 | 加密 | 计算特征</a></li>
<li><a href="#日志-1">日志</a></li>
<li><a href="#客户端">客户端</a>
<ul>
<li><a href="#mybatis">mybatis</a></li>
</ul></li>
<li><a href="#格式">格式</a></li>
<li><a href="#邮件">邮件</a></li>
<li><a href="#前端">前端</a>
<ul>
<li><a href="#dwr">dwr</a></li>
</ul></li>
<li><a href="#图形">图形</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
