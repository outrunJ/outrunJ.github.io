<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Principle
  
 | outrun的笔记</title>



<link rel="stylesheet" href="/book.min.1a0250256273fabf0f848ed9a3c50aae344d758339cad9725e656ac71546e6f5.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">outrun的笔记</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f backend\2fprinciple\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/project">项目</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/markup_language"><strong><em>标记语言</em></strong></a>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
<li><a href="/docs/architecture/nodejs">nodejs</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/principle">原理</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/javaweb">javaweb</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">pgsql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/linux_tool">linux工具</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a></li>
<li><a href="/docs/tool"><strong>图形工具</strong></a>

<ul>
<li><a href="/docs/tool/vim">vim</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
</ul></li>
<li><a href="/docs/management">管理</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/interview">题目</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Principle
  
</strong>
</header>

      
<article class="markdown">

<h1 id="并发并行">并发并行</h1>

<pre><code>并发
    为什么: 多任务能力，非阻塞
    类比: 任务队列
并行
    为什么: 提高执行效率
    类比: 多核处理器
    并行代码：编译代码顺序不确定，或执行顺序不确定
    面临竞争问题
    业务并行
        解耦业务
        业务满足幺半群性质
            封闭性     # 业务运算结果是业务
            结合律     # 业务a、b的结果后与c执行，等同b、c的结果与a执行
            单位元     # 单位业务a与其它业务b执行，得b
系统应用
    并发能力
    吞吐量(并行)
        I/O多路复用(epoll)
        cpu&quot;多路复用&quot;(进程、线程)
        cpu机制(多发射、流水线、超标量、超线程)
进程线程应用
    cpu对任务的M:N处理
    进程切换
    线程(共用地址空间、文件描述符，通信，并行)
为什么用户实现协程
    进程/线程 切换开销大
    空间资源占用大
异步编程
    回调(监听器), 链式(promise)，同步(async)
异步实现
    事件处理器
        调度方式: 单线程循环
    协程
        用户态，寄存器+栈, 让出
        调度方式: 单线程调度, M:N
概念
    过度竞争
        过多线程尝试同时使用一个共享资源
    同步  # 直接相互制约
    互斥  # 间接相互制约
        竞态条件(race condition)
    异步
        # 与同步相对。多线程是实现异步的一种手段
    可见性
        线程总可见到最后修改的数据, 脏读是反例
    原子性
        查看和修改同时发生
    乱序执行
        # java 中标记volatile的变量可以不乱序执行, 现多用原子变量
        编译器或JVM的静态优化可以打乱代码执行顺序(java)
        硬件可以通过乱序执行来优化性
    死锁  # 多线程竞争资源而互相等待
        条件
            互斥      # 资源排他
            不剥夺    # 资源不被外力剥夺
            请求和保持条件     # 线程已保持一个资源，请求新资源。请求被阻塞而自己资源保持
            循环等待    # 阻塞线程形成环
        方案
            锁按顺序获得  # a,b,c锁，要得c手中要有a, b
                # 使用锁的地方比较零散时，遵守此顺序变得不实际
                # 可以用对象散列值作全局顺序减小死锁机率
            阻塞加时限
            # 外星方法中可能包含另一把锁，要避免在持锁时调用外星方法
</code></pre>

<h2 id="线程">线程</h2>

<pre><code>线程池
    作用
        重复利用, 降低资源消耗
        提高响应速度，不等线程创建
        可管理，线程是稀缺资源，统一分配，调优和监控，提高系统稳定性
</code></pre>

<h2 id="锁">锁</h2>

<pre><code>锁
    公平锁         # FIFO取锁
    非公平锁        # 每次直接占有
    乐观锁         # 假设最好，有冲突时重试
    悲观锁         # 假设最坏，等所有线程释放成功
    互斥锁(mutex)
        # 访问前加锁，访问后解锁
        悲观锁
            读加锁
        乐观锁
            读不加锁，写时判断数据版本是否修改，再重试
    读写锁 rwlock
        状态
            读加锁状态
                可个线程占用
                阻塞写线程
                    # 导致写线程抢占不到资源，所以有写线程时，阻塞后进入的读线程
            写加锁状态
                一次只有一个线程占用
                阻塞所有线程
            不加锁状态
    自旋锁 spinlock
        互斥锁改，自己进入循环等待状态(忙等)
            # 适合锁持有时间较短
    RCU锁 Read-Copy Update
        读写锁改，一个写线程，读线程无限制
            实现垃圾回收器
            写线程copy副本修改，向垃圾回收器注册callback以执行真正的修改
            垃圾回收器收到信号，所有读线程结束，执行callback
    可重入锁
        # 互斥锁改，允许同一线程多次获得写锁
    管程(monitor)
    临界区(critical section)
    内置锁、显示锁
        # 指java的synchronized与Reentrantlock
信号量
    进程, 线程间通知状态
</code></pre>

<h2 id="cas">CAS</h2>

<pre><code># compare and swap，无锁算法(lock free), 非阻塞(non-blocking), 构成基本的乐观锁
# cpu实现的指令
3个操作数
    # V的值为A时，原子更新成B，否则无操作。返回V的值
    需要读写的内存位置V
    进行比较的值A
    拟写入的新值B
</code></pre>

<h2 id="函数式">函数式</h2>

<pre><code>介绍
    消除可变状态
概念
    命令式语言中，求值顺序与源码的语句顺序紧密相关(有可能乱序执行)
    函数式程序并不描述&quot;如何求值以得到结果&quot;，而是描述&quot;结果应当是什么样的&quot;。函数式编程中，如何安排求值顺序相对自由
    引用透明性
        # 任何调用函数的地方，都可以用函数运行结果来替换函数调用，而不会产生副作用
    数据流式编程(dataflow programming)
        # (+ (+ 1 2) (+ 3 4))就是一个数据流，所有函数都可以用时执行
        future模型
</code></pre>

<h2 id="分离标识与状态">分离标识与状态</h2>

<pre><code>介绍
    Clojure, 指令式编程和函数式编程混搭

clojure四种并发模型
    vars (thread-local)
    atoms原子变量
    agent代理
    refs引用 与 ATM软件事务内存
</code></pre>

<h2 id="actor模型">actor模型</h2>

<pre><code>介绍
    作为actor自己修改自己的数据，对外提供消息，处理对外消息
    共享内存模型和分布式内存模型，适合解决地理分布型问题，强大的容错性
    基于消息传递，侧重通道两端实体
    每个actor有一个mailbox, mailbox中转消息
</code></pre>

<h2 id="csp">csp</h2>

<pre><code>介绍
    通信顺序进程(communicating sequential processes)
    基于消息传递，侧重信息通道
</code></pre>

<h2 id="数据级并行">数据级并行</h2>

<pre><code># 不可变数据
</code></pre>

<h2 id="lambda架构">lambda架构</h2>

<pre><code>介绍
    综合MapReduce和流式处理的特点，处理大数据问题的架构
</code></pre>

<h1 id="状态保持">状态保持</h1>

<pre><code>cookie
    分域名, 客户端保存服务器定义数据, 请求时发送
session
    服务器id数据，id下发到客户端
    共享
        # 同时多方案，动态切换 zookeeper切换环境变量与重启
        # java中filter重写request getSession
        webSphere或JBoss可配置session复制或共享
            # 不好扩展和移植
        加密存cookie
        服务
            redis
            memorycache
            gemfire     # 12306
</code></pre>

<h1 id="认证">认证</h1>

<pre><code>单点登录
    sessionID存cookie, cookie禁用存头域
token
    类型
        access token
            # 标识唯一用户
            user_id
            issue_time
                # token发放时间，单位秒
            ttl
                # 有效时间，uint16,单位分钟
            mask
                # int128, 按bit分组用户，用于批量封禁或其它功能
        refresh token
            # 用来换access token，与access token同时发放
            # 过期时间更长
    实现
        redis存储
        token不要太长
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/hugo-blog/commit/37e76d5e09e9780b64056ab9c8a3827a2628f8fb" title='Last modified Jul 19, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Jul 19, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/hugo-blog/tree/master/content/docs/backend/principle.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#并发并行">并发并行</a>
<ul>
<li><a href="#线程">线程</a></li>
<li><a href="#锁">锁</a></li>
<li><a href="#cas">CAS</a></li>
<li><a href="#函数式">函数式</a></li>
<li><a href="#分离标识与状态">分离标识与状态</a></li>
<li><a href="#actor模型">actor模型</a></li>
<li><a href="#csp">csp</a></li>
<li><a href="#数据级并行">数据级并行</a></li>
<li><a href="#lambda架构">lambda架构</a></li>
</ul></li>
<li><a href="#状态保持">状态保持</a></li>
<li><a href="#认证">认证</a></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
