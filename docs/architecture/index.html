<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    
    Architecture
  
 | outrun的笔记</title>



<link rel="stylesheet" href="/book.min.1a0250256273fabf0f848ed9a3c50aae344d758339cad9725e656ac71546e6f5.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="https://example.com/docs/architecture/index.xml" title="outrun的笔记" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">outrun的笔记</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f architecture\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/project">项目</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/principle">原理</a></li>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/markup_language"><strong><em>标记语言</em></strong></a>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
<li><a href="/docs/architecture/3rd_product">第三方服务</a></li>
<li><a href="/docs/architecture/nginx">nginx</a></li>
<li><a href="/docs/architecture/nodejs">nodejs</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/principle">原理</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/javaweb">javaweb</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">pgsql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/linux_tool">linux工具</a></li>
<li><a href="/docs/ops/security">安全</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a></li>
<li><a href="/docs/tool"><strong>图形工具</strong></a>

<ul>
<li><a href="/docs/tool/vim">vim</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
</ul></li>
<li><a href="/docs/method">方法</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/interview">题目</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    
    Architecture
  
</strong>
</header>

      
<article class="markdown">

<h1 id="名词">名词</h1>

<pre><code>Alb        automaticLoopBack 自动回环，虚拟接口
sdn        software defined network 软件定义网络
</code></pre>

<h1 id="service-mesh">service mesh</h1>

<pre><code># 服务网格
</code></pre>

<h2 id="service-fabric">service fabric</h2>

<pre><code># 微软
</code></pre>

<h2 id="lstio">lstio</h2>

<pre><code>#google IBM, lyft开源，基于envoy
组成
    数据面板
    控制面板
</code></pre>

<h2 id="linkerd">linkerd</h2>

<pre><code># buoyant出品
</code></pre>

<h2 id="conduit">conduit</h2>

<pre><code># 面向k8s轻量化mesh
</code></pre>

<h2 id="fingle">fingle</h2>

<pre><code># twitter出品
</code></pre>

<h2 id="envoy">envoy</h2>

<pre><code># lyft出品
</code></pre>

<h2 id="nginmesh">nginmesh</h2>

<pre><code># nginx推出
</code></pre>

<h1 id="paas">paas</h1>

<pre><code># platform as a service
</code></pre>

<h2 id="cloudstack">cloudStack</h2>

<pre><code># 托管在apache的开源、高可用、高扩展性的云计算平台
# 支持主流hypervisors
# 一个开源云计算解决方案，可以加速iaaS的部署、管理、配置
</code></pre>

<h2 id="cloudfoundry">cloudfoundry</h2>

<pre><code># 根据应用模板，动态生成很多tomcat, mysql, nosql, 动态控制这些实例的启停。
</code></pre>

<h2 id="openstack">openstack</h2>

<pre><code># 云操作系统，管理虚拟资源
</code></pre>

<h1 id="分布式服务-容器调度编排">分布式服务(容器调度编排)</h1>

<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">dubbo</th>
<th align="left">spring cloud</th>
<th align="left">k8s</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">配置管理</td>
<td align="left">-</td>
<td align="left">config</td>
<td align="left">k8s configMap</td>
</tr>

<tr>
<td align="left">服务发现</td>
<td align="left">zookeeper</td>
<td align="left">eureka, consul, zookeeper</td>
<td align="left">k8s services</td>
</tr>

<tr>
<td align="left">负载均衡</td>
<td align="left">自带</td>
<td align="left">ribbon</td>
<td align="left">k8s services</td>
</tr>

<tr>
<td align="left">网关</td>
<td align="left">-</td>
<td align="left">zuul</td>
<td align="left">k8s services</td>
</tr>

<tr>
<td align="left">分布式追踪</td>
<td align="left">-</td>
<td align="left">spring cloud sleuth</td>
<td align="left">open tracing</td>
</tr>

<tr>
<td align="left">容错</td>
<td align="left">不完善</td>
<td align="left">hystrix</td>
<td align="left">k8s health check</td>
</tr>

<tr>
<td align="left">通信方式</td>
<td align="left">rpc</td>
<td align="left">http, message</td>
<td align="left"></td>
</tr>

<tr>
<td align="left">安全模块</td>
<td align="left">-</td>
<td align="left">spring cloud security</td>
<td align="left">-</td>
</tr>

<tr>
<td align="left">分布式日志</td>
<td align="left"></td>
<td align="left">ELK</td>
<td align="left">EFK</td>
</tr>

<tr>
<td align="left">任务管理</td>
<td align="left"></td>
<td align="left">spring batch</td>
<td align="left">k8s jobs</td>
</tr>
</tbody>
</table>

<h2 id="kubernetes">kubernetes</h2>

<pre><code># google开源的，borg的发展，在docker技术上，管理容器化应用
特点
    不限语言
    无侵入, 服务只写业务
    适合微服务                       # 调整服务副本数, 横向扩容
    无缝迁移到公有云                  # cluster ip实现不改配置迁移
    自动化资源管理
        服务发现，用dns解析服务名
        内嵌负载均衡
        部署实施
        治理
        监控
        故障发现、自我修复
        透明服务注册、发现
        服务滚动升级、在线扩容, 根据负载自动扩容缩容
        可扩展资源自动调度、多粒度资源配额
    多层安全防护、准入
    多租户
    完善的工具

    pod运行容器
    etcd保存所有状态
架构
    cluster
        master
            api server              # 对外http rest接口, 管理资源对象(pod, RC, service)增删改查
            controller manager      # 管理控制器, node, pod, endpoint, namespace, serviceAccount, resourceQuota自动化管理
            scheduler               # 接收controller manager命令执行pod调度
            etcd                    # 配置
        node                        # 一master多node
            特点
                node宕机，pod调度到其它节点
            pod                     # 一node几百个pod, 基本操作单元，代表一个运行进程，内部封装一个(或多个紧密相关的)容器。
                特点
                    pod内通信高效，放密切相关服务进程
                    可以判断一组相关容器的状态(用pause)
                    pause解决共享ip、容器通信、共享文件的问题
                    pod间通信用虚拟二层协议(flannel, openvswitch)实现
                    普通pod在etcd存储，再调度到某node实例化，静态pod在node中存储，在node实例化
                    对pod可进行资源(cpu,内存)限额
                label               # 标签，用标签选择器选择。key和value由用户指定，可附加到node, pod, service, rc等
                pause容器            # 根容器，共享网络栈、挂载卷
            docker/rocket           # 容器
            kubelet                 # master监视pod, 创建、修改、监控、删除
            kube-proxy              # 代理pod接口
            fluentd                 # 日志收集、存储、查询
            kube-dns                # 服务dns解析
概念
    service                         # 服务网关
        特点
            唯一名字
            唯一虚拟ip(cluster ip, service ip, vip)                  # 可多端口，每端口有名字
            提供远程服务              # 目前socket
            应用到一组pod
    event                           # 探针检测失败记录，用于排查故障
    rc                              # replication controller
        副本数
        筛选标签
        pod模板
        改变pod镜像版本，滚动升级
    replica set                     # 1.2 rc升级, 支持基于集合的标签选择。被deployment使用
    deployment                      # pod编排, rc升级
        特点
            查看pod部署进度
    HPA                             # horizontal pod autoscaler, 自动扩容缩容
        指标
            cpu utilization percentage                              # 1分钟内利用率平均值
            应用自定义指标(tps, qps)
    volume
        emptyDir
        hostPath
        gcePersistentDisk
        awsElasticBlockStore
        NFS
        persistent volume
        namespace
        annotation
动作
    扩容
        创建rc自动创建pod, 调度到合适的node
            pod定义
            副本数
            监控label                # 筛选pod得到数量
命令
    kubectl
        logs
            kubectl logs --tail=1000 appID1
                # 查看日志
        exec
            kubectl exec -it appID1 /bin/sh
                # 交互命令进入app
        create
            -f mysql-rc.yaml        # 创建rc
            -f mysql-svc.yaml       # 创建service
        get
            rc                      # 查看rc
            pods
            pod
                kubectl get pod -l app=app1 -o wide
                    # 查看pod app状态
            services
            svc                     # 查看service, 包含cluster ip
            nodes
            endpoints               # service pod的ip:端口
        describe                    # 详情
            node
            deployments
        scale                       # pod扩容或缩容
        autoscale                   # 创建hpa对象
            deployment
        rolling-update              # pod滚动升级
        apply                       # 应用配置
            -f
配置
    用yaml或json定义
    pod
        kind: Pod                   # 表明是Pod
        metadata:
            name: myweb             # pod名
            labels:
                name: myweb         # 标签
</code></pre>

<h2 id="spring-cloud">spring cloud</h2>

<pre><code>介绍
    spring boot基础上构建，快速构建分布式系统
    面向云环境架构(云原生)    # 适合在docker和paas部署
功能
    配置管理
    服务发现
    熔断
    智能路由
    微代理
    控制总线
    分布式会话
    集群状态管理
子项目
    spring cloud netflix    # 对netflix oss套件整合
        eureka     # 服务治理(注册、发现)
        hystrix    # 容错管理
        ribbon     # 软负载均衡(客户端)
        feign      # 基于hystrix和ribbon，服务调用组件
        zuul       # 网关，智能路由、访问过滤
        archaius   # 配置
    spring cloud config     # 应用配置外部化, 推送客户端配置
    spring cloud bus        # 消息总线，传播集群状态变化来触发动作
    spring cloud security   # 应用安全控制
    spring cloud consul     # 封装consul(服务发现与配置, 与docker无缝)
    spring cloud sleuth     # 跟踪
</code></pre>

<h2 id="dubbo">Dubbo</h2>

<pre><code>介绍
    阿里开源，分布式服务框架，rpc方案，soa治理
功能
    远程通讯    # 多协议，多种长连接nio框架封装
    集群容错    # 负载均衡，容错，地址路由，动态配置
    自动发现    # 注册中心
节点
    容器(container)
    提供者(provider)
    消费者(consumer)
    注册中心(registry)
    监控中心(monitor)
    调用关系
        容器启动提供者
        提供者注册
        消费者订阅
        注册中心返回地址列表, 长连接更新
        消费者软负载均衡挑选列表中提供者
        提供者和消费者累计调用次数和时间，定时发送到监控中心
容错机制
    failover    # 默认，失败自动切换
    failfast    # 立即报错，用于幂等写操作
    failsafe    # 忽略
    failback    # 定时重发
    forking     # 并行多个取最快(any)
    broadcast   # 逐个多个，异常退出
连接方式
    广播
        服务端配置 applicationContext-service.xml
            &lt;dubbo:application name=”taotao-manager-service” /&gt;
            &lt;dubbo:registry address=”multicast://224.5.6.7:1234” /&gt;
            &lt;dubbo:protocol name=”dubbo” port=”20880” /&gt;
            &lt;dubbo:service interface=”com.taotao.manager.service.TestService” ref=”testServiceImpl” /&gt;
        客户端配置 springMVC.xml
            &lt;dubbp:application name=”taotao-manager-web” /&gt;
            &lt;dubbo:registry address=”multicast://224.5.6.7:1234” /&gt;
            &lt;dubbo:service interface=”com.taotao.manager.service.TestService” id=”testService”
            timeout=”10000000” /&gt;
    直连
        服务端配置
            &lt;dubbo:application name=”taotao-manager-service” /&gt;
            &lt;dubbo:registry address=”N/A” /&gt;
            &lt;dubbo:protocol name=”dubbo” port=”20880” /&gt;
            &lt;dubbo:service interface=”com.taotao.manager.service.TestService” ref=”testServiceImpl” /&gt; applicationContext-service.xml
        客户端配置 springMVC.xml
            &lt;dubbp:application name=”taotao-manager-web” /&gt;
            &lt;dubbo:service interface=”com.taotao.manager.service.TestService” id=”testService”
            timeout=”10000000” /&gt;
注册中心
    zookeeper
</code></pre>

<h2 id="orleans">orleans</h2>

<pre><code># .NET
</code></pre>

<h2 id="hsf">hsf</h2>

<pre><code># high-speed service framework, 阿里出品， socket直连
特点
    不增加中间点(稳定，高度可伸缩)
结构
    注册服务信息，推送服务地址
    基于osgi
组件
    服务提供者
    消费者
    地址服务器
    配置服务器               # 分布式配置
    规则服务(diamond)       # 设置(黑白名单，认证，权重，限流)与推送
</code></pre>

<h1 id="soa">soa</h1>

<pre><code># 面向服务架构 service oriented architecture
</code></pre>

<h2 id="eai">eai</h2>

<pre><code>    # Enterprise Application Integration 建立底层结构将异构应用集成
</code></pre>

<h2 id="esb">esb</h2>

<pre><code>    # Enterprise Service Bus 企业服务总线， 是连接中枢
</code></pre>

<h1 id="rpc">rpc</h1>

<pre><code># 远程过程调用 remote procedure call
</code></pre>

<h2 id="thrift">thrift</h2>

<h2 id="cxf">cxf</h2>

<pre><code>常识
    自己内部整合spring(但是不耦合)
支持的协议
    soap1.1/1.2
    post/http
    restful
    http
使用
    导入cxf包
    方法1      # 不支持注解
        String address=&quot;http://localhost:8888/hello&quot;;
            ServerFactoryBean factoryBean=new ServerFactoryBean();
            factoryBean.setAddress(address);
            factoryBean.setServiceBean(new MyWS());
            factoryBean.create();
    方法2      # 支持注解,wsdl文件中类型不再单独schema文件
        ServerFactoryBean factoryBean = new JaxWsServerFactoryBean      # java and xml web service
    日志    # 记录握手信息(访问wsdl文件)
            ## 看日志记录得到 soap
        serverFactoryBean.getInInterceptors().add(new LoggingInInterceptor());
        serverFactoryBean.getOutInterceptors().add(new LoggingOutInterceptor());
整合spring
    o-&gt; cxf2.4.4.jar/schemas/jaxws.xsd中找到命名空间&quot;http://cxf.apache.org/jaxws&quot;
    o-&gt; 配置applicationContext.xml，加入cxf的命名空间http://cxf.apache.org/jaxws,schema地址为http://cxf.apache.org/schemas/jaxws.xsd。
        并且在eclipse中配置schema约束文件的路径
            # 该xsd约束文件的url地址用的是包地址,不规范
    o-&gt; applicationContext.xml中配置
        &lt;bean id=&quot;studentService&quot; class=&quot;test.spring.StudentServiceImpl&quot;/&gt;
            # 用于：自身调用，被spring引用
        &lt;jaxws:server serviceClass=&quot;test.spring.StudentService&quot; address=&quot;/student&quot;&gt;
            # address配置服务的名称即可(web.xml的servlet中配置了服务的实际访问地址)
            ## serviceClass配置的才是真正的服务，既然它是接口，那么webService注解也应该写在接口上
            &lt;jaxws:serviceBean&gt;
                &lt;ref bean=&quot;studentService&quot;/&gt;
            &lt;jaxws:inInterceptors&gt;
                &lt;bean class=&quot;org.apache.cxf.interceptor.LoggingInInterceptor&quot; /&gt;
            &lt;jaxws:outInterceptors&gt;
                &lt;bean class=&quot;org.apache.cxf.interceptor.LoggingOutInterceptor&quot; /&gt;
    o-&gt; web.xml中配置servlet
         &lt;servlet&gt;
              &lt;servlet-name&gt;springWS
              &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet        # 在cxf-2.4.4.jar包中
              &lt;load-on-startup&gt;1
         &lt;servlet-mapping&gt;
              &lt;servlet-name&gt;springWS
              &lt;url-pattern&gt;/ws/*
    o-&gt; web.xml中配置spring监听器
</code></pre>

<h2 id="grpc">grpc</h2>

<h2 id="protobuf">protobuf</h2>

<pre><code># 通信协议
命令
    protoc -I. -I-I$GOPATH/src  --go_out=plugins=grpc:. *
        # -I import目录
    protoc --grpc-gateway_out=.
插件
    安装
        # go build 出protoc-gen-go后，放入go/bin下
    protoc-gen-go
        # 编译proto文件
    protoc-gen-grpc-gateway
        # http服务
</code></pre>

<h1 id="rmi">rmi</h1>

<pre><code># java远程调用 remote method invocation
</code></pre>

<h2 id="hessian">hessian</h2>

<pre><code># 是caucho公司的开源协议,基于http
</code></pre>

<h2 id="burlap">Burlap</h2>

<pre><code># caucho公房的开源协议,基于http
</code></pre>

<h2 id="httpinvoker">httpinvoker</h2>

<pre><code># spring提供的协议，必须用spring
</code></pre>

<h2 id="web-service">web service</h2>

<pre><code># soap通讯
</code></pre>

<h1 id="粘合层">粘合层</h1>

<h2 id="zookeeper">zookeeper</h2>

<pre><code>介绍
    google chubby的开源实现。用于服务发现
    分布式, hadoop中hbase的组件
    fast paxos算法        # paxos存在活锁问题, fast paxos通过选举产生leader, 只有leader才能提交proposer
功能
    配置维护
    域名服务
    分布式同步
    组服务
    分布式独享锁、选举、队列
流程
    选举leader        # 多种算法, leader有最高执行ID
    同步数据
    大多数机器得到响应follow leader
exhibitor
    # supervisor for zk
</code></pre>

<h2 id="gearman">gearman</h2>

<pre><code># 把工作委派给其他机器
</code></pre>

<h2 id="etcd">etcd</h2>

<pre><code># k8s中用到的服务发现仓库
</code></pre>

<h2 id="mesos">mesos</h2>

<pre><code># apache开源的分布式资源管理框架
</code></pre>

<h2 id="hystrix">hystrix</h2>

<pre><code>功能
    服务线程隔离、信号量隔离
    降级: 超时、资源不足
    熔断: 自动降级、快速恢复
    请求缓存、请求合并
</code></pre>

<h2 id="twemproxy">twemproxy</h2>

<pre><code>redis/memcache分片代理
</code></pre>

<h1 id="tracing">tracing</h1>

<h2 id="zipkin">zipkin</h2>

<h2 id="opentracing">opentracing</h2>

<h1 id="monitor">monitor</h1>

<h2 id="spy-js">spy.js</h2>

<pre><code># webstorm用的监控工具
</code></pre>

<h2 id="alinode">alinode</h2>

<pre><code># 朴灵写的运行时性能管理工具
</code></pre>

<h2 id="oneapm">oneapm</h2>

<pre><code># 监控node性能
功能
    接口响应时间
    数据库方法时间
    外部服务时间
    单请求的耗时比
</code></pre>

<h2 id="nscale">nscale</h2>

<pre><code># 可扩展容器，用node.js和docker实现
</code></pre>

<h1 id="ha">ha</h1>

<pre><code># high-availability linux
目标
    reliability: 可靠性
    availability: 可用性
    serviceability: 可服务性
        ras: remote access service(远程服务访问)
术语
    节点(node): 唯一主节点，多个备用节点
    资源(resource): 是节点可控制的实体，主节点发生故障时，可以被其它节点接管
        例如:
            磁盘分区
            文件系统
            ip地址
            应用程序服务
            nfs文件系统
    事件(event): 集群中可能发生的事件
        例如:
            系统故障
            网络连通故障
            网卡故障
            应用程序故障
    动作(action): 事件发生时ha的响应方式
        例如: 用shell 脚本对资源进行转移
</code></pre>

<h2 id="心跳">心跳</h2>

<h3 id="heartbeat">heartbeat</h3>

<pre><code>2.0模块
    heartbeat: 节点间通信检测模块
    ha-logd: 集群事件日志服务
    CCM(Consensus CLuster Membership): 集群成员一致性管理模块
    LRM(Local Resource Manager): 本地资源管理模块
    Stonith Daemon: 使出现问题的节点从集群资源中脱离
    CRM(Cluster Resource management): 集群资源管理模块
    Cluster policy engine: 集群策略引擎
            用于实现节点与资源之间的管理与依赖关系
    Cluster transition  engine: 集群转移引擎

3.0拆分之后的组成部分
    Heartbeat: 负责节点之间的通信
    Cluster Glue: 中间层，关联Heartbeat 与 Pacemaker,包含LRM 与 stonith
    Resource Agent: 控制服务启停，监控服务状态脚本集合，被LRM调用
    Pacemaker: 也就是曾经的CRM，包含了更多的功能
        管理接口:
            crm shell
            一个使用ajax web 的web窗口
            hb_gui图形工具
            DRBD-MC, 一个基于java的工具

版本差异
    与1.x相比，2.1.x版本变化
        保留原来所有功能
        自动监控资源
        对各资源组进行独立监控
        同时监控系统负载
            自动切换到负载低的node上
</code></pre>

<h3 id="keepalived">keepalived</h3>

<pre><code>vrrp
    # virtual router redundancy protocol 虚拟路由器冗余协议
    # 解决静态路由出现的闪单点故障问题，它能够保证网络的不间断．稳定运行
</code></pre>

<h2 id="负载">负载</h2>

<pre><code># load balance
方法
        dns轮循

        java nio
        erlang语言
        linux epoll
        bsd kqueue
        消息队列、事件通知
        c/c++下ace, boost.asio, libev(libevent)
        服务器mina, jetty, node.js, netty
        java协程框架 quasar kilim
</code></pre>

<h3 id="haproxy">haproxy</h3>

<pre><code>监控页面
        /status
</code></pre>

<h3 id="tengine">tengine</h3>

<pre><code># 淘宝基于nginx修改，添加了功能
监控
    /upstream_status
</code></pre>

<h3 id="openresty">openresty</h3>

<pre><code># 淘宝改的nginx, lua工具
安装
    yum install -y gcc gcc-c++ kernel-devel readline-devel pcre-devel openssl-devel openssl zlib zlib-devel pcre-devel
    wget openresty-1.9.15.1.tar.gz
    ./configure --prefix=/opt/openresty --with-pcre-jit --with-ipv6 --without-http_redis2_module --with-http_iconv_module -j2
    make &amp;&amp; make install
    ln -s /opt/openresty/nginx/sbin/nginx /usr/sbin
    /opt/openresty/nginx/conf/nginx.conf
</code></pre>

<h3 id="varnish">varnish</h3>

<pre><code># 反向代理, http缓存
</code></pre>

<h3 id="traffic-server">traffic server</h3>

<pre><code># apache 缓存
</code></pre>

<h3 id="squid">squid</h3>

<pre><code>配置文件
    /etc/squid/squid.conf
代理类型
    普通代理
    透明代理
    反向代理
缓存
    动态资源
    静态资源
参考资料
    squid 透明代理详解
配置
    # squid.conf
    http_port 3128                                                # squid服务端口
    icp_port 3130                                                # udp端口,用来接收和发送ICP消息
    cache_dir ufs /var/spool/squid                                # 缓存目录, 写入方式有aufs与ufs两种,aufs使用大量线程异步进行磁盘i/o操作
    cache_access_log /var/log/squid/access.log
    cache_log /var/log/squid/cache.log
    cache_store_log /var/log/squid/store.log
    pid_filename /var/run/squid.pid                        # 日志文件位置

    #auth_param basic children 5
    #auth_param basic realm Squid proxy-caching web server
    #auth_param basic credentialsttl 2 hours                 # 关闭认证，认证一般不需要

    cache_effective_user squid
    cache_effective_group squid
    cache_mgr youraccount@your.e.mail                        # 设置squid用户及用户组、管理员账号

    cache_mem 128 MB                                        # 运行内存配置

    cache_swap_low 90
    cache_swap_high 95
    maximum_object_size 4096 KB                        ＃ 与磁盘容量相关的配置，90、95为百分比，磁盘大时4096 KB可以改成32768 KB

    maximum_object_size_in_memory 8 KB                ＃ 内存缓存资料大小

    以下为定义acl(访问控制列表)
            ＃ 语法为:acl&lt;acl&gt; &lt;acl名称&gt; &lt;acl类型&gt; &lt;配置的内容&gt;
    acl All src 0/0
    acl Manager proto cache_object  acl Localhost src 127.0.0.1/32
    acl Safe_ports port 80 21 443 563 70 210 280 488 591 777 1025-65535
    acl SSL_ports 443 563
    acl CONNECT method CONNECT
    acl MyNetwork src 192.168.0.0/16

    以下为利用前面定义的acl,定义访问控制规则
    http_access allow Manager Localhost
    http_access deny Manager
    http_access deny !Safe_ports
    http_access deny CONNECT SSL_ports
    http_access allow MyNetwork
    http_access deny All

    例子: 禁止访问sina
    acl sina dstdomain .sina.com.cn .sina.com
    http_access deny sina
    或
    acl sina dst 58.63.236.26 58.63.236.27 58.63.236.28 58.63.236.29 58.63.236.30 58.63.236.31 58.63.236.32 58.63.236.33 58.63.236.34 58.63.236.35 58.63.236.36 58.63.236.37 58.63.236.38 58.63.236.39 58.63.236.49 58.63.236.50
    http_access deny sina
    或
    acl sina dst www.sina.com.cn
    http_access deny sina

    例子: 禁止来自某些ip的访问
    acl zhang src 192.168.63.6/32
    http_access deny zhang

    例子: 禁止在某些时段访问
    acl Working_hours MTWHF 08:00-17:00
    http_access allow Working_hours
    http_access deny !Working_hours

    例子: 禁止某个代理客户建立过多连接
    acl OverConnLimit maxconn
    http_access deny OverConnLimit

    定义与其它代理服务器的关系,语法: &lt;cache_peer&gt; &lt;主机名称&gt; &lt;类别&gt; &lt;http_port&gt; &lt;icp_port&gt; &lt;其它参数&gt;
    cache_peer 192.168.60.6 parent 4480 7 no-query default

    #设置与其它代理服务器的关系: &lt;cache_peer_access&gt; &lt;上层 Proxy &gt; &lt;allow|deny&gt; &lt;acl名称&gt;
    #cache_peer_access 192.168.60.6 allow aclxxx
    #cache_peer_access 192.168.60.6 deny !aclxxx
    coredump_dir /var/spool/squid                                        # 崩溃存储目录
使用
    step1 检查配置文件
        squid -k parse
    step2  初始化cache 目录
        squid -z(X)                                # X会显示过程
    step3 启动squid
        service squid start
        或
        /usr/local/squid/sbin/squid -sD
    停止squid
        squid -k shutdown
    重新载入配置
        squid -k reconfigure
    滚动日志
        squid -k rotate
案例
    透明代理
        step1 检查配置文件
            squid -k parse
        step2  初始化cache 目录
            squid -z(X)                                # X会显示过程
        step3 启动squid
            service squid start
            或
            /usr/local/squid/sbin/squid -sD
        停止squid
            squid -k shutdown
        重新载入配置
            squid -k reconfigure
        滚动日志
            squid -k rotate
    代理
        squid.conf
            http_port 3128
            http_access allow all
            或
            http_port 3128
            http_access deny all前面添加
            acl 192.168.0.42 src 192.168.0.0/24
            http_access allow 192.168.0.42                        ＃ 192.168.0.42为允许的ip
</code></pre>

<h3 id="lvs">lvs</h3>

<pre><code>介绍
    第四层开始负载(可以建立到三层负载)

    第四层负载
        socket进必须连lvs

模式
    tun
        # lvs负载均衡器将请求包发给物理服务器，后者将应答包直接发给用户
    net
        # 请求和应答都经过lvs
    dr
        # 不要隧道结构的tun
使用
    DR模式 centos6
    yum install-y gcc gcc-c++ makepcre pcre-devel kernel-devel openssl-devel libnl-devel popt-devel
    modprobe -l |grep ipvs
        # 检查内核是否集成
    echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward
        # 开启路由转发
    安装ipvsadm
        http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz
    安装keepalived
        http://www.keepalived.org/software/keepalived-1.2.7.tar.gz
        ./configure --prefix=/usr/local/keepalived

        cp  /usr/local/keepalived/etc/rc.d/init.d/keepalived        /etc/init.d/
        cp /usr/local/keepalived/etc/sysconfig/keepalived        /etc/sysconfig/
        mkdir /etc/keepalived/
        cp /usr/local/keepalived/etc/keepalived/keepalived.conf        /etc/keepalived/
        cp /usr/local/keepalived/sbin/keepalived        /usr/sbin/

        o-&gt; 配置文件/etc/keepalived/keepalived.conf
        ! Configuration File forkeepalived
        global_defs {
        notification_email {
        test@sina.com    #故障接受联系人
        }
        notification_email_from admin@test.com  #故障发送人
        smtp_server 127.0.0.1  #本机发送邮件
        smtp_connect_timeout 30
        router_id LVS_MASTER  #BACKUP上修改为LVS_BACKUP
        }
        vrrp_instance VI_1 {
        state MASTER    #BACKUP上修改为BACKUP
        interface eth0
        virtual_router_id 51  #虚拟路由标识，主从相同
        priority 100  #BACKUP上修改为90
        advert_int 1
        authentication {
        auth_type PASS
        auth_pass 1111  #主从认证密码必须一致
        }
        virtual_ipaddress {    #Web虚拟IP（VTP）
        172.0.0.10
        }
        }
        virtual_server 172.0.0.10 80 { #定义虚拟IP和端口
        delay_loop 6    #检查真实服务器时间，单位秒
        lb_algo rr      #设置负载调度算法，rr为轮训
        lb_kind DR      #设置LVS负载均衡DR模式
        persistence_timeout 50 #同一IP的连接60秒内被分配到同一台真实服务器
        protocol TCP    #使用TCP协议检查realserver状态
        real_server 172.0.0.13 80 {  #第一个web服务器
        weight 3          #节点权重值
        TCP_CHECK {      #健康检查方式
        connect_timeout 3 #连接超时
        nb_get_retry 3    #重试次数
        delay_before_retry 3  #重试间隔/S
        }
        }
        real_server 172.0.0.14 80 {  #第二个web服务器
        weight 3
        TCP_CHECK {
        connect_timeout 3
        nb_get_retry 3
        delay_before_retry 3
            }
        }
        }

        service keepalived restart

    启动脚本 /etc/init.d/real.sh
        #description : start realserver
        VIP=172.0.0.10
        . /etc/init.d/functions
        case &quot;$1&quot; in
        start)
        /sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up
        echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
        echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
        echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
        echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce
        echo &quot;LVS RealServer Start OK&quot;
        ;;
        stop)
        /sbin/ifconfig lo:0 down
        echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
        echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
        echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
        echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce
        echo &quot;LVS RealServer Stoped OK&quot;
        ;;
        *)
        echo &quot;Usage: $0 {start|stop}&quot;
        exit 1
        esac

    o-&gt; 开机启动
        chmod +x /etc/init.d/real.sh
        /etc/init.d/real.sh start
        echo &quot;/etc/init.d/real.sh start&quot; &gt;&gt; /etc/rc.local
    o-&gt; 测试
        service httpd start
        echo &quot;1&quot; &gt; /var/www/html/index.html
        service iptables stop
        setenforce 0
            # 关闭selinux
    o-&gt; 其他命令
        ipvsadm -ln
            # 集群中服务器ip信息
        ip addr
            # 显示VIP当前绑定的服务器
        tail -f /var/log/messages
            # 日志
</code></pre>

<h1 id="容器服务">容器服务</h1>

<h2 id="tomcat">tomcat</h2>

<pre><code>## 介绍
    tomcat从7开始默认就是nio的
## 配置
    bin/startup.bat
            set JAVA_HOME=
                            # 设置tomcat运行jdk
    context.xml
        &lt;Loader delegate=&quot;true&quot;/&gt;
                # true表示使用java加载器的代理模式
                ## false代表永远先在Web应用程序中寻找
    web.xml
        Content-Type: text/x-zim-wiki
        Wiki-Format: zim 0.4
        Creation-Date: 2013-08-04T19:40:08+08:00

        ====== web.xml文件 ======
        Created Sunday 04 August 2013

        &lt;servlet&gt;
                &lt;servlet-name&gt;
                &lt;servlet-class&gt;
                &lt;load-on-startup&gt;1
                &lt;init-param&gt;
                        &lt;param-name&gt;
                        &lt;param-value&gt;
        &lt;servlet-mapping&gt;
                &lt;servlet-name&gt;
                &lt;url-pattern&gt;

        &lt;welcome-file-list&gt;
                &lt;welcome-file&gt;

        &lt;filter&gt;
                &lt;filter-name&gt;
                &lt;filter-class&gt;
                &lt;init-param&gt;
        &lt;filter-mapping&gt;
                &lt;filter-name&gt;
                &lt;url-pattern&gt;

        &lt;mime-mapping&gt;
                &lt;extension&gt;bmp
                &lt;mime-type&gt;image/bmp

        &lt;error-page&gt;
                &lt;exception-type&gt;异常类的完全限定名 /&lt;error-code&gt;错误码
                &lt;location&gt;以“/”开头的错误处理页面路径

## 启动顺序
    web.xml中配置的启动顺序
            监听器
            过滤器
            servlet
                    load-on-startup属性值越小越先启动

    tomcat的加载过程：        # 分析启动日志得到
            启动http协议
            启动catalina
            启动servlet引擎
            加载xml配置文件
            初始化日志配置
            初始化ContextListener
            初始化SessionListener
            部署web项目
                    spring监听器，加载xml配置(开始spring自己的日志记录)
                            实例化bean
                                    初始化c3p0连接池的记录显示
                                    初始化LocalSessionFactoryBean的记录显示
                    application监听器(监听器按配置顺序启动)
                    struts过滤器，加载xml配置(开始struts自己的日志记录)
                            struts-default.xml
                                    根据其中配置的bean属性加载类，并记录了日志
                            struts-plugin.xml                # 里面有加载spring-struts-plugin包
                                    初始化struts-spring 集成
                            struts.xml
## 目录
    LICENSE
    NOTICE
    RELEASE-NOTES
    RUNNING.txt
    bin
            bootstrap.jar
            commons-daemon.jar
            tomcat-juli.jar
            tomcat-native.tar.gz
            commons-daemon-native.tar.gz
            catalina.bat
            shutdown.bat
            startup.bat
            cpappend.bat
            digest.bat
            setclasspath.bat
            tool-wrapper.bat
            version.bat
            catalina.sh
            shutdown.sh
            startup.sh
            digest.sh
            setclasspath.sh
            tool-wrapper.sh
            version.sh
            catalina-tasks.xml
    conf
            catalina.policy
            catalina.properties
            logging.properties
            context.xml
            server.xml
            tomcat-users.xml
            web.xml
            Catalina
                    localhost
                            host-manager.xml
                            manager.xml
    lib
            annotations-api.jar
            catalina.jar
            catalina-ant.jar
            catalina-ha.jar
            catalina-tribes.jar
            el-api.jar
            jasper.jar
            jasper-el.jar
            jasper-jdt.jar
            jsp-api.jar
            servlet-api.jar
            tomcat-coyote.jar
            tomcat-dbcp.jar
            tomcat-i18n-es.jar
            tomcat-i18n-fr.jar
            tomcat-i18n-ja.jar
    log
            catalina.2013-07-28.log等等
    webapps
            ROOT
                    WEB-INF
                            web.xml
            docs
            examples
            manager
            host-manager
    tmp
    work

    发布
            conf/server.xml 中8080端口 位置
            &lt;Context path=&quot;/bbs&quot; reloadable=&quot;true&quot; docBase=&quot;E:\workspace\bbs&quot; workDir=&quot;E:\workspace\bbs\work&quot; /&gt;

    发布war文件：
            localhost:8080 -&gt; tomcat manager -&gt; WAR file to deploy
</code></pre>

<h2 id="netty">netty</h2>

<pre><code>## 介绍
    JBOSS提供，由Trustin Lee开发，比mina晚
    java开源框架
## 原理
    基于socket的数据流处理
            # socket数据流不是a queue of packets , 而是a queue of bytes, 所以分次传输的数据会成为a bunch of bytes
## 例子
    Handler
        ChannelHandler
            ChannelOutboundHandler
                    ChannelOutboundHandlerAdapter                        # 可作Encoder
                    MessageToByteEncoder
            ChannelInboundHandler                # 提供可重写的事件
                    ChannelInboundHandlerAdapter
                    ByteToMessageDecoder        # easy to deal with fragmentation issue
                            事件
                                    decode(ctx, in, out)                        # 内部处理过数据，堆积到了buffer(in)
                                                                            ## out中add了数据, 表示decode成功，则执行后抛弃in中数据
                                                                            # decode会被循环调用直到有一次out中没有add东西
                    ReplayingDecoder
                    事件
                            channelRead()                # 从client接收到数据时调用，数据的类型是ByteBuf
                                                    ## ByteBuf是 reference-counted object
                                                    ## 必须用ReferenceCountUtil.release(msg)或((ByteBuf) msg).release()来明确释放
                            exceptionCaught()        # 当抛出Throwable对象时调用
                            channelActive()                # as soon as a connection is established
            方法
                    handlerAdded()
                    handlerRemoved()
        ByteBuf
            方法
                    buf.writeBytes(m)                # 将m[ByteBuf]中的数据 cumulate into buf[ 定长的ByteBuf, 如ctx.alloc().buffer(4) ]
                    isReadable()                        # 返回ByteBuf中data的长度
        ChannelHandlerContext                # 用于触发一些i/o事件
            方法
                    write(msg)                # msg在flush后自动realease
                            write(msg, promise)                                # promise是ChannelPromise的对象，用来标记msg是否确切地写入到管道中
                    flush()
                    writeAndFlush(msg)                                        # 返回ChannelFuture
                    alloc()                                                        # 分配缓冲区来包含数据
        ByteBufAllocator
            buffer(4)                        # 返回存放32-bit Integer的ByteBuf
    Server
        EventLoopGroup
            NioEventLoopGroup                # 多线程 i/o eventloop
            方法
                    shutdownGracefully()                                                # 返回Funture类来通知group是否完全关闭并且所有group的channels都关闭
        ServerBootstrap                        # 建server的帮助类，链式编程
                                            ## 可以直接用Channel来建server
            方法
                group(bossGroup, workerGroup)                                # boss接收连接，worker处理boss中的连接
                        group(workerGroup)                                        # 只有一个参数时，该group即作boss也作worker
                channel(NioServerSocketChannel.class)                        # 用来接收连接的channel的类型
                        channel(NioSocketChannel.class)                        # create client-side channel
                childHandler(channelInitializer)                                # 新接收的channel总执行本handler
                                                                                ## 只有workerGroup时不用
                option(ChannelOption.SO_BACKLOG, 128)                        # channel实现的参数
                childOption(channelOption.SO_KEEPALIVE, true)                # option设置boss, childOption设置worker
                                                                                ## 在只有workerGroup时不用childOption,因为它没有parent
                bind(port)                                                        # 开始接收连接，返回的是ChannelFuture
                                                                                    ## 绑定网卡上的所有port端口，可以bind多次到不同的端口
        ChannelInitializer                        # 帮助设置channel, 如设置channel的pipeline中的handler
            实例
                new　ChannelInitializer&lt;SocketChannel&gt;(){
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception{
                                ch.pipeline().addLast(new DiyHandler());
                        }
                }
        ChannelFuture
            方法
                sync()
                channel()                                                        # 返回Channel
                addListener(channelFutureListener)
        Channel
                closeFuture()                                                        # 返回ChannelFuture
        ChannelFutureListener
            实例
                new ChannelFutureListener(){
                    // 当请求结束时通知
                    @Override
                    public void operationComplete(ChannelFuture future){
                        assert f == future;
                        ctx.close();
                    }
                }
    client
        Bootstrap                        # for non-server channels such as a client-side or connectionless channel
            connect(host, port)
</code></pre>

<h2 id="netty-tcnative">netty-tcnative</h2>

<pre><code>介绍
        tomcat native 的分支
特点
        简化本地库的分配和连接
        可以maven配置dependency
        提供openssl的支持
</code></pre>

<h2 id="jetty">jetty</h2>

<pre><code># 是开源的servlet容器，基于java, 可以给jsp和servlet提供运行环境
# jetty容器可以实例化成一个对象，迅速为一些独立运行(stand-alone)的java应用提供网络和web连接
</code></pre>

<h2 id="apache">apache</h2>

<pre><code># http容器，可容纳php, python。一请求一线程
安装
    pacman -S apache
    mkdir /srv/http
    chown http:http /srv/http
编译安装
    ./configure
        --prefix=/全路径/install_path
        --with-apxs2=/全路径/apxs            # 模块
    make
    make install
命令
    httpd
        -f                                  # 指定配置
        -t                                  # 配置检查
        -k
            start
            restart
            graceful
            stop
            graceful-stop
    apachectl
        graceful                            # 重载配置
        -f /全路径/httpd.conf                # 指定配置
        -t                                  # 配置检查
配置
    /etc/httpd/conf/httpd.conf
        DocumentRoot &quot;/srv/http&quot;            # 项目路径
        Listen                              # 端口
案例
    php
        docker解决
</code></pre>

<h2 id="lighttpd">lighttpd</h2>

<h2 id="meteor">meteor</h2>

<pre><code># 包装node
</code></pre>

<h2 id="ringojs">ringojs</h2>

<pre><code># jvm上commonJs规范的服务器
</code></pre>

<h2 id="mina">mina</h2>

<pre><code>apache提供， 由Trustin Lee开发，比netty更早
</code></pre>

<h2 id="tomcat-native">tomcat native</h2>

<pre><code># 基于apr(apache portable runtime)技术，让tomcat在操作系统级别的交互上做的更好
</code></pre>

<h2 id="tinyhttpd">tinyHttpd</h2>

<h2 id="resin">resin</h2>

<pre><code># 收费, 类似tomcat的java容器，性能提升
</code></pre>

<h2 id="uwsgi">uwsgi</h2>

<pre><code># 一个web服务器，实现了wsgi, uwsgi, http等协议
</code></pre>

<h2 id="weblogic">weblogic</h2>

<pre><code># oracle
</code></pre>

<h2 id="was">was</h2>

<pre><code># ibm服务器
</code></pre>

<h2 id="gunicon">gunicon</h2>

<pre><code># python wsgi http server
</code></pre>

<h2 id="node-js">node.js</h2>

<h1 id="通信服务">通信服务</h1>

<h2 id="log">log</h2>

<h3 id="elk">elk</h3>

<pre><code>        # elasticsearch, logstash, kibana
</code></pre>

<h3 id="log-io">log.io</h3>

<h2 id="mq">mq</h2>

<pre><code>消息重发
    状态表记录消息状态
</code></pre>

<h3 id="rabbitmq">rabbitMQ</h3>

<pre><code>介绍
    erlang开发, 重量级
    支持协议多，AMQP、XMPP、SMTP、STOMP
    Broker构架        # 消息在中心队列排队
install
        yum install rabbitmq-server
命令
        添加用户:
                rabbitmqctl add_user rainbird password
        添加权限:
                rabbitmqctl set_permissions -p &quot;/&quot; rainbird &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
        删除测试用户:
                rabbitmqctl delete_user guest
原理
    虚拟主机 virtual host: 用户通过虚拟主机进行权限控制(如禁止A组访问B组的交换机)
            ＃ 默认虚拟主机为&quot;/&quot;
            队列 queue: 由生产者(producers)通过程序建立，再通过消费者(consuming)连接取走
                    消息:
                            路由键 routing key
            交换机 exchange: 负责把消息放入队列
                    绑定 binding(路由规则): 如指明交换机中具有路由键&quot;X&quot;的消息要到名为&quot;Y&quot;的队列中去
                            # 如果同一个键对应多个队列，则复制后分别发送

    功能
            持久化
                    队列和交换机创建时指定标志durable,指定队列和交换机重启生重建
                            ＃ 如果绑定了durable的队列和durable的交换机，该绑定自动保留
                            ＃ non-durable的交换机与durable的队列不能绑定
                            ＃ 一但创建durable标志，不能修改
                    消息发布到交换机时，指定标志Delivery Mode=2,这样消息会持久化
使用(原文http://adamlu.net/rabbitmq/tutorial-one-python)
        安装python 与插件支持
                pip
                python-pip git
                python-pika
        rabbitmq-server start
        send.py
            #!/usr/bin/env python
            import pika

            connection = pika.BlockingConnection(pika.ConnectionParameters(
                    host='localhost'))
            channel = connection.channel()

            channel.queue_declare(queue='hello')

            channel.basic_publish(exchange='',
                                routing_key='hello',
                                body='Hello World!')
            print &quot; [x] Sent 'Hello World!'&quot;
            connection.close()
                    receive.py
                            #!/usr/bin/env python
            import pika

            connection = pika.BlockingConnection(pika.ConnectionParameters(
                    host='localhost'))
            channel = connection.channel()

            channel.queue_declare(queue='hello')

            print ' [*] Waiting for messages. To exit press CTRL+C'

            def callback(ch, method, properties, body):
                print &quot; [x] Received %r&quot; % (body,)

            channel.basic_consume(callback,
                                queue='hello',
                                no_ack=True)

            channel.start_consuming()
</code></pre>

<h3 id="jafka">jafka</h3>

<pre><code>介绍
    基于kafka, 快速持久化(O(1)时间开销)
    高吞吐，一台普通服务器 100k/s
    完全分布式，Broker, Producer, Consumer原生支持分布式，自动负载均衡
    支持hadoop并行加载
</code></pre>

<h3 id="kafka">kafka</h3>

<pre><code>介绍
    apache子项目，scala语言编写, 发布订阅队列
    相对activeMQ轻量
架构
        push/pull队列架构，适合异构集群
        高吞吐率
        分布式
        支持数据并行到hadoop
工具
    manager # 监控
</code></pre>

<h3 id="nsq">nsq</h3>

<pre><code>介绍
    go
工具
    admin   # 监控
</code></pre>

<h3 id="memcacheq">memcacheQ</h3>

<h3 id="zeromq">zeroMQ</h3>

<h3 id="activemq">activeMQ</h3>

<pre><code>介绍
    apache子项目, 类似zeroMQ
通信方式
    点到点
        不成功时保存在服务端
    发布订阅
        不成功消息丢失
</code></pre>

<h3 id="beanstalkd">beanstalkd</h3>

<h3 id="mqtt">mqtt</h3>

<pre><code>    # 最早由ibm提供的，二进制消息的mq
</code></pre>

<h2 id="任务">任务</h2>

<h3 id="quartz">quartz</h3>

<pre><code># java作业调度
配置applicationContext_job.xml
    job             # 任务内容
    jobDetail       # 调度方案
    trigger         # 时间
    scheduler       # jobDetail和trigger的容器
状态监控
    # 用日志表记录
    运行中
        JobListener监听器
    暂停中
        scheduler.pauseTrigger()
    等待中
        创建job时
</code></pre>

<h3 id="celery">celery</h3>

<pre><code># python
</code></pre>

<h3 id="rundeck">rundeck</h3>

<pre><code># java
</code></pre>

<h1 id="存储服务">存储服务</h1>

<pre><code>存储的概念和术语
    scsi: 小型计算机系统接口(Small Computer System Interface)
    fc: 光纤通道(Fibre channel)
    das: 直连式存储(Direct-Attached Storage)
    nas: 网络接入存储(Network-Attached Storage)
    san: 存储区域网络(Storage Area Network)
        连接设备: 路由,  光纤交换机, 集线器(hub)
        接口: scsi fc
        通信协议: ip scsi
</code></pre>

<h2 id="iscsi">iscsi</h2>

<pre><code># internet scsi
优点
    可以网络传输
    服务器数量无限
    在线扩容．动态部署
架构
    控制器架构: 专用数据传输芯片．专用RAID数据校验芯片．专用高性能cache缓存和专用嵌入式系统平台
    iscsi连接桥架构:
        前端协议转换设备(硬件)
        后端存储(scsi磁盘阵列．fc存储设备)
    pc架构
        存储设备搭建在pc服务器上，通过软件管理成iscsi, 通过网卡传输数据
        实现
            以太网卡 + initiator软件
            toe网卡 + initiator软件
            iscsi HBA卡
iscsi系统组成
    iscsi initiator 或　iscsi hba
    iscsi target
    以太网交换机
    一台或多台服务器
</code></pre>

<h2 id="fastdfs">fastdfs</h2>

<pre><code># 开源分布式文件系统
</code></pre>

<h2 id="cdn">cdn</h2>

<pre><code>介绍
    流量不大时带宽比cdn便宜, 流量大时cdn便宜。
    界限为250Mbps左右，价格在9k/month
价格     50TB/月        100TB/月
阿里云   3.8w/月        6.9w/月
盛大云   9k/月          1.7w/月
网宿
蓝汛
</code></pre>

<h2 id="aws服务器">aws服务器</h2>

<pre><code>命令
    aws
        s3
            cp --recursive bin s3://meiqia/crm-module/search/bin
                # 级联复制
            sync s3://meiqia/crm-module/search/bin bin
                # 下载
            rm --recursive s3://meiqia/crm-module/search
                # 级联删除
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/hugo-blog/commit/cd195b4fce4da3843da413e752633395b41861f4" title='Last modified Aug 23, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Aug 23, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/hugo-blog/tree/master/content/docs/architecture/_index.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#名词">名词</a></li>
<li><a href="#service-mesh">service mesh</a>
<ul>
<li><a href="#service-fabric">service fabric</a></li>
<li><a href="#lstio">lstio</a></li>
<li><a href="#linkerd">linkerd</a></li>
<li><a href="#conduit">conduit</a></li>
<li><a href="#fingle">fingle</a></li>
<li><a href="#envoy">envoy</a></li>
<li><a href="#nginmesh">nginmesh</a></li>
</ul></li>
<li><a href="#paas">paas</a>
<ul>
<li><a href="#cloudstack">cloudStack</a></li>
<li><a href="#cloudfoundry">cloudfoundry</a></li>
<li><a href="#openstack">openstack</a></li>
</ul></li>
<li><a href="#分布式服务-容器调度编排">分布式服务(容器调度编排)</a>
<ul>
<li><a href="#kubernetes">kubernetes</a></li>
<li><a href="#spring-cloud">spring cloud</a></li>
<li><a href="#dubbo">Dubbo</a></li>
<li><a href="#orleans">orleans</a></li>
<li><a href="#hsf">hsf</a></li>
</ul></li>
<li><a href="#soa">soa</a>
<ul>
<li><a href="#eai">eai</a></li>
<li><a href="#esb">esb</a></li>
</ul></li>
<li><a href="#rpc">rpc</a>
<ul>
<li><a href="#thrift">thrift</a></li>
<li><a href="#cxf">cxf</a></li>
<li><a href="#grpc">grpc</a></li>
<li><a href="#protobuf">protobuf</a></li>
</ul></li>
<li><a href="#rmi">rmi</a>
<ul>
<li><a href="#hessian">hessian</a></li>
<li><a href="#burlap">Burlap</a></li>
<li><a href="#httpinvoker">httpinvoker</a></li>
<li><a href="#web-service">web service</a></li>
</ul></li>
<li><a href="#粘合层">粘合层</a>
<ul>
<li><a href="#zookeeper">zookeeper</a></li>
<li><a href="#gearman">gearman</a></li>
<li><a href="#etcd">etcd</a></li>
<li><a href="#mesos">mesos</a></li>
<li><a href="#hystrix">hystrix</a></li>
<li><a href="#twemproxy">twemproxy</a></li>
</ul></li>
<li><a href="#tracing">tracing</a>
<ul>
<li><a href="#zipkin">zipkin</a></li>
<li><a href="#opentracing">opentracing</a></li>
</ul></li>
<li><a href="#monitor">monitor</a>
<ul>
<li><a href="#spy-js">spy.js</a></li>
<li><a href="#alinode">alinode</a></li>
<li><a href="#oneapm">oneapm</a></li>
<li><a href="#nscale">nscale</a></li>
</ul></li>
<li><a href="#ha">ha</a>
<ul>
<li><a href="#心跳">心跳</a>
<ul>
<li><a href="#heartbeat">heartbeat</a></li>
<li><a href="#keepalived">keepalived</a></li>
</ul></li>
<li><a href="#负载">负载</a>
<ul>
<li><a href="#haproxy">haproxy</a></li>
<li><a href="#tengine">tengine</a></li>
<li><a href="#openresty">openresty</a></li>
<li><a href="#varnish">varnish</a></li>
<li><a href="#traffic-server">traffic server</a></li>
<li><a href="#squid">squid</a></li>
<li><a href="#lvs">lvs</a></li>
</ul></li>
</ul></li>
<li><a href="#容器服务">容器服务</a>
<ul>
<li><a href="#tomcat">tomcat</a></li>
<li><a href="#netty">netty</a></li>
<li><a href="#netty-tcnative">netty-tcnative</a></li>
<li><a href="#jetty">jetty</a></li>
<li><a href="#apache">apache</a></li>
<li><a href="#lighttpd">lighttpd</a></li>
<li><a href="#meteor">meteor</a></li>
<li><a href="#ringojs">ringojs</a></li>
<li><a href="#mina">mina</a></li>
<li><a href="#tomcat-native">tomcat native</a></li>
<li><a href="#tinyhttpd">tinyHttpd</a></li>
<li><a href="#resin">resin</a></li>
<li><a href="#uwsgi">uwsgi</a></li>
<li><a href="#weblogic">weblogic</a></li>
<li><a href="#was">was</a></li>
<li><a href="#gunicon">gunicon</a></li>
<li><a href="#node-js">node.js</a></li>
</ul></li>
<li><a href="#通信服务">通信服务</a>
<ul>
<li><a href="#log">log</a>
<ul>
<li><a href="#elk">elk</a></li>
<li><a href="#log-io">log.io</a></li>
</ul></li>
<li><a href="#mq">mq</a>
<ul>
<li><a href="#rabbitmq">rabbitMQ</a></li>
<li><a href="#jafka">jafka</a></li>
<li><a href="#kafka">kafka</a></li>
<li><a href="#nsq">nsq</a></li>
<li><a href="#memcacheq">memcacheQ</a></li>
<li><a href="#zeromq">zeroMQ</a></li>
<li><a href="#activemq">activeMQ</a></li>
<li><a href="#beanstalkd">beanstalkd</a></li>
<li><a href="#mqtt">mqtt</a></li>
</ul></li>
<li><a href="#任务">任务</a>
<ul>
<li><a href="#quartz">quartz</a></li>
<li><a href="#celery">celery</a></li>
<li><a href="#rundeck">rundeck</a></li>
</ul></li>
</ul></li>
<li><a href="#存储服务">存储服务</a>
<ul>
<li><a href="#iscsi">iscsi</a></li>
<li><a href="#fastdfs">fastdfs</a></li>
<li><a href="#cdn">cdn</a></li>
<li><a href="#aws服务器">aws服务器</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
