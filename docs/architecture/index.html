<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    
    架构
  
 | outrun的笔记</title>



<link rel="stylesheet" href="/book.min.1a0250256273fabf0f848ed9a3c50aae344d758339cad9725e656ac71546e6f5.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="https://example.com/docs/architecture/index.xml" title="outrun的笔记" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">outrun的笔记</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f architecture\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/server">服务器</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/lucene">lucene</a></li>
<li><a href="/docs/backend/nodejs">nodejs</a></li>
<li><a href="/docs/backend/shiro">shiro</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/struts2">struts2</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
<li><a href="/docs/backend/hadoop">hadoop</a></li>
<li><a href="/docs/backend/mybatis">mybatis</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">pgsql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/project">项目</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/linux_tool">linux工具</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/javaweb">javaweb</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/markup_language"><strong><em>标记语言</em></strong></a>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a></li>
<li><a href="/docs/tool"><strong>图形工具</strong></a>

<ul>
<li><a href="/docs/tool/vim">vim</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
</ul></li>
<li><a href="/docs/management">管理</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/interview">题目</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    
    架构
  
</strong>
</header>

      
<article class="markdown">

<h1 id="名词">名词</h1>

<pre><code>Alb        automaticLoopBack 自动回环，虚拟接口
sdn        software defined network 软件定义网络
</code></pre>

<h1 id="模块">模块</h1>

<pre><code>服务
    注册
    发现
性能/ha
    区域感知load balance
    故障切换
    故障注入
    熔断
    健康检查
    流量拆分和推出
策略
    quota
        网络数据
        api调用
    服务准入条件
    路由规则
    容错
    访问策略
安全
    服务间认证(auth)
    tls
    细粒度权限控制
配置
    啮合层
        # 服务与网络间加入透明层，用来功能配置
查看
    服务网可视化
    monitor
    log
    tracing
迭代
    部署
    版本控制
平台支持
    # 如aws, k8s, mesos
通讯能力
    # http/1.1 http/2 grpc tcp
</code></pre>

<h1 id="mesh">mesh</h1>

<pre><code># 服务网格
</code></pre>

<h2 id="lstio">lstio</h2>

<pre><code>#google IBM, lyft开源，基于envoy
组成
    数据面板
    控制面板
</code></pre>

<h2 id="linkerd">linkerd</h2>

<pre><code># buoyant出品
</code></pre>

<h2 id="fingle">fingle</h2>

<pre><code># twitter出品
</code></pre>

<h2 id="envoy">envoy</h2>

<pre><code># lyft出品
</code></pre>

<h2 id="nginmesh">nginmesh</h2>

<pre><code># nginx推出
</code></pre>

<h1 id="paas">paas</h1>

<pre><code># platform as a service
</code></pre>

<h2 id="cloudstack">cloudStack</h2>

<pre><code># 托管在apache的开源、高可用、高扩展性的云计算平台
# 支持主流hypervisors
# 一个开源云计算解决方案，可以加速iaaS的部署、管理、配置
</code></pre>

<h2 id="kubernetes">kubernetes</h2>

<pre><code># google开源的，在docker技术上，为容器化应用提供:
作用
    资源调度
    部署运行
    服务发现
    扩容缩容
</code></pre>

<h2 id="cloudfoundry">cloudfoundry</h2>

<pre><code># 根据应用模板，动态生成很多tomcat, mysql, nosql, 动态控制这些实例的启停。
</code></pre>

<h2 id="openstack">openstack</h2>

<pre><code># 云操作系统，管理虚拟资源
</code></pre>

<h2 id="hsf">hsf</h2>

<pre><code># high-speed service framework
特点
    不增加中间点(稳定，高度可伸缩)
结构
    注册服务信息，推送服务地址
    基于osgi
</code></pre>

<h1 id="rpc">rpc</h1>

<pre><code># 远程过程调用 remote procedure call
</code></pre>

<h2 id="hsf-1">hsf</h2>

<pre><code># 高速服务框架 (socket直连)
</code></pre>

<h2 id="thrift">thrift</h2>

<h2 id="dubbo">Dubbo</h2>

<h2 id="cxf">cxf</h2>

<pre><code>常识
    自己内部整合spring(但是不耦合)
支持的协议
    soap1.1/1.2
    post/http
    restful
    http
使用
    导入cxf包
    方法1      # 不支持注解
        String address=&quot;http://localhost:8888/hello&quot;;
            ServerFactoryBean factoryBean=new ServerFactoryBean();
            factoryBean.setAddress(address);
            factoryBean.setServiceBean(new MyWS());
            factoryBean.create();
    方法2      # 支持注解,wsdl文件中类型不再单独schema文件
        ServerFactoryBean factoryBean = new JaxWsServerFactoryBean      # java and xml web service
    日志    # 记录握手信息(访问wsdl文件)
            ## 看日志记录得到 soap
        serverFactoryBean.getInInterceptors().add(new LoggingInInterceptor());
        serverFactoryBean.getOutInterceptors().add(new LoggingOutInterceptor());
整合spring
    o-&gt; cxf2.4.4.jar/schemas/jaxws.xsd中找到命名空间&quot;http://cxf.apache.org/jaxws&quot;
    o-&gt; 配置applicationContext.xml，加入cxf的命名空间http://cxf.apache.org/jaxws,schema地址为http://cxf.apache.org/schemas/jaxws.xsd。
        并且在eclipse中配置schema约束文件的路径
            # 该xsd约束文件的url地址用的是包地址,不规范
    o-&gt; applicationContext.xml中配置
        &lt;bean id=&quot;studentService&quot; class=&quot;test.spring.StudentServiceImpl&quot;/&gt;
            # 用于：自身调用，被spring引用
        &lt;jaxws:server serviceClass=&quot;test.spring.StudentService&quot; address=&quot;/student&quot;&gt;
            # address配置服务的名称即可(web.xml的servlet中配置了服务的实际访问地址)
            ## serviceClass配置的才是真正的服务，既然它是接口，那么webService注解也应该写在接口上
            &lt;jaxws:serviceBean&gt;
                &lt;ref bean=&quot;studentService&quot;/&gt;
            &lt;jaxws:inInterceptors&gt;
                &lt;bean class=&quot;org.apache.cxf.interceptor.LoggingInInterceptor&quot; /&gt;
            &lt;jaxws:outInterceptors&gt;
                &lt;bean class=&quot;org.apache.cxf.interceptor.LoggingOutInterceptor&quot; /&gt;
    o-&gt; web.xml中配置servlet
         &lt;servlet&gt;
              &lt;servlet-name&gt;springWS
              &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet        # 在cxf-2.4.4.jar包中
              &lt;load-on-startup&gt;1
         &lt;servlet-mapping&gt;
              &lt;servlet-name&gt;springWS
              &lt;url-pattern&gt;/ws/*
    o-&gt; web.xml中配置spring监听器
</code></pre>

<h2 id="spring-cloud">spring cloud</h2>

<h2 id="grpc">grpc</h2>

<h2 id="protobuf">protobuf</h2>

<pre><code># 通信协议
命令
    protoc -I. -I-I$GOPATH/src  --go_out=plugins=grpc:. *
        # -I import目录
    protoc --grpc-gateway_out=.
插件
    安装
        # go build 出protoc-gen-go后，放入go/bin下
    protoc-gen-go
        # 编译proto文件
    protoc-gen-grpc-gateway
        # http服务
</code></pre>

<h1 id="rmi">rmi</h1>

<pre><code># java远程调用 remote method invocation
</code></pre>

<h2 id="hessian">hessian</h2>

<h1 id="soa">soa</h1>

<pre><code># 面向服务架构 service oriented architecture
</code></pre>

<h2 id="eai">eai</h2>

<pre><code>    # Enterprise Application Integration 建立底层结构将异构应用集成
</code></pre>

<h2 id="esb">esb</h2>

<pre><code>    # Enterprise Service Bus 企业服务总线， 是连接中枢
</code></pre>

<h1 id="粘合层">粘合层</h1>

<h2 id="zookeeper">zookeeper</h2>

<pre><code># 服务发现
exhibitor
    # supervisor for zk
</code></pre>

<h2 id="gearman">gearman</h2>

<pre><code># 把工作委派给其他机器
</code></pre>

<h2 id="etcd">etcd</h2>

<pre><code># k8s中用到的服务发现仓库
</code></pre>

<h2 id="mesos">mesos</h2>

<pre><code># apache开源的分布式资源管理框架
</code></pre>

<h1 id="tracing">tracing</h1>

<h2 id="zipkin">zipkin</h2>

<h2 id="opentracing">opentracing</h2>

<h1 id="monitor">monitor</h1>

<h2 id="spy-js">spy.js</h2>

<pre><code># webstorm用的监控工具
</code></pre>

<h2 id="alinode">alinode</h2>

<pre><code># 朴灵写的运行时性能管理工具
</code></pre>

<h2 id="oneapm">oneapm</h2>

<pre><code># 监控node性能
功能
    接口响应时间
    数据库方法时间
    外部服务时间
    单请求的耗时比
</code></pre>

<h2 id="nscale">nscale</h2>

<pre><code># 可扩展容器，用node.js和docker实现
</code></pre>

<h1 id="ha">ha</h1>

<pre><code># high-availability linux
目标
    reliability: 可靠性
    availability: 可用性
    serviceability: 可服务性
        ras: remote access service(远程服务访问)
术语
    节点(node): 唯一主节点，多个备用节点
    资源(resource): 是节点可控制的实体，主节点发生故障时，可以被其它节点接管
        例如:
            磁盘分区
            文件系统
            ip地址
            应用程序服务
            nfs文件系统
    事件(event): 集群中可能发生的事件
        例如:
            系统故障
            网络连通故障
            网卡故障
            应用程序故障
    动作(action): 事件发生时ha的响应方式
        例如: 用shell 脚本对资源进行转移
</code></pre>

<h2 id="心跳">心跳</h2>

<h3 id="heartbeat">heartbeat</h3>

<pre><code>2.0模块
    heartbeat: 节点间通信检测模块
    ha-logd: 集群事件日志服务
    CCM(Consensus CLuster Membership): 集群成员一致性管理模块
    LRM(Local Resource Manager): 本地资源管理模块
    Stonith Daemon: 使出现问题的节点从集群资源中脱离
    CRM(Cluster Resource management): 集群资源管理模块
    Cluster policy engine: 集群策略引擎
            用于实现节点与资源之间的管理与依赖关系
    Cluster transition  engine: 集群转移引擎

3.0拆分之后的组成部分
    Heartbeat: 负责节点之间的通信
    Cluster Glue: 中间层，关联Heartbeat 与 Pacemaker,包含LRM 与 stonith
    Resource Agent: 控制服务启停，监控服务状态脚本集合，被LRM调用
    Pacemaker: 也就是曾经的CRM，包含了更多的功能
        管理接口:
            crm shell
            一个使用ajax web 的web窗口
            hb_gui图形工具
            DRBD-MC, 一个基于java的工具

版本差异
    与1.x相比，2.1.x版本变化
        保留原来所有功能
        自动监控资源
        对各资源组进行独立监控
        同时监控系统负载
            自动切换到负载低的node上
</code></pre>

<h3 id="keepalived">keepalived</h3>

<pre><code>vrrp
    # virtual router redundancy protocol 虚拟路由器冗余协议
    # 解决静态路由出现的闪单点故障问题，它能够保证网络的不间断．稳定运行
</code></pre>

<h2 id="负载">负载</h2>

<pre><code># load balance
方法
        dns轮循

        java nio
        erlang语言
        linux epoll
        bsd kqueue
        消息队列、事件通知
        c/c++下ace, boost.asio, libev(libevent)
        服务器mina, jetty, node.js, netty
        java协程框架 quasar kilim
</code></pre>

<h3 id="haproxy">haproxy</h3>

<pre><code>监控页面
        /status
</code></pre>

<h3 id="nginx">nginx</h3>

<h3 id="varnish">varnish</h3>

<h3 id="squid">squid</h3>

<h3 id="lvs">lvs</h3>

<pre><code>介绍
    第四层开始负载(可以建立到三层负载)

    第四层负载
        socket进必须连lvs

模式
    tun
        # lvs负载均衡器将请求包发给物理服务器，后者将应答包直接发给用户
    net
        # 请求和应答都经过lvs
    dr
        # 不要隧道结构的tun
使用
    DR模式 centos6
    yum install-y gcc gcc-c++ makepcre pcre-devel kernel-devel openssl-devel libnl-devel popt-devel
    modprobe -l |grep ipvs
        # 检查内核是否集成
    echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward
        # 开启路由转发
    安装ipvsadm
        http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz
    安装keepalived
        http://www.keepalived.org/software/keepalived-1.2.7.tar.gz
        ./configure --prefix=/usr/local/keepalived

        cp  /usr/local/keepalived/etc/rc.d/init.d/keepalived        /etc/init.d/
        cp /usr/local/keepalived/etc/sysconfig/keepalived        /etc/sysconfig/
        mkdir /etc/keepalived/
        cp /usr/local/keepalived/etc/keepalived/keepalived.conf        /etc/keepalived/
        cp /usr/local/keepalived/sbin/keepalived        /usr/sbin/

        o-&gt; 配置文件/etc/keepalived/keepalived.conf
        ! Configuration File forkeepalived
        global_defs {
        notification_email {
        test@sina.com    #故障接受联系人
        }
        notification_email_from admin@test.com  #故障发送人
        smtp_server 127.0.0.1  #本机发送邮件
        smtp_connect_timeout 30
        router_id LVS_MASTER  #BACKUP上修改为LVS_BACKUP
        }
        vrrp_instance VI_1 {
        state MASTER    #BACKUP上修改为BACKUP
        interface eth0
        virtual_router_id 51  #虚拟路由标识，主从相同
        priority 100  #BACKUP上修改为90
        advert_int 1
        authentication {
        auth_type PASS
        auth_pass 1111  #主从认证密码必须一致
        }
        virtual_ipaddress {    #Web虚拟IP（VTP）
        172.0.0.10
        }
        }
        virtual_server 172.0.0.10 80 { #定义虚拟IP和端口
        delay_loop 6    #检查真实服务器时间，单位秒
        lb_algo rr      #设置负载调度算法，rr为轮训
        lb_kind DR      #设置LVS负载均衡DR模式
        persistence_timeout 50 #同一IP的连接60秒内被分配到同一台真实服务器
        protocol TCP    #使用TCP协议检查realserver状态
        real_server 172.0.0.13 80 {  #第一个web服务器
        weight 3          #节点权重值
        TCP_CHECK {      #健康检查方式
        connect_timeout 3 #连接超时
        nb_get_retry 3    #重试次数
        delay_before_retry 3  #重试间隔/S
        }
        }
        real_server 172.0.0.14 80 {  #第二个web服务器
        weight 3
        TCP_CHECK {
        connect_timeout 3
        nb_get_retry 3
        delay_before_retry 3
            }
        }
        }

        service keepalived restart

    启动脚本 /etc/init.d/real.sh
        #description : start realserver
        VIP=172.0.0.10
        . /etc/init.d/functions
        case &quot;$1&quot; in
        start)
        /sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up
        echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
        echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
        echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
        echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce
        echo &quot;LVS RealServer Start OK&quot;
        ;;
        stop)
        /sbin/ifconfig lo:0 down
        echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
        echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
        echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
        echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce
        echo &quot;LVS RealServer Stoped OK&quot;
        ;;
        *)
        echo &quot;Usage: $0 {start|stop}&quot;
        exit 1
        esac

    o-&gt; 开机启动
        chmod +x /etc/init.d/real.sh
        /etc/init.d/real.sh start
        echo &quot;/etc/init.d/real.sh start&quot; &gt;&gt; /etc/rc.local
    o-&gt; 测试
        service httpd start
        echo &quot;1&quot; &gt; /var/www/html/index.html
        service iptables stop
        setenforce 0
            # 关闭selinux
    o-&gt; 其他命令
        ipvsadm -ln
            # 集群中服务器ip信息
        ip addr
            # 显示VIP当前绑定的服务器
        tail -f /var/log/messages
            # 日志
</code></pre>

<h1 id="通信服务">通信服务</h1>

<h2 id="log">log</h2>

<h3 id="elk">elk</h3>

<pre><code>        # elasticsearch, logstash, kibana
</code></pre>

<h3 id="log-io">log.io</h3>

<h2 id="mq">mq</h2>

<h3 id="rabbitmq">rabbitMQ</h3>

<pre><code>install
        yum install rabbitmq-server
命令
        添加用户:
                rabbitmqctl add_user rainbird password
        添加权限:
                rabbitmqctl set_permissions -p &quot;/&quot; rainbird &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
        删除测试用户:
                rabbitmqctl delete_user guest
原理
    虚拟主机 virtual host: 用户通过虚拟主机进行权限控制(如禁止A组访问B组的交换机)
            ＃ 默认虚拟主机为&quot;/&quot;
            队列 queue: 由生产者(producers)通过程序建立，再通过消费者(consuming)连接取走
                    消息:
                            路由键 routing key
            交换机 exchange: 负责把消息放入队列
                    绑定 binding(路由规则): 如指明交换机中具有路由键&quot;X&quot;的消息要到名为&quot;Y&quot;的队列中去
                            # 如果同一个键对应多个队列，则复制后分别发送

    功能
            持久化
                    队列和交换机创建时指定标志durable,指定队列和交换机重启生重建
                            ＃ 如果绑定了durable的队列和durable的交换机，该绑定自动保留
                            ＃ non-durable的交换机与durable的队列不能绑定
                            ＃ 一但创建durable标志，不能修改
                    消息发布到交换机时，指定标志Delivery Mode=2,这样消息会持久化
使用(原文http://adamlu.net/rabbitmq/tutorial-one-python)
        安装python 与插件支持
                pip
                python-pip git
                python-pika
        rabbitmq-server start
        send.py
            #!/usr/bin/env python
            import pika

            connection = pika.BlockingConnection(pika.ConnectionParameters(
                    host='localhost'))
            channel = connection.channel()

            channel.queue_declare(queue='hello')

            channel.basic_publish(exchange='',
                                routing_key='hello',
                                body='Hello World!')
            print &quot; [x] Sent 'Hello World!'&quot;
            connection.close()
                    receive.py
                            #!/usr/bin/env python
            import pika

            connection = pika.BlockingConnection(pika.ConnectionParameters(
                    host='localhost'))
            channel = connection.channel()

            channel.queue_declare(queue='hello')

            print ' [*] Waiting for messages. To exit press CTRL+C'

            def callback(ch, method, properties, body):
                print &quot; [x] Received %r&quot; % (body,)

            channel.basic_consume(callback,
                                queue='hello',
                                no_ack=True)

            channel.start_consuming()
</code></pre>

<h3 id="jafka">jafka</h3>

<h3 id="kafaka">kafaka</h3>

<pre><code>介绍
    scala语言编写
架构
        push/pull队列架构，适合异构集群
        高吞吐率
        分布式
        支持数据并行到hadoop
工具
    manager # 监控
</code></pre>

<h3 id="nsq">nsq</h3>

<pre><code>介绍
    go
工具
    admin   # 监控
</code></pre>

<h3 id="memcacheq">memcacheQ</h3>

<h3 id="zeromq">zeroMQ</h3>

<h3 id="activemq">activeMQ</h3>

<h3 id="beanstalkd">beanstalkd</h3>

<h3 id="mqtt">mqtt</h3>

<pre><code>    # 最早由ibm提供的，二进制消息的mq
</code></pre>

<h2 id="任务">任务</h2>

<h3 id="quartz">quartz</h3>

<pre><code># java
</code></pre>

<h3 id="celery">celery</h3>

<pre><code># python
</code></pre>

<h3 id="rundeck">rundeck</h3>

<pre><code># java
</code></pre>

<h1 id="存储服务">存储服务</h1>

<pre><code>存储的概念和术语
    scsi: 小型计算机系统接口(Small Computer System Interface)
    fc: 光纤通道(Fibre channel)
    das: 直连式存储(Direct-Attached Storage)
    nas: 网络接入存储(Network-Attached Storage)
    san: 存储区域网络(Storage Area Network)
        连接设备: 路由,  光纤交换机, 集线器(hub)
        接口: scsi fc
        通信协议: ip scsi
</code></pre>

<h2 id="iscsi">iscsi</h2>

<pre><code># internet scsi
优点
    可以网络传输
    服务器数量无限
    在线扩容．动态部署
架构
    控制器架构: 专用数据传输芯片．专用RAID数据校验芯片．专用高性能cache缓存和专用嵌入式系统平台
    iscsi连接桥架构:
        前端协议转换设备(硬件)
        后端存储(scsi磁盘阵列．fc存储设备)
    pc架构
        存储设备搭建在pc服务器上，通过软件管理成iscsi, 通过网卡传输数据
        实现
            以太网卡 + initiator软件
            toe网卡 + initiator软件
            iscsi HBA卡
iscsi系统组成
    iscsi initiator 或　iscsi hba
    iscsi target
    以太网交换机
    一台或多台服务器
</code></pre>

<h2 id="fastdfs">fastdfs</h2>

<pre><code># 开源分布式文件系统
</code></pre>

<h2 id="squid-1">squid</h2>

<pre><code>配置文件
    /etc/squid/squid.conf
代理类型
    普通代理
    透明代理
    反向代理
缓存
    动态资源
    静态资源
参考资料
    squid 透明代理详解
配置
    # squid.conf
    http_port 3128                                                # squid服务端口
    icp_port 3130                                                # udp端口,用来接收和发送ICP消息
    cache_dir ufs /var/spool/squid                                # 缓存目录, 写入方式有aufs与ufs两种,aufs使用大量线程异步进行磁盘i/o操作
    cache_access_log /var/log/squid/access.log
    cache_log /var/log/squid/cache.log
    cache_store_log /var/log/squid/store.log
    pid_filename /var/run/squid.pid                        # 日志文件位置

    #auth_param basic children 5
    #auth_param basic realm Squid proxy-caching web server
    #auth_param basic credentialsttl 2 hours                 # 关闭认证，认证一般不需要

    cache_effective_user squid
    cache_effective_group squid
    cache_mgr youraccount@your.e.mail                        # 设置squid用户及用户组、管理员账号

    cache_mem 128 MB                                        # 运行内存配置

    cache_swap_low 90
    cache_swap_high 95
    maximum_object_size 4096 KB                        ＃ 与磁盘容量相关的配置，90、95为百分比，磁盘大时4096 KB可以改成32768 KB

    maximum_object_size_in_memory 8 KB                ＃ 内存缓存资料大小

    以下为定义acl(访问控制列表)
            ＃ 语法为:acl&lt;acl&gt; &lt;acl名称&gt; &lt;acl类型&gt; &lt;配置的内容&gt;
    acl All src 0/0
    acl Manager proto cache_object  acl Localhost src 127.0.0.1/32
    acl Safe_ports port 80 21 443 563 70 210 280 488 591 777 1025-65535
    acl SSL_ports 443 563
    acl CONNECT method CONNECT
    acl MyNetwork src 192.168.0.0/16

    以下为利用前面定义的acl,定义访问控制规则
    http_access allow Manager Localhost
    http_access deny Manager
    http_access deny !Safe_ports
    http_access deny CONNECT SSL_ports
    http_access allow MyNetwork
    http_access deny All

    例子: 禁止访问sina
    acl sina dstdomain .sina.com.cn .sina.com
    http_access deny sina
    或
    acl sina dst 58.63.236.26 58.63.236.27 58.63.236.28 58.63.236.29 58.63.236.30 58.63.236.31 58.63.236.32 58.63.236.33 58.63.236.34 58.63.236.35 58.63.236.36 58.63.236.37 58.63.236.38 58.63.236.39 58.63.236.49 58.63.236.50
    http_access deny sina
    或
    acl sina dst www.sina.com.cn
    http_access deny sina

    例子: 禁止来自某些ip的访问
    acl zhang src 192.168.63.6/32
    http_access deny zhang

    例子: 禁止在某些时段访问
    acl Working_hours MTWHF 08:00-17:00
    http_access allow Working_hours
    http_access deny !Working_hours

    例子: 禁止某个代理客户建立过多连接
    acl OverConnLimit maxconn
    http_access deny OverConnLimit

    定义与其它代理服务器的关系,语法: &lt;cache_peer&gt; &lt;主机名称&gt; &lt;类别&gt; &lt;http_port&gt; &lt;icp_port&gt; &lt;其它参数&gt;
    cache_peer 192.168.60.6 parent 4480 7 no-query default

    #设置与其它代理服务器的关系: &lt;cache_peer_access&gt; &lt;上层 Proxy &gt; &lt;allow|deny&gt; &lt;acl名称&gt;
    #cache_peer_access 192.168.60.6 allow aclxxx
    #cache_peer_access 192.168.60.6 deny !aclxxx
    coredump_dir /var/spool/squid                                        # 崩溃存储目录
使用
    step1 检查配置文件
        squid -k parse
    step2  初始化cache 目录
        squid -z(X)                                # X会显示过程
    step3 启动squid
        service squid start
        或
        /usr/local/squid/sbin/squid -sD
    停止squid
        squid -k shutdown
    重新载入配置
        squid -k reconfigure
    滚动日志
        squid -k rotate
案例
    透明代理
        step1 检查配置文件
            squid -k parse
        step2  初始化cache 目录
            squid -z(X)                                # X会显示过程
        step3 启动squid
            service squid start
            或
            /usr/local/squid/sbin/squid -sD
        停止squid
            squid -k shutdown
        重新载入配置
            squid -k reconfigure
        滚动日志
            squid -k rotate
    代理
        squid.conf
            http_port 3128
            http_access allow all
            或
            http_port 3128
            http_access deny all前面添加
            acl 192.168.0.42 src 192.168.0.0/24
            http_access allow 192.168.0.42                        ＃ 192.168.0.42为允许的ip
</code></pre>

<h2 id="varnish-1">varnish</h2>

<pre><code># 反向代理，web缓存
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/hugo-blog/commit/527b54f06fb1e4192f7f9c86cfded0cda859d1b3" title='Last modified Jun 17, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Jun 17, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/hugo-blog/tree/master/content/docs/architecture/_index.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#名词">名词</a></li>
<li><a href="#模块">模块</a></li>
<li><a href="#mesh">mesh</a>
<ul>
<li><a href="#lstio">lstio</a></li>
<li><a href="#linkerd">linkerd</a></li>
<li><a href="#fingle">fingle</a></li>
<li><a href="#envoy">envoy</a></li>
<li><a href="#nginmesh">nginmesh</a></li>
</ul></li>
<li><a href="#paas">paas</a>
<ul>
<li><a href="#cloudstack">cloudStack</a></li>
<li><a href="#kubernetes">kubernetes</a></li>
<li><a href="#cloudfoundry">cloudfoundry</a></li>
<li><a href="#openstack">openstack</a></li>
<li><a href="#hsf">hsf</a></li>
</ul></li>
<li><a href="#rpc">rpc</a>
<ul>
<li><a href="#hsf-1">hsf</a></li>
<li><a href="#thrift">thrift</a></li>
<li><a href="#dubbo">Dubbo</a></li>
<li><a href="#cxf">cxf</a></li>
<li><a href="#spring-cloud">spring cloud</a></li>
<li><a href="#grpc">grpc</a></li>
<li><a href="#protobuf">protobuf</a></li>
</ul></li>
<li><a href="#rmi">rmi</a>
<ul>
<li><a href="#hessian">hessian</a></li>
</ul></li>
<li><a href="#soa">soa</a>
<ul>
<li><a href="#eai">eai</a></li>
<li><a href="#esb">esb</a></li>
</ul></li>
<li><a href="#粘合层">粘合层</a>
<ul>
<li><a href="#zookeeper">zookeeper</a></li>
<li><a href="#gearman">gearman</a></li>
<li><a href="#etcd">etcd</a></li>
<li><a href="#mesos">mesos</a></li>
</ul></li>
<li><a href="#tracing">tracing</a>
<ul>
<li><a href="#zipkin">zipkin</a></li>
<li><a href="#opentracing">opentracing</a></li>
</ul></li>
<li><a href="#monitor">monitor</a>
<ul>
<li><a href="#spy-js">spy.js</a></li>
<li><a href="#alinode">alinode</a></li>
<li><a href="#oneapm">oneapm</a></li>
<li><a href="#nscale">nscale</a></li>
</ul></li>
<li><a href="#ha">ha</a>
<ul>
<li><a href="#心跳">心跳</a>
<ul>
<li><a href="#heartbeat">heartbeat</a></li>
<li><a href="#keepalived">keepalived</a></li>
</ul></li>
<li><a href="#负载">负载</a>
<ul>
<li><a href="#haproxy">haproxy</a></li>
<li><a href="#nginx">nginx</a></li>
<li><a href="#varnish">varnish</a></li>
<li><a href="#squid">squid</a></li>
<li><a href="#lvs">lvs</a></li>
</ul></li>
</ul></li>
<li><a href="#通信服务">通信服务</a>
<ul>
<li><a href="#log">log</a>
<ul>
<li><a href="#elk">elk</a></li>
<li><a href="#log-io">log.io</a></li>
</ul></li>
<li><a href="#mq">mq</a>
<ul>
<li><a href="#rabbitmq">rabbitMQ</a></li>
<li><a href="#jafka">jafka</a></li>
<li><a href="#kafaka">kafaka</a></li>
<li><a href="#nsq">nsq</a></li>
<li><a href="#memcacheq">memcacheQ</a></li>
<li><a href="#zeromq">zeroMQ</a></li>
<li><a href="#activemq">activeMQ</a></li>
<li><a href="#beanstalkd">beanstalkd</a></li>
<li><a href="#mqtt">mqtt</a></li>
</ul></li>
<li><a href="#任务">任务</a>
<ul>
<li><a href="#quartz">quartz</a></li>
<li><a href="#celery">celery</a></li>
<li><a href="#rundeck">rundeck</a></li>
</ul></li>
</ul></li>
<li><a href="#存储服务">存储服务</a>
<ul>
<li><a href="#iscsi">iscsi</a></li>
<li><a href="#fastdfs">fastdfs</a></li>
<li><a href="#squid-1">squid</a></li>
<li><a href="#varnish-1">varnish</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
