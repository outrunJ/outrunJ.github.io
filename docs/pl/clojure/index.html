<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clojure | outrun的笔记</title>


<link rel="stylesheet" href="/book.min.6c7317d2e8552a0ac3ea8fd4ba500c3dfb1cc9c74e7afd73eee6d729751fad30.css">


<script defer src="/search.min.ee27cec5adeebb17f8ab96e7260ab73b42d3cfc1dcca73a13fceb99f2ef14cff.js"></script>



<link rel="icon" href="/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">outrun的笔记</a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fpl\2f clojure\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/project">项目</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/principle">原理</a></li>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/markup_language"><strong><em>标记语言</em></strong></a>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
<li><a href="/docs/architecture/3rd_product">第三方服务</a></li>
<li><a href="/docs/architecture/nginx">nginx</a></li>
<li><a href="/docs/architecture/nodejs">nodejs</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/principle">原理</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/javaweb">javaweb</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">pgsql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/linux_tool">linux工具</a></li>
<li><a href="/docs/ops/security">安全</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a></li>
<li><a href="/docs/tool"><strong>图形工具</strong></a>

<ul>
<li><a href="/docs/tool/vim">vim</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
</ul></li>
<li><a href="/docs/method">方法</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/interview">题目</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
</ul>







</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>Clojure</strong>
</header>

      
<article class="markdown">

<h1 id="介绍">介绍</h1>

<pre><code>    是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程
    操作符知道自己的特征值(identity value), 如+是0, *是1
    数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃
    集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能
            # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的
    没有尾递归优化，不常用递归，要用loop.recur
</code></pre>

<h1 id="语法">语法</h1>

<pre><code>    s-expressions
            (max 3 5)
            (+ 1 (* 2 3))
            (def meaning-of-life 42)
            (if (&lt; meaning-of-life 0) &quot;negative&quot; &quot;non-negative&quot;)
    (def droids [&quot;Huey&quot; &quot;Dewey&quot; &quot;Louie&quot;])
            (count droids)
            (droids 0)
    (def me {:name &quot;Paul&quot; :age 45 :sex :male})
            (:age me)
    (defn percentage [x p] (* x (/ p 100.0)))
            (percentage 200 10)
</code></pre>

<h1 id="并发">并发</h1>

<pre><code>o-&gt; 原子变量
        # 对一个值进行同步更新
(def my-atom (atom 42))
(deref my-atom)
@my-atom
(swap! my-atom inc)
(swap! my-atom + 2)
(reset! my-atom 0)

(def session (atom {}))
(swap! session assoc :username &quot;paul&quot;)

(if (compare-and-set! a old new)
        # 判断原子变量a的值是否是old, 是时赋成new并返回true
new
(recur))

o-&gt; conj 添加新成员
(def players (atom ()))
(defn list-players []
(response (json/encode @players)))
(defn create-player [player-name]
(swap! players conj player-name)
(status (response &quot;&quot;) 201))
(defroutes app-routes
(GET &quot;/players&quot; [] (list-players))
(PUT &quot;/players/:player-name&quot; [player-name] (create-player player-name)))
(defn -main [&amp; args]
(run-jetty (site app-routes) {:port 3000}))

o-&gt; cons列表首添加元素
(def listv2 (cons 4 listv1))

o-&gt; validator
        # 值改变之前调用
(def non-negative (atom 0 :validator #(&gt;= % 0)))
(reset! non-negative -1)

o-&gt; 监视器
        # 值改变之后调用　
(def a (atom 0))
(add-watch a :print #(println &quot;Changed from &quot; %3 &quot; to &quot; %4))
(swap! a + 2)
        # !的命名表示函数是事务不安全的

o-&gt; 代理
        # 对一个值进行异步更新。
        # 代理维护的数据与事务数据相同。代理具有事务性，send会在事务成功后生效
        # 方便做内存并发日志系统
(def my-agent (agent 0))
@my-agent
(send my-agent inc)
        # send在值更新之前立即返回，不进行重试。多线程同时调用send, 调用被串行。具有副作用
        # send使用公用线程池，send-off使用一个新线程，send-via使用由参数指定的executor
(send my-agent #((Thread/sleep 2000) (inc %)))
        # 设置延迟时间
(await my-agent)
        # 等待代理执行完成后再继续。await-for函数可以设置超时时间

(def non-negative (agent 1 :validator (fn [new-val] (&gt;= new-val 0))))
        # 代理可以使用校验器和监视器
        # 校验器失败时抛出异常，代理进入失效状态
        # 错误处理模式默认为 :fail, 可以置为:continue
        # 可以设置错误处理函数
(agent-error non-negative)
        # 查看代理是否在失效状态
(restart-agent non-negative 0)
        # 重置失效状态

o-&gt; 引用
        # 只有在事务中才能修改引用的值，对多个值进行同步更新
(def my-ref (ref 0))
@my-ref

(dosync (ref-set my-ref 42))
        # dosync创建一个事务，事务同swap!一样，用重试机制实现
        # clojure的事务有原子性，一致性，隔离性，没有持久性
(dosync (alter my-ref inc))
        # commute替换alter，可以得到不很强的隔离性，用于做优化
(defn transfer [from to amount]
(dosync 
    (alter from - amount)
    (alter to + amount)))

o-&gt; threed
(defn stress-thread [from to iterations amount]
(Thread. #(dotimes [_ iterations] (transfer from to amount))))
(let [t1 (stress-thread checking savings 100 100)
    t2 (stress-thread savings checking 200 100)]
(.start t1)
(.start t2)
(.join t1)
(.join t2))

o-&gt; ensure确保当前返回的值不被其它事务修改
(when (and (= (ensure left) :thinking) (= (ensure right) :thinking))
(ref-set philosopher :eating))
</code></pre>

<h2 id="csp">csp</h2>

<pre><code>介绍
        core.async提供了channel和go块
        引入的core.async中部分函数名与clojure核心库函数名冲突

o-&gt; channel
(def c (chan))
(thread (println &quot;Read:&quot; (&lt;!! c) &quot;from c&quot;))
        # thread是core.async提供的辅助宏，将其中代码运行在一个单独的线程上
(&gt;!! c &quot;Hello thread&quot;)
</code></pre>

<h1 id="用例">用例</h1>

<pre><code>o-&gt;求和
(defn recursive-sum 
&quot;&quot;
        # 文档字符串
        ## (require '[philosophers.util :refer :all])
        ## (clojure.repl/doc swap-when!) 来查看文档字符串
[numbers &amp; args])
        # &amp;表示可变参数
        ## (apply f old args) 将args展开，作为附加参数传递给f
(if (empty? numbers)
    0
    (+ (first numbers) (recursive-sum (rest numbers))))

(defn reduce-sum [numbers]
(reduce (fn [acc x] (+ acc x)) 0 numbers))

(defn sum [numbers]
(reduce + numbers))

o-&gt;并行
(ns sum.core
(:require [clojure.core.reducers :as r]))

(defn parallel-sum [numbers]
(r/fold + numbers))

(def numbers (into [] (range 0 10000)))
(time (sum numbers))
(time (sum numbers))
        # 预热jim编译器
(time (parallel-sum numbers))

o-&gt; map
(def counts {&quot;apple&quot; 2 &quot;orange&quot; 1})
        (get counts &quot;apple&quot; 0)
        (get counts &quot;banana&quot; 0)
                # 没有时返回设定的默认值0
        (assoc counts &quot;banana&quot; 1)
        (assoc counts &quot;apple&quot; 3)

o-&gt; frequencies
(defn word-frequencies [words]
(reduce
(fn [counts word] (assoc counts word (inc (get counts word 0))))
{} words))

(frequencies [&quot;one&quot; &quot;potato&quot;])
        # 标准库中已提供

o-&gt; partial函数
        # 返回一个被局部代入的函数
(def multiply-by-2 (partial * 2))
(multiply-by-2 3)

o-&gt; 序列
(defn get-words [text] (re-seq #&quot;\w+&quot; text))
(get-words &quot;one tow three four&quot;)
(map get-words [&quot;one two three&quot; &quot;four five six&quot;])
(mapcat get-words [&quot;one two three&quot; &quot;four five six&quot;])
        # 平辅数组

o-&gt; iterate
        # 不断将函数应用到初始值，第一次返回值，第二次返回值
(take 10 (iterate inc 0))
(take 10 (iterate (partial + 2) 0))
(take-last 5 (range 0 10000))
        # 头元素使用后舍弃，耗相同的内存

o-&gt; pmap
(pmap #(frequencies (get-words %)) pages)
        # pmap在需要结果时并行计算，仅生成需要的结果，称为半懒惰(semi-lazy)
        # #(...)是读取器宏，来快速创建匿名函数，参数通过%1, %2标识, 只有一个参数时可以是%
        ## (fn [page] (frequencies (get-words page)))与其等价

o-&gt; merge-with
        # 标准库函数
(merge-with f &amp; maps)
        # 将maps中其余map合并到第一个map中，返回合并后的map
        ## 同键名时，多个值从左向右地合并，调用传递的f(val-in-result val-in-latter)
(def merge-counts (partial merge-with +))
(merge-counts {:x 1 :y 2} {:y 1 :z 1})

o-&gt; partition-all
        # 序列分批
(partition-all 4 [1 2 3 4 5 6 7 8 9 10])
        # ((1 2 3 4) (5 6 7 8) (9 10))

o-&gt; reducers包
        # 化简器，不代表函数的结果，代表如何产生结果的描述
        ## 嵌套的函数返回化简器，比返回懒惰序列效率更高
        ## 可以对整个嵌套链的集合操作，可以用fold进行并行化
        # clojure.core中大部分函数都有其对应的化简器版本
(require '[clojure.core.reducers :as r]')
(r/map (partial * 2) [1 2 3 4])
        # 返回一个化简器(reducible)
(reduce conj [] reducible)
        # conj函数第一个参数为一个集合(初始值为[]), 将第二个参数合并到第一个参数中
(into [] reducible)
        # into函数为内置函数，同上

o-&gt;协议(类似java中的接口)来定义
(defprotocol CollReduce
        # 化简
(coll-reduce [coll f] [coll f init]))
        # coll相当于this, 支持多态性分派(polymorphic dispatch)
(coll-reduce coll f)

(defn my-reduce
([f coll] (coll-reduce coll f))
([f init coll] (coll-reduce coll f init)))
(my-reduce + [1 2 3 4])
(my-reduce + 10 [1 2 3 4])

(defn make-reducer [reducible transforms]
(reify
    CollReduce
    (coll-reduce [_ f1]
    (coll-reduce reducible (transformf f1) (f1)))
    (coll-reduce [_ f1 init]
    (coll-reduce reducible (transformf f1) init))))
        # 用reify实现一个协议
        # 调用reducible的coll-reduce方法。用transformf对f1进行转换，转换出的函数作为传给coll-reduce方法的一个参数
        # _表示未被使用的函数参数名，可以写成(coll-reduce [this f1])

(defn my-map [mapf reducible]
(make-reducer reducible
    (fn [reducef]
    (fn [acc v]
        (reducef acc (mapf v))))))
        # acc是之前化简结果, v是集合元素。mapf对v进行转换

o-&gt; fold折叠
        # 不能适用于懒惰序列
(defprotocol CollFold
(coll-fold [coll n combinef reducef]))

(defn my-fold
([reducef coll]
    (my-fold reducef reducef coll))
([combinef reducef coll]
    (my-fold 512 combinef reducef coll))
([n combinef reducef coll]
    (coll-fold coll n combinef reducef)))

(defn make-reducer [reducible transformf]
(reify
    CollFold
    (coll-fold [_ n combinef reducef]
    (coll-fold reducible n combinef (transformf reducef)))

    (CollReduce
    (coll-reduce [_ f1]
        (coll-reduce reducible (transformf f1) (f1)))
    (coll-reduce [_ f1 init]
        (coll-reduce reducible (transformf f1) init))))

(def numbers (into [] (take 10000000 (repeatedly #(rand-int 10)))))
(require ['reducers.parallel-frequencies :refer :all'])
(time (frequencies numbers))
(time (parallel-frequencies numbers))

o-&gt; doall强迫懒惰序列对全部元素求值
(reduce + (doall (map (partial * 2) (range 10000))))

o-&gt; future
        # 单独线程中执行一段代码
        # 典型场景是异步通信
(def sum (future (+ 1 2 3 4 5)))
sum
        # 返回一个future对象
(deref sum)
@sum
        # 运行
(let [a (future (+ 1 2))
    b (future (+ 3 4))]
(+ @a @b))
        # let给a赋值，阻塞当前线程直到被求值
        # 外层加法将一直阻塞，直到所有代表的值被求值

o-&gt; promise
        # 创建promise对象后，代码并不会像future一样立即执行，等待deliver赋值后执行
(def meaning-of-life (promise))
(future (println &quot;The meaning of life is:&quot; @meaning-of-life))
(deliver meaning-of-life 42)

o-&gt; Compojure库的服务器
(def snippets (repeatedly promise))
(defn accept-snippet [n test]
(deliver (nth snippets n) test))
(future
(doseq [snippet (map deref snippets)]
    (println snippet)))

(defroutes app-routes
(PUT &quot;/snippet/:n&quot; [n :as {:keys [body]}]
    (accept-snippet (edn/read-string n) (slurp body))
    (response &quot;OK&quot;)))
(defn -main [&amp; args]
(run-jetty (site app-routes) {:port 3000}))

o-&gt; re-seq正则
(defn sentence-split [text]
(map trim (re-seq #&quot;[^\.!\?:;]+[\.!\?:;]*&quot; text)))
        # trim是内置函数
(defn is-sentence? [text]
(re-matches #&quot;^.*[\.!\?:;]$&quot; text))

o-&gt; reductions
        # 同reduce, 返回中间值构成的序列
(reductions + [1 2 3 4])
        # (1 3 6 10)

o-&gt; clj-http库
(def translator &quot;http://localhost:3001/translate&quot;)
(defn translate [text]
(future
    (:body (client/post translator {:body text}))))

o-&gt; delay在解引用前不求值
(def translations
(delay
    (map translate (strings-&gt;sentences (map deref snippets)))))

o-&gt; 系统时间
(defn now []
(System/currentTimeMillis))

o-&gt; Schejulure库
(def session-sweeper
(schedule {:min (range 0 60 5)} sweep-sessions))
        # 定期调用

o-&gt; Useful库
(defn expired? [session]
(&lt; @(:last-referenced session) (session-expiry-time)))
(defn sweep-sessions []
(swap! sessions #(remove-vals % expired?)))
        # 删除元素

o-&gt; Loop/Recur
(defn swap-when! [a pred f &amp; args]
(loop []
    (let [old @a]
    (if (pred old)
        (let [new (apply f old args)]
        (if (compare-and-set! a old new)
            new
            (recur)))
        nil))))
</code></pre>

<h1 id="工具">工具</h1>

<pre><code>clojureScript
        # 编译到js
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/hugo-blog/commit/527b54f06fb1e4192f7f9c86cfded0cda859d1b3" title='Last modified Jun 17, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Jun 17, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/hugo-blog/tree/master/content/docs/pl/clojure.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#介绍">介绍</a></li>
<li><a href="#语法">语法</a></li>
<li><a href="#并发">并发</a>
<ul>
<li><a href="#csp">csp</a></li>
</ul></li>
<li><a href="#用例">用例</a></li>
<li><a href="#工具">工具</a></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
