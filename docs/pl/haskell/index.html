<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Haskell
  
 | outrun的笔记</title>



<link rel="stylesheet" href="/book.min.1a0250256273fabf0f848ed9a3c50aae344d758339cad9725e656ac71546e6f5.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">outrun的笔记</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fpl\2fhaskell\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/project">项目</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/principle">原理</a></li>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/markup_language"><strong><em>标记语言</em></strong></a>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
<li><a href="/docs/architecture/nginx">nginx</a></li>
<li><a href="/docs/architecture/nodejs">nodejs</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/principle">原理</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/javaweb">javaweb</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">pgsql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/linux_tool">linux工具</a></li>
<li><a href="/docs/ops/security">安全</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a></li>
<li><a href="/docs/tool"><strong>图形工具</strong></a>

<ul>
<li><a href="/docs/tool/vim">vim</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
</ul></li>
<li><a href="/docs/management">管理</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/interview">题目</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Haskell
  
</strong>
</header>

      
<article class="markdown">

<h1 id="介绍">介绍</h1>

<pre><code>源于ML
标准化的、纯函数式编程语言
非限定性语义和强静态类型
作为其他语言设计新功能时的样板，如Python的lambda标记语句
</code></pre>

<h1 id="工具">工具</h1>

<pre><code>检索函数用http://www.Haskell.org/hoogle
</code></pre>

<h1 id="单词">单词</h1>

<pre><code>polymorphism
    # 多态
monomorphic
    # 单态
</code></pre>

<h1 id="风格">风格</h1>

<pre><code>point free style
    sum' xs = foldl (+) 0 xs
    sum' = foldl (+) 0
</code></pre>

<h1 id="注意">注意</h1>

<pre><code>使用缩进代替括号，但也可用括号
</code></pre>

<h1 id="文件扩展名">文件扩展名</h1>

<pre><code># 文件中不用let定义变量, 
# 变量赋值两次会报错, 这意味着代码顺序不重要
hs
</code></pre>

<h1 id="内置变量">内置变量</h1>

<pre><code>pi
</code></pre>

<h1 id="模块">模块</h1>

<pre><code>:m Data.Char Data.Map
    # 加载模块
    chr
        # chr :: Int -&gt; Char
    ord
        # ord :: Char -&gt; Int
    toUpper
    toLower
import Data.Char
    # 导入到全局命名空间
    import Data.List (nub, sort)
    import Data.List hiding (nub)
    import qualified Data.Map as M
        # 这样其中命名冲突的filter, null函数，只能用Data.Map.filter或M.filter方式调用
可用模块
    prelude
        # 默认载入的模块
    Data
        Char
        List
        Map
        Set
自定义模块
module Geometry.Sphere
(sphereVolume
, sphereArea
, Shape(..)
    # 导出类型和其所有构造子
) where
sphereVolum :: Float -&gt; Float
sphereVolum radius = (4.0 / 3.0) * pi * (radius ^ 3)
</code></pre>

<h1 id="命令函数">命令函数</h1>

<pre><code>:load
    # 加载模块
    :load a.hs
:l
:cd
    # 切换工作目录
    :cd c:\a
:reload
    # 重载所有模块
:r
:type
    :type 'H'
:t
:info
    # 查看一个typeclass有哪些instance和subclass
    # 类型的信息、函数的类型声明
:k
    # 查看kind
    :k Int
        # Int :: *
    :k Maybe
        # Maybe :: * -&gt; *
</code></pre>

<h1 id="操作符">操作符</h1>

<pre><code>%
    # 分号
&amp;&amp;
||
++    
    # 字符串拼接
/=
    # 不等
do
    # 动作的combine, do 是&gt;&gt;=的语法糖, 用来连接一系列动作
&lt;-
    # name &lt;- getLine, 存到变量
    # 除了程序的最后一行用来作返回值，其它语句都可以用 &lt;-
</code></pre>

<h1 id="表达式">表达式</h1>

<pre><code># 表达式可以随处安放
if x &lt; 0 then
    -1
else if x &gt; 0 then
    1
else
    0

case x of
    0 -&gt; 1
    1 -&gt; 5
    _ -&gt; (-1)

let a = 1
    # 局部绑定, in可省略则定义到全局
    twice_a = 2 * a
in (a + twice_a, a - twice_a)

let boot x  y z = x * y + z in boot 3 4 2
</code></pre>

<h1 id="i-o-action">I/O action</h1>

<pre><code># 在main中 I/O action才被执行
# return () 语句产生I/O action, do接着执行
# 执行后会打印结果，结果为()时不打印
main = do
    _ &lt;- putStrLn &quot;a&quot;
    name &lt;- getLine
    putStrLn (name)
</code></pre>

<h1 id="类型表示">类型表示</h1>

<pre><code>Eq a =&gt; a -&gt; a -&gt; Bool
    # =&gt; 前面是类型约束, 后面表示传入两个同类型参数，返回Bool类型
</code></pre>

<h1 id="变量">变量</h1>

<pre><code>let pi = 3.14
    # 变量不可变，但可重复定义
(-1)
    # 负数一般加小括号
  let r = 25 :: Double
    # 默认猜测是Integer
    # monomorphish restriction(单一同态限定)原理，可以指定polymorphic(多态)
    ## let r = 25 :: Num a =&gt; a
True, False
    # 类型为 Bool
&quot;abc&quot;
    # 类型为[char], 与'a':'b':'c':[]
    a = &quot;aaa&quot; :: String
        # 得到一个String, 与[char]同样使用
LT, GT, EQ
</code></pre>

<h1 id="函数">函数</h1>

<pre><code># 函数名与参数，参数与参数之间有空格隔开
# 函数比运算符先结合
let area r = pi * r ^ 2
    # 定义函数, 
area 2
area (-2)
let area2 r = area r
let first (x, y) = x
    # 接收元组
uppercase, lowercase :: String -&gt; String
    # 指定函数类型
分段定义
    # 编译成case语句
    f 0 = 1
    f 1 = 5
    f _ = -1
函数合成调用
    square (f 1)
    (square . f) 1
(\xs -&gt; length xs &gt; 15)
    # lambda表达式
    # lambda可以用模式匹配，但使用不了多个模式
</code></pre>

<h1 id="列表">列表</h1>

<pre><code># 列表，类型必须相同。
# 列表都由[]追加得到，逗号是语法糖
let n = [1, 2]
[1..20]
    # range浮点数不精确
take 20 [1,2..]
[2,4..20]
['a'..'z']
0:n
    # 得到追加列表[0, 1, 2]， 头部追加叫作consing, cons是constructor
    # -1:0:n
[[1], [2]]
n !! 1
    # 取元素
l1 &gt; l2
    # 元素依次比较
[x*2 | x &lt;- [1..10], x*2 &gt;= 12]
    # list comprehension
    boomBangs xs = [if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;-xs, odd x]
    [x*y | x &lt;-[1,2], y &lt;-[3,4]]
        # 聚合得[3,4,6,8]
    length' xs = sum [1 | _ &lt;- xs]

    xxs = [[1,2], [3,4]]
    [[x | x &lt;- xs, even x] | xs &lt;- xxs]

    [(a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 = c ^2]

    [a + b | (a,b) &lt;- xs]
        # list comprehension中的模式匹配
模式匹配
    x:xs
    x:y:z:xs
</code></pre>

<h1 id="元组">元组</h1>

<pre><code># 类型可不同，不能单元素。2元组叫pairs, 3元组叫triples, n元组叫n-tuple
# 元组不可变
# 元组的类型由长度和其中的类型决定, (&quot;a&quot;, 1)与(1, &quot;a&quot;)是不同的类型，所以[(&quot;a&quot;, 1), (2, &quot;b&quot;)]是错误的
(True, 1)
((1,2), True)
</code></pre>

<h1 id="monad">monad</h1>

<pre><code>o-&gt; do
doGuessing num = do
    putStrLn &quot;Enter your guess:&quot;
    guess &lt;- getLine
    if (read guess) &lt; num
    then do putStrLn &quot;Too low&quot;
        doGuessing num
    else if (read guess) &gt; num
    then do putStrLn &quot;Too high&quot;
        doGuessing num
    else putStrLn &quot;You Win&quot;
        # 只有一个动作时，可省略do

o-&gt; do
doGuessing num = do
    putStrLn &quot;Enter your guess:&quot;
    guess &lt;- getLine
    case compare (read guess) num of
        LT -&gt; do putStrLn &quot;Too low&quot;
        GT -&gt; do putStrLn &quot;Too high&quot;
        EQ -&gt; putStrLn &quot;You Win&quot;

o-&gt; functor applicative monad
class Functor f where
fmap :: (a -&gt; b) -&gt; f a -&gt; f b
class Functor f =&gt; Applicative f where
pure :: a -&gt; f a
() :: f (a -&gt; b) -&gt; f a -&gt; f b
class Applicative m =&gt; Monad m where
return :: a -&gt; m a
(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
(&gt;&gt;) :: m a -&gt; m b -&gt; m b
x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y
fail :: String -&gt; m a
fail msg = error msg
instance Functor Maybe where
fmap func (Just x) = Just (func x)
fmap func Nothing  = Nothing
instance Applicative Maybe where
pure = Just
Nothing  _ = Nothing
(Just func)  something = fmap func something
instance Monad Maybe where
return = Just
Nothing &gt;&gt;= func = Nothing
Just x &gt;&gt;= func  = func x
</code></pre>

<h1 id="内置函数">内置函数</h1>

<pre><code>prelude
    $
        # 函数调用符，优先级最低。而空格是最高优先级
        # $右结合。而空格左结合
        # 等价于在右而写一对括号
    .
        # f . g = \x -&gt; f (g x)
        # 函数组合
    main
        # main :: IO ()
        main = do
    signum
        # 根据数字返回 -1, 0, 1
    not
    id
        # identity
    unlines
        unlines [&quot;a&quot;, &quot;b&quot;]
            # 成为 &quot;a\nb\n&quot;
    unwords
        unwords [&quot;a&quot;, &quot;b&quot;]
            # 成为 &quot;a b&quot;
    show
        # 接受各种类型，转换为String, 再转义打印
    read
        read &quot;5&quot; :: Int
        read &quot;5&quot; - 2
        read &quot;[1,2,3]&quot; ++ [4]
    reads
        # 读取失败返回[]而不报错
    negate
        # 取反数字
    abs
        # 绝对值
    length
        # 列表的长度, [a] -&gt; Int , a在这里是一个type variable, 以小写字母开头(具体类型都大写开头)。
    map
    compare
        # 返回 LT, GT, EQ其中一个
    min
    max
    compare
        # 返回LT, GT, EQ
        &quot;Abc&quot; `compare` &quot;Zyx&quot;
    mod
        # 取模
    odd
        # 奇数
    even
        # 偶数
    succ
        # 取Enum的后继
    pred
        # 取Enum的前置
    minBound
        # 取Bound下限
    maxBound
    substract
        # 减

    head
    tail
        # 除第一个
    last
    init
        # 除最后一个

    null
        # 检查list是否空
    reverse
        # list反转
    take
        take 1 [1,2,3]
    takeWhile
        # 取list值，直到某条件
    drop
        drop 1 [1,2,3]
    maximum
        # list中最大元素
    minimun
        # list中最小元素
    sum
        # list和
    product
        # list积
    elem
        # 判断元素是否在list中
        4 `elem` [3,4,5]
    cycle
        take 7 (cycle [1,2,3])
            # [1,2,3,1,2,3,1]
    repeat
        repeat 5
    replicate
        replicate 3 10
            # [10, 10, 10]

    fst (1, 2)
        # 只适合2元组
    snd (1, 2)
        # 只适合2元组
    zip
        # zip3, zip4 ... zip7
        zip [1,2,3] [4,5,6]
            # [(1,4), (2,5), (3,6)]
    zipWith
        # zipWith1 ... zipWith7
        zipWith (\x y -&gt; x + y) [1,2] [3,4]
            # [4,6]
    fromIntegral
        # 返回更通用的数字类型
    error &quot;&quot;
        # 抛错
    flip
        # 翻转两个参数调用
    map
    filter
    foldl
        foldl (\acc x -&gt; acc + x) 0 xs
    foldr
        foldr (\x acc -&gt; f x : acc) [] xs
    foldl1
        # 以第一个元素为初始值，空list报错
    foldr1
    foldl'
        # foldl的strict版
    foldr'
    scanl
        # 返回累加过程的list
    scanr
    scanl1
    scanr1
    o-&gt; I/O action
        # 只有在main中执行
        # 类型为 IO a
        putStrLn
            # 只接受String，不转义打印，加换行符
            # putStrLn :: String -&gt; IO () , 表示接收String, 是IO动作, 结果类型是()。表示是一个&quot;IO monad&quot;动作
        putStr
            # 由putChar递归定义，边界条件是空字符串
        putChar
        print
            # 打印Show typeclass的值
        getLine
            # 控制台读一行
            # getLine :: IO String
            name &lt;- getLine
        getChar
        sequence
        # 顺序执行I/O action
        mapM
            mapM print [1,2,3]
                # 对list元素执行sequence f
        mapM_
            # 同mapM，不打印[(),()]
        getContents
            # 读直到 eof (ctrl + d)
        interact
            # 用函数处理输入，返回到输出
Data.List
    # 每个元素存在thunk中
    \
        # 差集
        [1..3] \\ [2]
            # [1,3]
        &quot;Im a big baby&quot; \\ &quot;big&quot;
            # &quot;Im a baby&quot;
    union
    intersection
    insert
        # 插入一个元素到可排序list相对位置
    nub
        # 去重复元素,常用Set转换取代,提高很多效率
    map
        # 导出到了prelude
    filter
        # 导出到了prelude
    intersperse
        intersperse '.' &quot;abc&quot;
            # &quot;a.b.c&quot;
    intercalate
        # 同intersperse, 但插入list
    transpose
        # 二元list列为行
    foldl'
        # fold的严格版，直接计算出中间值，而非用惰性&quot;承诺&quot;塞满堆栈
    foldl1'
    concat
        # 移除一级嵌套
    concatMap
        # 先map再concat
        concatMap (replicate 2) [1..3]
            # [1,1,2,2,3,3]
    and
        # list中全true返回true
        and $ map (&gt;4) [5,6,7,8]
    or
    any
    iterate
        # 无限迭代值到函数，结果形成list
        take 10 $ iterate (*2) 1
    splitAt
        # 断开list, 返回二元组
        splitAt 3 &quot;abcdef&quot;
            # (&quot;abc&quot;, &quot;def&quot;)
    takeWhile
        # 取元素，直到不符合条件
    dropWhile
    span
        # 同takeWhile, 不过返回分割list的二元组
    break
        # 同span, 但在条件首次为true时断开
    sort
        # list元素要求Ord类型，排序list
    group
        # 合并相邻并相等的list元素
    inits
        # init递归调用自身
        inits &quot;abc&quot;
            # [&quot;&quot;, &quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;]
    tails
        # tail递归调用自身
        tails &quot;abc&quot;
            # [&quot;abc&quot;, &quot;bc&quot;, &quot;c&quot;, &quot;&quot;]
    isInfixOf
        # list中搜索子list, 有则返回true
        &quot;cat&quot; `isInfixOf` &quot;im a cat&quot;
    isPrefixOf
        # 是否以某list开头
    isSuffixOf
        # 是否以某list结尾
    elem
        # 是否包含某元素
    notElem
    partition
        # 条件划分list为二元组
        partition (`elem` ['A'..'Z']) &quot;AbCD&quot;
            # (&quot;ACD&quot;, &quot;b&quot;)
    find
        # 条件查找list, 返回第一个符合元素的Maybe值
    elemIndex
        # 返回elem第一个元素的索引的Maybe值
    elemIndices
        # 返回所有匹配索引的list
    findIndex
    findIndices
    lines
        # 字符串分行到list
    unlines
    words
        # 字符串分词到list
    unwords
    delete
        # 删除list中第一个匹配元素
        delete 'h' &quot;hha&quot;
            # &quot;ha&quot;
    replace
    lookup
        # 用a查找[('a', 'b')]中的b
    genericLength
        # 换Int类型为Num类型
    genericTake
    genericDrop
    genericSplitAt
    genericIndex
    genericReplicate

    nubBy
        # 传递函数判断相等性，取代==
    deleteBy
    unionBy
    intersectBy
    groupBy
    sortBy
    insertBy
    maximumBy
    minimumBy
Data.Monoid
    Monoid
    Product
    Sum
    Any
    All
Data.Foldable
    foldr
    foldl
    foldr1
    foldl1
Data.Function
    on
        ((==) `on` (&gt; 0))
            # 判断相等性，等价于 (\x y -&gt; (x &gt; 0) == (y &gt; 0))
        (compare `on` length)
            # 判断大小
Data.Char
    isControl
        # 是否控制字符
    isSpace
        # 包括空格, tab, 换行等
    isLower
    isUpper
    isAlpha
        # 是否字母
    isAlphaNum
        # 字母或数字
    isPrint
        # 可打印
    isDigit
    isOctDigit
    isHexDigit
    isLetter
        # 同isAlpha
    isMark
        # unicode注音字符
    isNumber
    isPunctuation
        # 是否标点符号
    isSymbol
        # 货币符号
    isSeperater
        # unicode空格或分隔符
    isAscii
        # unicode 前128位
    isLatin1
        # unicode 前256位
    isAsciiUpper
    isAsciiLower
    GeneralCategory
        # 得到字符的分类，一共31类, 属于Eq类型
        generalCategory ' '
            # Space
    toUpper
    toLower
    toTitle
    digitToInt
        # 数字，大小写字母list 转成 int list
    intToDigit
    ord
    char
Data.Map
    # 用avl树实现
    fromList
        # 重复键会忽略，要求key有相等性和排序性
    fromListWith
        # 重复键给函数处理
    toList
    empty
        # 返回空map
    insert
        insert 3 10 map
    insertWith
        # 已包含键时函数处理
    null
        # 检查map是否空
    size
        # 返回map的大小
    singleton
        singleton 3, 9
            # fromList [(3,9)]
    lookup
    member
        # key 是否在map中
    map
    filter
    keys
    elems
Data.Set
    # 要求元素可排序，自动排序、唯一
    # 用avl树实现
    fromList
    intersection
    difference
        # 存在于第一集合而不在第二集合的元素
    union
    null
    size
    member
    empty
    singleton
    insert
    delete
    isSubsetOf    
        # 子集
        fromList [1,2] isSubsetOf fromList [1,2]
    isProperSubsetOf
        # 真子集
    filter
    map
Data.ByteString
    # strict bytestring
    # Empty相当于[], cons相当于:
Data.ByteString.Lazy
    # 每个元素存在chunk中，每个chunk 64k，每个chunk相当于一个strict bytestring
    # cons在chunk不满的时候会新建chunk, cons'是strick版的cons, 会填充chunk
    pack
        # pack :: [Word8] -&gt; ByteString
        pack [80,81]
    unpack
    fromChunks
        # 转换strick bytestring 到lazy
    toChunks
        # lazy转strick
Data.Ratio
Control.Applicative
    Applicative
        class (Functor f) =&gt; Applicative f where
            pure :: a -&gt; fa
            (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
            f &lt;$&gt; x = fmap f x
    ZipList
        ZipList3
        ZipList7
    getZipList
    liftA2
        liftA2 f x y = f &lt;$&gt; x &lt;*&gt; y 
    sequenceA
Control.Monad
    when
        # Bool true时，返回后面的I/O action, 否则return ()
    forever
        # 不断执行后面的I/O action
        forever $ do
            putStr &quot;a&quot;
    forM
        # 同mapM, 但两个参数顺序相反
    liftM
        # monad中的fmap
    liftM2 liftM3 liftM4 liftM5
    `ap`
        # monad中的&lt;*&gt;
    join
        join :: (Monad m) =&gt; m (m a) -&gt; m a
        join mm = do
            m &lt;- mm
            m
    filterM
    foldM
Control.Monad.State
    State
        newtype State s a = State {runState :: s -&gt; (a, s)}
    get
    put
Control.Monad.Error
System.IO
    openFile
        # openFile :: FilePath -&gt; IOMode -&gt; IO Handle
        # data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
        do
        handle = openFile &quot;a.txt&quot; ReadMode
        contents &lt;- hGetContents handle
        putStr contents
        hClose handle
    withFile
        # withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
        # 处理完关掉
        withFile &quot;a.txt&quot; ReadMode (\handle -&gt; do
            contents &lt;- hGetContents handle
            putStr contents)
    readFile
        # readFile :: FilePath -&gt; IO String
        do
        contents &lt;- readFile &quot;a.txt&quot;
        putStr contents
    wirteFile
        # writeFile :: FilePath -&gt; String -&gt; IO ()
        do
        writeFile &quot;a.txt&quot; contents
    appendFile
    hSetBuffering
        # 读binary file时的buffer，默认是系统值
        # data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)
        hSetBuffering handle $ BlockBuffering (Just 2048)
    hFlush
        # 写入时自动Flush
    openTempFile
        (tempName, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot;
    hGetContents
    hClose
    hGetLine
    hPusStr
    hPutStrLn
    hGetChar
System.IO.Error
    catch
        # catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a
        toTry `catch` handler
        handler e
            | isDoesNotExistError e = 
                case ioeGetFileName e of Just path -&gt; putStrLn $ &quot;a&quot; ++ path
                    Nothing -&gt; putStrLn &quot;b&quot;
            | otherwise = ioError e
    isDoesNotExistError
    isAlreadyExistsError
    isFullError
    isEOFError
    isIllegalOperation
    isPermissionError
    isUserError
    ioeGetFileName
        # ioeGetFileName :: IOError -&gt; Maybe FilePath
    ioError
        # 丢出接到的error
System.Directory
    removeFile
        removeFile &quot;a.txt&quot;
    renameFile
        renameFile tempName &quot;a.txt&quot;
    copyFile
    doesFileExist
System.Environment
    getArgs
    getProgName
System.Random
    mkStdGen
        # mkStdGen :: Int -&gt; StdGen
    getStdGen
        # IO类型, 得到系统启动时的global generator
    newStdGen
        # 把现有的random generator分成两个新的generators, 其中一个指定成新的，返回另一个
    random
        # random :: (RandomGen g, Random a) = g -&gt; (a, g)
        random (mkStdGen 100) :: (Int, StdGen)
    randoms
        take 5 $ randoms (mkStdGen 11) :: [Int]
    randomR
        # 区间random
        randomR (1,6) (mkStdGen 2)
    randomRs
        take 10 $ randomRs ('a', 'z') (mkStdGen 3) :: [Char]
</code></pre>

<h1 id="函数-1">函数</h1>

<pre><code>o-&gt; 模式匹配
    # case的语法糖
    # 对构造子匹配，如 8 'a' : []
factorial :: (Integral a) =&gt; a -&gt; a
factorial 0 = 1
factorial n = n * factorial (n - 1)

addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

first :: (a, b, c) -&gt; a
first (x, _, _) = x

tell :: (Show a) =&gt; [a] -&gt; String
tell [] = &quot;&quot;
tell [x: []] = &quot;&quot;
tell [x:y:[]] = &quot;&quot;
tell [x:y:_] = &quot;too long, the first is &quot; ++ show x ++ &quot; and the second is &quot; ++ show y

length' :: (Num b) =&gt; [a] -&gt; b
length' [] = 0
length' (_:xs) = 1 + length' xs

capital :: String -&gt; String
capital &quot;&quot; = &quot;&quot;
capital all@(x:xs) = &quot;The first letter of &quot; ++ all ++ &quot; is &quot; ++ [x]
    # @是as模式

o-&gt; guard
bmiTell :: (RealFloat a) =&gt; a -&gt; String
bmiTell weight height
    | bmi &lt;= skinny = &quot;You're underweight&quot;
    | bmi &lt;= normal = &quot;You're supposedly normal&quot;
    | bmi &lt;= fat = &quot;You're fat&quot;
    | otherwise = &quot;You're a whale&quot;
    where bmi = weight / height ^ 2
    (skinny, normal, fat) = (18.5, 25.0, 30.0)
        # where是语法结构，不是表达式
calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]
calcBmis xs = [bmi w h | (w, h) &lt;- xs, let bmi = w / h ^ 2]

myCompare :: (Ord a) =&gt; a -&gt; a -&gt; Ordering
a `myCompare` b
    | a &gt; b = GT
    | a == b = EQ
    | otherwise = LT

o-&gt; quicksort
quicksort :: (Ord a) =&gt; [a] -&gt; [a]
quicksort [] = []
quicksort (x:xs) = 
    let smallerSorted = quicksort (filter (&lt;=x) xs)
        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]
    in smallerSorted ++ [x] ++ biggerSorted

o-&gt; curry
compareWithHundred :: (Num a, ord a) =&gt; a -&gt; Ordering
compareWithHundred = compare 100

divideByTen :: (Floating a) =&gt; a -&gt; a
divideByTen = (/10)
    # 中缀函数用括号来不完全调用
    # 但(-4)表示负4, (substract 4)来表示减4函数

o-&gt; 高阶函数
applyTwice :: (a -&gt; a) -&gt; a -&gt; a
applyTwice f x = f (f x)

o-&gt; lambda
addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a
addThree = \x -&gt; \y -&gt; \z -&gt; x + y + z

o-&gt; $ 做数据函数
map ($ 3) [(4+), (10*), (^2), sqrt]
</code></pre>

<h1 id="类型">类型</h1>

<pre><code>类型
    Int
        # 有界整数
    Integer
        # 无界整数
    Float
        # 单精度浮点数
    Double
    Bool
    Char
    Maybe
    []
    ()
    a
        # type variables
类型约束
    Eq
    # 可判断相等性的类型，可用 == 或 /= 判断
        # 只除函数
    Ord
        #可比较大小的类型, 必定是Eq
        # 只除函数
    Ordering
        # 只有GT, EQ, LT
    Show
        # 可用字符串表示的类型
        # 只除函数
    Read
        # 与Show相反
    Enum
        # 连续的类型，有后继子(successer)和前置子(predecesor), 分别通过succ函数和pred函数得到
        # 可以[1..2]构造list
        # 包含 (), Bool, Char, Ordering, Int, Integer, Float, Double
    Bounded
        # 有上限和下限
        # 如果Tuple中都属于Bounded, 那么这个Tuple属于Bounded
    Num
        # 数字特征
    Integral
        # 整数
    Floating
        # 浮点，包含Float和Double
构造类型
    data Bool = False | True deriving (Ord)
        # Bool是构造的类型, False为值构造子，值可以用:t查看其类型
        # 值构造子可以用于模式匹配
        # 这里值构造子是没有参数的，叫作nullary
        # False在True前，所以比较时True比False大
    data Point = Point Float Float deriving (Show)
        # 值构造子可以与类型同名
    data Shape = Circle Point Float | Rectangle  Point Point deriving (Show)
        # 派生自Show, 就可show值成字符串
    data Person = Person {firstName :: String
        , lastName :: String
        } deriving (Show)
            # Record Syntax, 同 Person String String,  但自动生成同名的取值函数，show显示也改变
        let p = Person {firstName=&quot;aa&quot;, lastName=&quot;bb&quot;}

        tellPerson :: Person -&gt; String
        tellPerson (Person {firstName = a, lastName = b}) = a ++ b
    newtype CharList = CharList {getCharList :: [Char]} deriving {Eq, Show}
        # newtype将现有类型包成新类型，只能定义单一值构造子，且其只能有一个字段。并将包裹和解开的成本都去掉
类型构造子
    # data声明中不能加类型约束
    data Maybe a = Nothing | Just a
    data Car a b = Car { company :: a
        , year :: b
        } deriving (Show)
    tellCar :: (Show a) =&gt; Car String a -&gt; String
类型别名
    type String = [Char]
    type AssocList k v = [(k,v)]
        # 别名类型构造子
    type IntMap = Map Int
        # 不全调用得到不全类型构造子, 同 type intMap v = Map Int v
infixr
    infixr 5 :-:
        # 定义中缀构造子, 5是优先级, :-:是符号
        # 默认left-associative

    infixr 5 .++
    (.++) :: List a -&gt; List a -&gt; List a
    Empty .++ ys = ys
    (x :-: xs) .++ ys = x :-: (xs .++ ys)
recursive data structures
    data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
typeclass
    class Eq a where
        (==) :: a -&gt; a -&gt; Bool
        (/=) :: a -&gt; a -&gt; Bool
        x == y = not (x /= y)
        x /= y = not (x == y)
            # 只需要instance一个定义就好，这个定义叫minimal complete definition
    data TrafficLight = Red | Yellow | Green
    instance Eq TrafficLight where
        Red == Red = True
        Green == Green = True
        Yellow == Yellow = True
        _ == _ = False
    instance Show TrafficLight where
        show Red = &quot;Red light&quot;
        show Yellow = &quot;Yellow light&quot;
        show Green = &quot;Green light&quot;

    class (Eq a) =&gt; Num a where
        # Num 是 Eq  的 subclass, 要是Num必是Eq

    instance (Eq m) =&gt; Eq (Maybe m) where
        Just x == Just y = x == y
        Nothing == Nothing = True
        _ == _ = False

o-&gt; Either
data Either a b = Left a | Right a deriving (Eq, Ord, Read, Show)

o-&gt; Tree
data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)

o-&gt; YesNo
class YesNo a where
    yesno :: a -&gt; Bool
instance YesNo Int where
    yesno 0 = False
    yesno _ = True

o-&gt; Functor
class Functor f where
    # map over
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
instance Functor Maybe where
    # 接收构造子而非类型
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
instance Functor (Either a) where
    # parital apply Either, Either a 是个类型构造子
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x
instance Functor ((-&gt;) r) where
    # 对函数的functor
    fmap f g = (\x -&gt; f (g x))
</code></pre>

<h1 id="命令">命令</h1>

<pre><code>ghci
    set prompt &quot;ghci&gt; &quot;
        # 设置显示的提示符
ghc
    ghc --make a.hs
runhaskell
ghc-pkg list
    # 列出已安装的软件包
</code></pre>

<h1 id="玄学">玄学</h1>

<pre><code>o-&gt;
:{
data X = X
a :: Int -&gt; Int
a x = x + 3
:}
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/hugo-blog/commit/527b54f06fb1e4192f7f9c86cfded0cda859d1b3" title='Last modified Jun 17, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Jun 17, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/hugo-blog/tree/master/content/docs/pl/haskell.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#介绍">介绍</a></li>
<li><a href="#工具">工具</a></li>
<li><a href="#单词">单词</a></li>
<li><a href="#风格">风格</a></li>
<li><a href="#注意">注意</a></li>
<li><a href="#文件扩展名">文件扩展名</a></li>
<li><a href="#内置变量">内置变量</a></li>
<li><a href="#模块">模块</a></li>
<li><a href="#命令函数">命令函数</a></li>
<li><a href="#操作符">操作符</a></li>
<li><a href="#表达式">表达式</a></li>
<li><a href="#i-o-action">I/O action</a></li>
<li><a href="#类型表示">类型表示</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#函数">函数</a></li>
<li><a href="#列表">列表</a></li>
<li><a href="#元组">元组</a></li>
<li><a href="#monad">monad</a></li>
<li><a href="#内置函数">内置函数</a></li>
<li><a href="#函数-1">函数</a></li>
<li><a href="#类型">类型</a></li>
<li><a href="#命令">命令</a></li>
<li><a href="#玄学">玄学</a></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
