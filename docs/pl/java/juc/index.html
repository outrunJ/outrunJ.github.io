<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="基础 # 并发编程三大特性 可见性(visibility) synchronized会刷新线程栈 有序性(ordering) 原子性(atomicity) CPU # PC寄存器(Program Counter Register, 存下一指令) 优化 乱序读 合并写 乱序执行(流水线) ALU 访问速度 Registers: &lt; 1ns L1 cache(核内): 1ns WC(Writer Comblining) Buffer # 合并写, 一般4个字节 L2 cache(核内): 3ns L3 cache(CPU内): 15ns memory: 80ns 局部性原理 空间 按块读取(cache line) 一次读64Bytes # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知 Java1.8注解@Contended # 保证不在同一行，需要JVM参数-XX:-RestrictContended 时间 批量读指令 内存屏障 # 不同CPU不一样 Intel sfence # save, 之前写操作必须完成 lfence # load, 之前读操作必须完成 mfence # mix(save &#43; load) lock指令 # 指令执行完之前，锁内存 lock_add CPU缓存一致性协议 # # 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁 状态 MESI Cache一致性协议 # Intel CPU，实现方式为主动监听 Modified # 一行数据在CPU Modified, 其它CPU为Invalid Exclusive # 独享，其它CPU没有 Shared # 别人也在读 Invalid # 别人改过了 MSI MOSI 缓存行 # 多数64字节 伪共享 # 缓存行内无关数据也要同步 OS # 进程 # 资源分配 线程 # 调度执行 切换(Context Switch) CPU导出原线程指令和data到cache, 再导入新线程数据 线程数 N(threads) = N(CPU) * U(CPU) * (1 &#43; W/C) # N(CPU): CPU数 # U(CPU): 期望CPU利用率, 0到1 # W/C: wait时间/compute时间, (1&#43;W/C)即运行时间/计算时间。用profiler、arthas分析 压测决定 CPU性能压榨 单进程 批处理 多进程切换 多线程进程内切换 I/O复用 协程(纤程、绿色线程)用户空间切换 JVM # 内存屏障 # LoadLoad StoreStore LoadStore StoreLoad 乱序执行(指令重排序) # 为什么 CPU快, 指令1阻塞时，指令2先执行 判断 代码不影响单线程最终一致性 例子，多线程 static int x = 0, y = 0; static int a = 0, b = 0; void main(){ for (long i = 0; i &lt; Long.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Java并发" />
<meta property="og:description" content="基础 # 并发编程三大特性 可见性(visibility) synchronized会刷新线程栈 有序性(ordering) 原子性(atomicity) CPU # PC寄存器(Program Counter Register, 存下一指令) 优化 乱序读 合并写 乱序执行(流水线) ALU 访问速度 Registers: &lt; 1ns L1 cache(核内): 1ns WC(Writer Comblining) Buffer # 合并写, 一般4个字节 L2 cache(核内): 3ns L3 cache(CPU内): 15ns memory: 80ns 局部性原理 空间 按块读取(cache line) 一次读64Bytes # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知 Java1.8注解@Contended # 保证不在同一行，需要JVM参数-XX:-RestrictContended 时间 批量读指令 内存屏障 # 不同CPU不一样 Intel sfence # save, 之前写操作必须完成 lfence # load, 之前读操作必须完成 mfence # mix(save &#43; load) lock指令 # 指令执行完之前，锁内存 lock_add CPU缓存一致性协议 # # 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁 状态 MESI Cache一致性协议 # Intel CPU，实现方式为主动监听 Modified # 一行数据在CPU Modified, 其它CPU为Invalid Exclusive # 独享，其它CPU没有 Shared # 别人也在读 Invalid # 别人改过了 MSI MOSI 缓存行 # 多数64字节 伪共享 # 缓存行内无关数据也要同步 OS # 进程 # 资源分配 线程 # 调度执行 切换(Context Switch) CPU导出原线程指令和data到cache, 再导入新线程数据 线程数 N(threads) = N(CPU) * U(CPU) * (1 &#43; W/C) # N(CPU): CPU数 # U(CPU): 期望CPU利用率, 0到1 # W/C: wait时间/compute时间, (1&#43;W/C)即运行时间/计算时间。用profiler、arthas分析 压测决定 CPU性能压榨 单进程 批处理 多进程切换 多线程进程内切换 I/O复用 协程(纤程、绿色线程)用户空间切换 JVM # 内存屏障 # LoadLoad StoreStore LoadStore StoreLoad 乱序执行(指令重排序) # 为什么 CPU快, 指令1阻塞时，指令2先执行 判断 代码不影响单线程最终一致性 例子，多线程 static int x = 0, y = 0; static int a = 0, b = 0; void main(){ for (long i = 0; i &lt; Long." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/docs/pl/java/juc/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2018-10-09T08:48:07+08:00" />
<meta property="article:modified_time" content="2021-06-18T13:03:49+08:00" />

<title>Java并发 | outrun的笔记</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css" integrity="sha256-RhgbyTN1upMgJudTs3xA5v&#43;LsWqe93DHi8xmPkV3sbo=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.a49cd50c32ea1b75896f9bb5acf1f42a5e283f6d3c5c9311850bf487538e7b99.js" integrity="sha256-pJzVDDLqG3WJb5u1rPH0Kl4oP208XJMRhQv0h1OOe5k=" crossorigin="anonymous"></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-154152836-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>outrun的笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/architect"><strong>架构</strong></a>
<ul>
<li><a href="/docs/architect/strategy"><strong><strong>战略性</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/middle_platform">中台</a></li>
<li><a href="/docs/architect/strategy/big_data">大数据</a>
<ul>
<li><a href="/docs/architect/strategy/big_data/hadoop">Hadoop</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy/ai">AI</a></li>
<li><a href="/docs/architect/strategy/iot">IoT</a></li>
</ul>
</li>
<li><a href="/docs/architect/project"><strong><strong>工程设计原则</strong></strong></a>
<ul>
<li><a href="/docs/architect/project/ddd">DDD</a></li>
</ul>
</li>
<li><a href="/docs/architect/code"><strong><strong>代码原则</strong></strong></a>
<ul>
<li><a href="/docs/architect/code/design_mode">设计模式</a></li>
<li><a href="/docs/architect/code/security">安全/协议</a></li>
</ul>
</li>
<li><a href="/docs/architect/frontend"><strong><strong>前端</strong></strong></a></li>
</ul>
</li>
<li><a href="/docs/tool"><strong>工具</strong></a>
<ul>
<li><a href="/docs/tool/linux"><strong><strong>Linux系统</strong></strong></a>
<ul>
<li><a href="/docs/tool/linux/linux_tool">Linux工具</a></li>
<li><a href="/docs/tool/linux/scene">Linux场景</a></li>
<li><a href="/docs/tool/linux/linux_program">Linux系统编程函数</a></li>
</ul>
</li>
<li><a href="/docs/tool/ops"><strong><strong>运维工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/ops/monitor">监控指标</a></li>
<li><a href="/docs/tool/ops/docker">Docker</a></li>
<li><a href="/docs/tool/ops/k8s">Kubernetes</a></li>
</ul>
</li>
<li><a href="/docs/tool/develop"><strong><strong>开发工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/develop/vim">Vim</a></li>
<li><a href="/docs/tool/develop/eclipse">Eclipse</a></li>
<li><a href="/docs/tool/develop/apple">Apple</a></li>
<li><a href="/docs/tool/develop/jetbrains">Jetbrains</a></li>
</ul>
</li>
<li><a href="/docs/tool/test"><strong><strong>测试工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/test/debug">代码调试</a></li>
</ul>
</li>
<li><a href="/docs/tool/product"><strong><strong>产品工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/product/enterprise_system">企业级系统</a></li>
<li><a href="/docs/tool/product/framework">服务与框架</a></li>
</ul>
</li>
<li><a href="/docs/tool/physics"><strong><strong>实物工具</strong></strong></a></li>
</ul>
</li>
<li><a href="/docs/middleware"><strong>中间件</strong></a>
<ul>
<li><a href="/docs/middleware/container"><strong><strong>容器</strong></strong></a>
<ul>
<li><a href="/docs/middleware/container/nginx">Nginx</a></li>
<li><a href="/docs/middleware/container/nodejs">Node.js</a></li>
</ul>
</li>
<li><a href="/docs/middleware/distributed"><strong><strong>分布式</strong></strong></a>
<ul>
<li><a href="/docs/middleware/distributed/spring_cloud">Spring Cloud</a></li>
</ul>
</li>
<li><a href="/docs/middleware/library"><strong><strong>库</strong></strong></a>
<ul>
<li><a href="/docs/middleware/library/hibernate">Hibernate</a></li>
</ul>
</li>
<li><a href="/docs/middleware/library_frontend"><strong><strong>前端库</strong></strong></a>
<ul>
<li><a href="/docs/middleware/library_frontend/jquery">JQuery</a></li>
<li><a href="/docs/middleware/library_frontend/bootstrap">Bootstrap</a></li>
<li><a href="/docs/middleware/library_frontend/angular">Angular</a></li>
<li><a href="/docs/middleware/library_frontend/react">React</a></li>
<li><a href="/docs/middleware/library_frontend/threejs">Three.js</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/db"><strong>数据库</strong></a>
<ul>
<li><a href="/docs/db/mongodb">MongoDB</a></li>
<li><a href="/docs/db/mysql">Mysql</a></li>
<li><a href="/docs/db/oracle">Oracle</a></li>
<li><a href="/docs/db/postgresql">PgSQL</a></li>
<li><a href="/docs/db/redis">Redis</a></li>
<li><a href="/docs/db/elasticsearch">Elasticsearch</a></li>
</ul>
</li>
<li><a href="/docs/pl"><strong>语言</strong></a>
<ul>
<li><a href="/docs/pl/principle">原理</a></li>
<li><a href="/docs/pl/java"><strong><strong>Java</strong></strong></a>
<ul>
<li><a href="/docs/pl/java/jvm">JVM</a></li>
<li><a href="/docs/pl/java/collection">Java Collection</a></li>
<li><a href="/docs/pl/java/juc">Java Concurrent</a></li>
<li><a href="/docs/pl/java/spring">Spring</a></li>
<li><a href="/docs/pl/java/rxjava">RxJava</a></li>
<li><a href="/docs/pl/java/javaweb">JavaWeb</a></li>
</ul>
</li>
<li><a href="/docs/pl/go">GO</a></li>
<li><a href="/docs/pl/js">JS</a></li>
<li><a href="/docs/pl/python">Python</a></li>
<li><a href="/docs/pl/haskell">Haskell</a></li>
<li><a href="/docs/pl/clojure">Clojure</a></li>
<li><a href="/docs/pl/markup_language"><strong><strong>标记语言</strong></strong></a>
<ul>
<li><a href="/docs/pl/markup_language/html">HTML</a></li>
<li><a href="/docs/pl/markup_language/css">CSS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/basic"><strong>基本功</strong></a>
<ul>
<li><a href="/docs/basic/algorithm"><strong><strong>算法</strong></strong></a>
<ul>
<li><a href="/docs/basic/algorithm/math">数学</a></li>
<li><a href="/docs/basic/algorithm/thought">思想</a></li>
<li><a href="/docs/basic/algorithm/data_structure">数据结构</a></li>
</ul>
</li>
<li><a href="/docs/basic/computer"><strong><strong>计算机</strong></strong></a>
<ul>
<li><a href="/docs/basic/computer/principle">原理</a></li>
<li><a href="/docs/basic/computer/performance">性能</a></li>
</ul>
</li>
<li><a href="/docs/basic/business"><strong><strong>业务</strong></strong></a>
<ul>
<li><a href="/docs/basic/business/trade">行业发展</a></li>
<li><a href="/docs/basic/business/function">功能</a></li>
<li><a href="/docs/basic/business/ops">运维</a></li>
<li><a href="/docs/basic/business/test">测试</a></li>
</ul>
</li>
<li><a href="/docs/basic/soft"><strong><strong>软技能</strong></strong></a>
<ul>
<li><a href="/docs/basic/soft/person">个人</a></li>
<li><a href="/docs/basic/soft/organize"><em><strong><strong>组织</strong></strong></em></a>
<ul>
<li><a href="/docs/basic/soft/organize/people">人员</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/cache"><strong>Cache</strong></a>
<ul>
<li><a href="/docs/cache/ops">运维</a></li>
<li><a href="/docs/cache/template">模板配置</a></li>
<li><a href="/docs/cache/soft_arch">软考</a></li>
</ul>
</li>
<li><a href="/docs/misc"><strong>Misc</strong></a>
<ul>
<li><a href="/docs/misc/infomation">信息</a></li>
<li><a href="/docs/misc/media">媒体</a></li>
<li><a href="/docs/misc/english">英语</a></li>
<li><a href="/docs/misc/interview">题目</a></li>
<li><a href="/docs/misc/book">书</a></li>
<li><a href="/docs/misc/about_me">关于我</a></li>
<li><a href="/docs/misc/summary">这些年我做过的技术</a></li>
</ul>
</li>
<li><a href="/posts"><strong>Posts</strong></a></li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Java并发</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a>
      <ul>
        <li><a href="#cpu">CPU</a>
          <ul>
            <li><a href="#cpu缓存一致性协议">CPU缓存一致性协议</a></li>
          </ul>
        </li>
        <li><a href="#os">OS</a></li>
        <li><a href="#jvm">JVM</a>
          <ul>
            <li><a href="#内存屏障">内存屏障</a></li>
            <li><a href="#乱序执行指令重排序">乱序执行(指令重排序)</a></li>
          </ul>
        </li>
        <li><a href="#unsafe类">Unsafe类</a></li>
      </ul>
    </li>
    <li><a href="#修饰符与锁">修饰符与锁</a>
      <ul>
        <li><a href="#概念">概念</a></li>
        <li><a href="#synchronized">synchronized</a></li>
        <li><a href="#volatile">volatile</a></li>
        <li><a href="#cas">CAS</a></li>
        <li><a href="#锁">锁</a>
          <ul>
            <li><a href="#aqs">AQS</a></li>
            <li><a href="#reentrantlock">ReentrantLock</a></li>
            <li><a href="#countdownlatch">CountDownLatch</a></li>
            <li><a href="#cyclicbarrier">CyclicBarrier</a></li>
            <li><a href="#phaser">Phaser</a></li>
            <li><a href="#readwritelock">ReadWriteLock</a></li>
            <li><a href="#stampedlock">StampedLock</a></li>
            <li><a href="#semaphore">Semaphore</a></li>
            <li><a href="#exchanger">Exchanger</a></li>
            <li><a href="#locksupport">LockSupport</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#线程及线程池">线程及线程池</a>
      <ul>
        <li><a href="#使用注意">使用注意</a></li>
        <li><a href="#类">类</a></li>
        <li><a href="#创建线程">创建线程</a></li>
        <li><a href="#线程状态">线程状态</a></li>
        <li><a href="#线程打断">线程打断</a></li>
        <li><a href="#线程间通信">线程间通信</a>
          <ul>
            <li><a href="#通知">通知</a></li>
            <li><a href="#生产消费">生产消费</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#协程">协程</a></li>
    <li><a href="#并发api">并发API</a>
      <ul>
        <li><a href="#stream">Stream</a></li>
        <li><a href="#threadlocal">ThreadLocal</a></li>
        <li><a href="#pipedstream">PipedStream</a></li>
        <li><a href="#jmh">JMH</a></li>
        <li><a href="#disruptor">Disruptor</a></li>
      </ul>
    </li>
    <li><a href="#源码分析">源码分析</a>
      <ul>
        <li><a href="#threadpoolexecutor">ThreadPoolExecutor</a></li>
        <li><a href="#forkjoinpool">ForkJoinPool</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>并发编程三大特性
    可见性(visibility)
        synchronized会刷新线程栈
    有序性(ordering)
    原子性(atomicity)
</code></pre>
<h2 id="cpu">
  CPU
  <a class="anchor" href="#cpu">#</a>
</h2>
<pre><code>PC寄存器(Program Counter Register, 存下一指令)
优化
    乱序读
    合并写
    乱序执行(流水线)
ALU
    访问速度
        Registers: &lt; 1ns
        L1 cache(核内): 1ns
        WC(Writer Comblining) Buffer    # 合并写, 一般4个字节
        L2 cache(核内): 3ns
        L3 cache(CPU内): 15ns
        memory: 80ns
局部性原理
    空间
        按块读取(cache line)
            一次读64Bytes               # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知
            Java1.8注解@Contended       # 保证不在同一行，需要JVM参数-XX:-RestrictContended
    时间
        批量读指令
内存屏障                        # 不同CPU不一样
    Intel
        sfence                      # save, 之前写操作必须完成
        lfence                      # load, 之前读操作必须完成
        mfence                      # mix(save + load)
lock指令                            # 指令执行完之前，锁内存
    lock_add
</code></pre>
<h3 id="cpu缓存一致性协议">
  CPU缓存一致性协议
  <a class="anchor" href="#cpu%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%8d%8f%e8%ae%ae">#</a>
</h3>
<pre><code># 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁
状态
    MESI Cache一致性协议                    # Intel CPU，实现方式为主动监听
        Modified                            # 一行数据在CPU Modified, 其它CPU为Invalid
        Exclusive                           # 独享，其它CPU没有
        Shared                              # 别人也在读
        Invalid                             # 别人改过了
    MSI
    MOSI
缓存行                                      # 多数64字节
    伪共享                                  # 缓存行内无关数据也要同步
</code></pre>
<h2 id="os">
  OS
  <a class="anchor" href="#os">#</a>
</h2>
<pre><code>进程
    # 资源分配
线程
    # 调度执行
    切换(Context Switch)
        CPU导出原线程指令和data到cache, 再导入新线程数据
    线程数
        N(threads) = N(CPU) * U(CPU) * (1 + W/C)
            # N(CPU): CPU数
            # U(CPU): 期望CPU利用率, 0到1
            # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析
        压测决定
CPU性能压榨
    单进程
    批处理
    多进程切换
    多线程进程内切换
        I/O复用
    协程(纤程、绿色线程)用户空间切换
</code></pre>
<h2 id="jvm">
  JVM
  <a class="anchor" href="#jvm">#</a>
</h2>
<h3 id="内存屏障">
  内存屏障
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c">#</a>
</h3>
<pre><code>LoadLoad
StoreStore
LoadStore
StoreLoad
</code></pre>
<h3 id="乱序执行指令重排序">
  乱序执行(指令重排序)
  <a class="anchor" href="#%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f">#</a>
</h3>
<pre><code>为什么
    CPU快, 指令1阻塞时，指令2先执行
判断
    代码不影响单线程最终一致性
例子，多线程
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> y <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> b <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++&gt;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                x<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                y<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                a<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                b<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                CountDownLatch latch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CountDownLatch<span style="color:#f92672">(</span>2<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Thread one <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                        a <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                        x <span style="color:#f92672">=</span> b<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                        latch<span style="color:#f92672">.</span><span style="color:#a6e22e">countDown</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                Thread other <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                        b <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                        y <span style="color:#f92672">=</span> a<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                        latch<span style="color:#f92672">.</span><span style="color:#a6e22e">countDown</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>                one<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                other<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                latch<span style="color:#f92672">.</span><span style="color:#a6e22e">await</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span></code></pre></div><pre><code>例子，类初始化指令换顺序
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> 8<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        T t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        汇编码
</span></span><span style="display:flex;"><span>            0 <span style="color:#66d9ef">new</span> <span style="color:#960050;background-color:#1e0010">#</span>2 <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">#</span> 变量半初始化状态为0
</span></span><span style="display:flex;"><span>            3 dup
</span></span><span style="display:flex;"><span>            4 invokespecial <span style="color:#960050;background-color:#1e0010">#</span>3 <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">.&lt;</span>init<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>            7 astore_1
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">#</span> 4<span style="color:#f92672">,</span>7乱序执行<span style="color:#f92672">,</span> 先建立了关联再初始化<span style="color:#f92672">,</span> 变量中间状态值为0<span style="color:#960050;background-color:#1e0010">。</span>线程访问时中间状态逸出
</span></span><span style="display:flex;"><span>            8 <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">C</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">num</span><span style="color:#f92672">)).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> C<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="unsafe类">
  Unsafe类
  <a class="anchor" href="#unsafe%e7%b1%bb">#</a>
</h2>
<pre><code># 相当于指针。1.8只能根部类用, 11可以直接用
操作内存
    allocateMemory
    putXX
    freeMemory
    pageSize
生成类实例
    allocateInstance
操作类或实例
    objectFieldOffset
    getInt
    getObject
CAS
    compareAndSwapObject()          # JDK1.8
    compareAndSetObject()
    weakCompareAndSetObject()       # JDK11
</code></pre>
<h1 id="修饰符与锁">
  修饰符与锁
  <a class="anchor" href="#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e4%b8%8e%e9%94%81">#</a>
</h1>
<h2 id="概念">
  概念
  <a class="anchor" href="#%e6%a6%82%e5%bf%b5">#</a>
</h2>
<pre><code>锁细化                              # 少代码加轻量锁
锁粗化                              # 锁太多时，如行锁变表锁
</code></pre>
<h2 id="synchronized">
  synchronized
  <a class="anchor" href="#synchronized">#</a>
</h2>
<pre><code>实现方式
    JVM没要求实现方式
    早期都是OS调度
    HotSpot
        在对象头(64位)上用2位实现，组合成锁的类型
        锁升级                      # 不比原子类慢，升完不降
            偏向锁, 第一个线程第一次访问只记线程id
            自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平
            重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景
原子性、可见性
可重入                              # 同一个对象同线程可重入
加锁对象
    方法锁和对象锁锁this
    static方法锁和类锁锁class类
    继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象
使用注意
    抛异常立即释放锁，但被锁数据已更新
    不能用的对象
        String常量，可能未知地方锁同一个
        Integer、Long等基本类型, 值变化会生成新对象
    synchronized的属性加final防止赋值
</code></pre>
<h2 id="volatile">
  volatile
  <a class="anchor" href="#volatile">#</a>
</h2>
<pre><code># 用synchronized性能差不多，volatile一般不用
作用
    # 没有原子性，可能写同一值
    变量在线程见可见性
        依靠CPU缓存一致性协议
    禁止指令重排序                  # 用JVM的读写屏障
        
修饰引用类型，内部属性不监控

DCL(Double Check Lock)单例volatile问题
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> C c<span style="color:#f92672">;</span>    <span style="color:#75715e">// 禁止了创建c指令重排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">C</span><span style="color:#f92672">(){}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> C <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>C<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 申请内存(半初始化状态默认0)，成员变量初始化，赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        c <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> C<span style="color:#f92672">();</span>    
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> c<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="cas">
  CAS
  <a class="anchor" href="#cas">#</a>
</h2>
<pre><code># Compare And Set/Swap, 无锁优化, 乐观锁, 自旋
# Unsafe类支持
CPU原语
    cas(V, Expected, NewValue)
        if V == E                   # 无并发值判断问题，原语上加了屏障
        V = New
        else try again or fail
Java
    AtomicInteger
        incrementAndGet()
ABA问题
    # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据
    版本号                          # Java版本号类AtomicStampedReference
LongAdder
    LongAdder每次加数字, LongAccumulator用lambda
    分段锁(CAS)。值分开放数组里, 多线程对应一个item
性能测试
    LongAdder(713) &gt; Atomic(2166) &gt; Synchronized(3129)
</code></pre>
<h2 id="锁">
  锁
  <a class="anchor" href="#%e9%94%81">#</a>
</h2>
<h3 id="aqs">
  AQS
  <a class="anchor" href="#aqs">#</a>
</h3>
<pre><code># AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种
# 实现方式: CAS，volatile, 模板方法
类图
    AbstractQueueSynchronizer
        Sync
            NonfairSync
方法
    AbstractQueueSynchronizer
        # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待)
        Node
            volatile Node prev
            volatile Node next
            volatile Thread thread
        VarHandle
            # JDK1.9，保存引用，普通属性原子操作。
            # 相比反射，直接操作二进制码
            get()
            set()
            compareAndSet()         # 原子性
            getAndAdd()             # 原子性
            class C {
                int x = 0;
                private static VarHandle handle;
                static {
                    handle = MethodHandles.lookup().findVarHandle(C.class, &quot;x&quot;, int.class)
                    handle.compareAndSet(c, 0, 1);

                }
            }
        volatile state              # 多态实现
        acquire()
        tryAcquire()                # 模板方法
        acquireQueued()             # 获得
        addWaiter(Node.EXCLUSIVE)   # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表)
        cancelAcquire()             # status CANCELLED, tail时设置null, 非tail时unpark下一节点
    NonfairSync
        nonfairTryAcquire()
</code></pre>
<h3 id="reentrantlock">
  ReentrantLock
  <a class="anchor" href="#reentrantlock">#</a>
</h3>
<pre><code>    # 可重入锁，CAS实现, state记重入多少次
    new ReentrantLock(true)         # 公平锁
    tryLock(long, TimeUnit)
    lockInterruptibly()             # 响应interrupt()标记
    newCondition()                  # 多一个等待队列

    源码
        调NonfairSync
</code></pre>
<h3 id="countdownlatch">
  CountDownLatch
  <a class="anchor" href="#countdownlatch">#</a>
</h3>
<pre><code>    # 比join()灵活
    new CountDownLatch(4)
    countDown()
    await()
</code></pre>
<h3 id="cyclicbarrier">
  CyclicBarrier
  <a class="anchor" href="#cyclicbarrier">#</a>
</h3>
<pre><code>    # 满了一起放行, 场景如I/O批量消费
    new CyclicBarrier(4, ()-&gt;{})
    await()
</code></pre>
<h3 id="phaser">
  Phaser
  <a class="anchor" href="#phaser">#</a>
</h3>
<pre><code>    # 阶段批量执行过滤
    class MyPhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch(phase) {
                case 0:
                    print(&quot;arrived&quot; + registeredParties);
                    return false;
                case 1:
                    print(&quot;eated&quot; + registeredParties);
                    return false;
                case 2:
                    print(&quot;hugged&quot; + registeredParties);
                    return true;
                default:
                    return true;
            }
        }
    }
    Person implements Runnable {
        private int i;
        public Person(int i) {
            this.i = i;
        }
        public void arrive() {
            phaser.arriveAndAwaitAdvance();
        }
        public void eat() {
            phaser.arriveAndAwaitAdvance();
        }
        public void hug() {
            if (i == 0 || i == 1) {
                phaser.arriveAndAwaitAdvance();
            } else {
                phaser.arriveAndDeregister();
            }
        }

        @Override
        public void run() {
            arrive();
            eat();
            hug();
        }
    }
    phaser = new MyPhaser();
    phaser.bulkRegister(5);
    for (int i = 0; i &lt; 5; i++) {
        new Thread(new Person(i)).start()
    }
</code></pre>
<h3 id="readwritelock">
  ReadWriteLock
  <a class="anchor" href="#readwritelock">#</a>
</h3>
<pre><code>    # 读锁是共享锁，不能写，悲观锁
    # 写锁是排他锁，不能读写
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    void read(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    void write(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    for (int i =0; i&lt;10;i++) {
        new Thread(()-&gt;read(readLock)).start();
    }
    for (int i =0; i&lt;2; i++) {
        new Thread(()-&gt;write(writeLock)).start();
    }
</code></pre>
<h3 id="stampedlock">
  StampedLock
  <a class="anchor" href="#stampedlock">#</a>
</h3>
<pre><code>    # 读时允许写，读完判断不一致再读一遍，乐观锁
</code></pre>
<h3 id="semaphore">
  Semaphore
  <a class="anchor" href="#semaphore">#</a>
</h3>
<pre><code>    # 信号量, 限流同时运行, 用于线程间同步。可设置公平
    Semaphore s = new Semaphore(1, true)
    new Thread(() -&gt; {
        s.acquire();
        s.release()
    })
</code></pre>
<h3 id="exchanger">
  Exchanger
  <a class="anchor" href="#exchanger">#</a>
</h3>
<pre><code>    # 线程间通信, 阻塞交换
    exchange()
</code></pre>
<h3 id="locksupport">
  LockSupport
  <a class="anchor" href="#locksupport">#</a>
</h3>
<pre><code>    # 线程间通信，非锁阻塞，指定线程唤醒
    # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1)
    Thread t = new Thread(() -&gt; {
        for (int i = 0; i &lt; 10; i++) {
            if (i == 5) {
                LockSupport.park();
            }
        }
    })
    t.start();
    TimeUnit.SECONDS.sleep(1);
    LockSupport.unpark(t);
</code></pre>
<h1 id="线程及线程池">
  线程及线程池
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e5%8f%8a%e7%ba%bf%e7%a8%8b%e6%b1%a0">#</a>
</h1>
<h2 id="使用注意">
  使用注意
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%b3%a8%e6%84%8f">#</a>
</h2>
<pre><code>为什么不用Executors线程池
    用LinkedBlockingQueue超数量OOM
    拒绝策略
    线程命名
</code></pre>
<h2 id="类">
  类
  <a class="anchor" href="#%e7%b1%bb">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    Object
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wait</span><span style="color:#f92672">()</span>                              <span style="color:#960050;background-color:#1e0010">#</span> 释放synchronized锁并加入等待队列<span style="color:#960050;background-color:#1e0010">，</span>唤醒后执行需要得到synchronized锁
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">notify</span><span style="color:#f92672">()</span>                            <span style="color:#960050;background-color:#1e0010">#</span> 只唤醒<span style="color:#960050;background-color:#1e0010">，</span>不释放当前synchronized锁
</span></span><span style="display:flex;"><span>    Thread
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">currentThread</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">sleep</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">yield</span><span style="color:#f92672">()</span>                      <span style="color:#960050;background-color:#1e0010">#</span> 让出CPU<span style="color:#f92672">,</span> 进Ready队列
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">start</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        getState<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        join<span style="color:#f92672">()</span>                              <span style="color:#960050;background-color:#1e0010">#</span> 等待结束
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setDaemon</span><span style="color:#f92672">()</span>                         <span style="color:#960050;background-color:#1e0010">#</span> 是否后台
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setPriority</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">NORM_PRIORITY</span><span style="color:#f92672">)</span>   <span style="color:#960050;background-color:#1e0010">#</span> 优先级<span style="color:#960050;background-color:#1e0010">，</span>没有用
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Runnable</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Callable</span>
</span></span><span style="display:flex;"><span>        V <span style="color:#a6e22e">call</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Future</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">get</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        get<span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        cancel<span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        isCanceled<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        isDone<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">RunnableFuture</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FutureTask</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CompletableFuture</span>         <span style="color:#960050;background-color:#1e0010">#</span> parallel
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">allOf</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;...)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">anyOf</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;...)</span>
</span></span><span style="display:flex;"><span>            T <span style="color:#a6e22e">join</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>            CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenApply</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>            CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenAccept</span><span style="color:#f92672">(</span>Consumer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ThreadFactory</span>
</span></span><span style="display:flex;"><span>        Thread <span style="color:#a6e22e">newThread</span><span style="color:#f92672">(</span>Runnable<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DefaultThreadFactory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Executor</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ExecutorService</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">shutdown</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>            shutdownNow<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>            isShutdown<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>            isTerminated<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>            awaitTermination<span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            Future <span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;)</span>
</span></span><span style="display:flex;"><span>            Future <span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>Runnable<span style="color:#f92672">,</span> T<span style="color:#f92672">)</span>                     <span style="color:#960050;background-color:#1e0010">#</span> 手动设个result
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>Runnable<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            invokeAll<span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;)</span>
</span></span><span style="display:flex;"><span>            invokeAll<span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;,</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            invokeAny<span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;)</span>
</span></span><span style="display:flex;"><span>            invokeAny<span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;,</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">abstract</span> AbstractExecutorService
</span></span><span style="display:flex;"><span>                RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">newTaskFor</span><span style="color:#f92672">(</span>Runnable<span style="color:#f92672">,</span> T<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">newTaskFor</span><span style="color:#f92672">(</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;)</span>
</span></span><span style="display:flex;"><span>                T <span style="color:#a6e22e">doInvokeAny</span><span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;,</span> <span style="color:#66d9ef">boolean</span> timed<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                submit<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>                invokeAll<span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;)</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 忽略CancellationException<span style="color:#f92672">,</span> ExecutionException<span style="color:#960050;background-color:#1e0010">，</span>其它异常抛出并取消未完成任务
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">invokeAll</span><span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;,</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 忽略CancellationException<span style="color:#f92672">,</span> ExecutionException<span style="color:#f92672">,</span> TimeoutException<span style="color:#960050;background-color:#1e0010">，</span>其它异常抛出并取消未完成任务
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">invokeAny</span><span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;)</span>
</span></span><span style="display:flex;"><span>                invokeAny<span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;,</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutor</span>                    <span style="color:#960050;background-color:#1e0010">#</span> 线程池<span style="color:#f92672">+</span>任务队列
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 任务顺序<span style="color:#f92672">:</span> 核心线程<span style="color:#f92672">,</span> 任务队列<span style="color:#960050;background-color:#1e0010">，</span>起新线程<span style="color:#960050;background-color:#1e0010">，</span>拒绝策略
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>       <span style="color:#960050;background-color:#1e0010">#</span> 用DelayedWorkQueue
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">scheduleAtFixedRate</span><span style="color:#f92672">(()-&gt;{},</span> <span style="color:#66d9ef">int</span> initial<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> period<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForkJoinPool</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>ForkJoinTask<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ScheduledExecutorService</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">[</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CompletionService</span>                             <span style="color:#960050;background-color:#1e0010">#</span> 不阻塞全部任务<span style="color:#960050;background-color:#1e0010">，</span>已有结果入队列
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">poll</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExecutorCompletionService</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Executors</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newSingleThreadExecutor</span><span style="color:#f92672">()</span>                           <span style="color:#960050;background-color:#1e0010">#</span> 为了用任务队列和生命周期管理
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newCachedThreadPool</span><span style="color:#f92672">()</span>                               <span style="color:#960050;background-color:#1e0010">#</span> 超时60s<span style="color:#f92672">,</span> max为MAX_VALUE<span style="color:#f92672">,</span> 任务不堆积场景
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        newScheduledThreadPool<span style="color:#f92672">()</span>                            <span style="color:#960050;background-color:#1e0010">#</span> AbstractQueuedSynchronizer
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newWorkStealingPool</span><span style="color:#f92672">()</span>                               <span style="color:#960050;background-color:#1e0010">#</span> ForkJoinPool<span style="color:#f92672">,</span> go的M<span style="color:#f92672">,</span>G<span style="color:#f92672">,</span>P
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span> 每个线程单独队列<span style="color:#f92672">,</span> 尾部偷加尾部
</span></span></code></pre></div><h2 id="创建线程">
  创建线程
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b">#</a>
</h2>
<pre><code># 继承
class MyThread extendws Thread {
    @Override
    public void run(){}
}
new MyThread().start();

# 组合
class MyRun implements Runnable {
    @Override
    public void run(){}
}
new Thread(new MyRun()).start();

# 返回值
class myCall implements Callable&lt;String&gt; {
    @Override
    public String call(){}
}
FutureTask = ft = new FutureTask&lt;String&gt;(new MyCall())
new Thread(ft).start();
ft.get();

# 线程池
// execute无返回值
ExecutorService service = Executors.newCachedThreadPool()
service.execute(()-&gt;{});
// submit有返回值 
Future&lt;String&gt; f = service.submit(new MyCall());
service.shutdown();
</code></pre>
<h2 id="线程状态">
  线程状态
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81">#</a>
</h2>
<pre><code>NEW
RUNNABLE            # 可调度
    READY
    RUNNING
WAITING             # 等待唤醒，忙等待(一直占CPU)
    o.wait()
    t.join()
    LockSupport.park()
    Lock.lock()

    o.notify()
    o.notifyAll()
    LockSupport.unpark()
    Lock.unlock()
TIMED WAITING
    Thread.sleep(time)
    o.wait(time)
    t.join(time)
    LockSupport.parkNanos()
    LockSupport.parkUntil()
BLOCKING            # 阻塞等待（不占CPU但经过OS调度)
    synchronized
TERMINATED
</code></pre>
<h2 id="线程打断">
  线程打断
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%89%93%e6%96%ad">#</a>
</h2>
<pre><code>方法 
    interrupt()                 # 设置打断标记位
    isInterrupted()             # 检查标记位
    static interrupted()        # 检查当前线程标记位，并重置
检测当前线程打断标记的方法      # 抛异常并重置
    Thread.sleep()
    o.wait();
    o.join();
    ReentrantLock
        lockInterruptibly()
不检测当前线程打断标记的方法
    synchronized                # 不是代码实现检测不了
    ReentrantLock
        lock()
强制打断
    Thread
        stop()                  # 已废弃, 立即释放所有锁
        suspend()               # 已废弃，强制暂停，所有锁不释放容易死锁
        resume()                # 已废弃，强制恢复
volatile
    判断数字不准，有同步的时间延迟, interrupt()也有延迟
    也需要代码中判断, 但interrupt()有wait()等系统方法支持
</code></pre>
<h2 id="线程间通信">
  线程间通信
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1">#</a>
</h2>
<h3 id="通知">
  通知
  <a class="anchor" href="#%e9%80%9a%e7%9f%a5">#</a>
</h3>
<pre><code># synchronized wait() notify(), CountDownLatch, LockSupport
volatile List c = new ArrayList();
final Object lock = new Object();
new Thread(() -&gt; {
    synchronized(lock) {
        if (c.size() != 5) {
            lock.wait();
        }
        lock.notify();              // 唤醒t1
    }
}, &quot;t2&quot;).start();

TimeUnit.SECONDS.sleep(1);

new Thread(() -&gt; {
    synchronized(lock) {
        for (int i = 0; i &lt; 10; i++) {
            c.add(new Object());
            if (c.size() == 5) {
                lock.notify();
                lock.wait();        // 让出sychronized锁
            }
        }
    }
}, &quot;t1&quot;).start();
</code></pre>
<h3 id="生产消费">
  生产消费
  <a class="anchor" href="#%e7%94%9f%e4%ba%a7%e6%b6%88%e8%b4%b9">#</a>
</h3>
<pre><code># 优化count可以用CAS加(有ABA问题)
class MyContainer&lt;T&gt; {
    final private List&lt;T&gt; list = new LinkedList&lt;&gt;();
    final private int MAX = 10;
    private int count = 0;

    public synchronized void put(T t) {
        while(list.size() == MAX) {
            this.wait();            // 期间可能有add() 
        }
        list.add(t);
        count++;
        this.notifyAll();           // 应该只唤醒消费者
    }

    public synchronized T get() {
        T t = null;
        while(list.size() == 0) {
            this.wait();
        }
        t = list.removeFirst();
        count--;
        this.notifyAll();           // 应该只唤醒生产者
        return t;
    }
}

# 同步容器, ReentrantLock Condition
private Lock lock = new ReentrantLock();
private Condition producer = lock.newCondition();
private Condition consumer = lock.newCondition();

public void put(T t) {
    try {
        lock.lock();
        while(list.size() == MAX) {
            producer.await();
        }
        list.add(t);
        count++;
        consumer.signalAll();
    } finally {
        lock.unlock();
    }
}

public T get() {
    T t = null;
    try {
        lock.lock();
        while(list.size() == 0) {
            consumer.await();
        }
        t = list.removeFirst();
        count--;
        producer.signalAll();
    } finally {
        lock.unlock();
    }
    return t;
}
</code></pre>
<h1 id="协程">
  协程
  <a class="anchor" href="#%e5%8d%8f%e7%a8%8b">#</a>
</h1>
<pre><code>quasar库                            # 需要设javaagent, 每个fiber生成栈
    fiber =  new Fiber&lt;Void&gt;()
    fiber.start()
</code></pre>
<h1 id="并发api">
  并发API
  <a class="anchor" href="#%e5%b9%b6%e5%8f%91api">#</a>
</h1>
<h2 id="stream">
  Stream
  <a class="anchor" href="#stream">#</a>
</h2>
<pre><code>parallelStream()                    # ForkJoinPool
</code></pre>
<h2 id="threadlocal">
  ThreadLocal
  <a class="anchor" href="#threadlocal">#</a>
</h2>
<pre><code>内部类
    ThreadLocalMap&lt;ThreadLocal, Object&gt;
        # 存在每个线程里。场景如声明式事务拿conn
        # key是弱引用指向ThreadLocal, value是强引用。
    Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        Object value;
        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
方法
    set(T)
内存泄露问题
    ThreadLocal&lt;M&gt; tl = new ThreadLocal();
    tl.set(new M());
    tl = null;
        # threadLocalMap中key弱引用回收, value不回收
    tl.remove();
        # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在
</code></pre>
<h2 id="pipedstream">
  PipedStream
  <a class="anchor" href="#pipedstream">#</a>
</h2>
<pre><code># 效率不高
PipedInputStream
    connect(PipedOutputStream)
    read(byte[])
PipedOutputStream
    write(byte[])
</code></pre>
<h2 id="jmh">
  JMH
  <a class="anchor" href="#jmh">#</a>
</h2>
<pre><code># Java Microbenchmark Harness
概念
    Warmup                              # 预热
    Mesurement                          # 总执行次数
    Timeout                             # 每次执行超时时间
    Threads                             # fork线程数
    Benchmark mode                      # 模式
    Benchmark                           # 方法名
环境变量
    TEMP或TMP                           # JHM临时文件存放
使用
    @Benchmark
    @Warmup(iterations = 2, time = 3)           # 执行2次, 每次隔3秒
    @Fork(5)                                    # 多少线程
    @BenchmarkMode(Mode.Throughput)             # 显示每秒多少次
    @Measurement(iterations = 10, time = 3)     # 共测10次, 每次隔3秒
    public void testA() {

    }
</code></pre>
<h2 id="disruptor">
  Disruptor
  <a class="anchor" href="#disruptor">#</a>
</h2>
<pre><code>介绍
    CAS, 环形数组Buffer
        数组用sequence定位修改快,也避免了头尾加锁
        直接覆盖降低GC
            覆盖前有等待策略
    单机MQ
        发布订阅模式
        观察者模式
    EventFactory
        会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC
使用
    class MyEvent {}
    class MyEventFactory implements EventFactory&lt;MyEvent&gt; {
        @Override
        public MyEvent newInstance() {}
    }
    class MyEventHandler implements EventHandler&lt;MyEvent&gt; {
        @Override
        void onEvent(MyEvent, long sequence, boolean endOfBatch) {}
    }
    class MyExceptionHandler implements ExceptionHandler&lt;MyEvent&gt; {
        @Override
        void handleEventException()
        @Override
        void handleOnStartException()
        @Override
        void handleOnShutdownException()
    }
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(MyEvent::new, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory(), 
        ProducerType.SINGLE, new BlockingWaitStrategy())
        # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁
    // 消费
    disruptor.handleEventsWith(handler1, handler2)
    disruptor.handleEventsWith((event,seq,end)-&gt;{})
    disruptor.handleExceptionsFor(handler1).with(excptionHandler1)

    disruptor.start()

    // 生产
    ringBuffer = disruptor.getRingBuffer()
    sequence = ringBuffer.next()
    event = ringBuffer.get(sequence)
    event.set(&quot;&quot;)
    ringBuffer.publish(sequence)
    translator = new EventTranslator&lt;&gt;() {
        @Override
        void translateTo(event, sequence) {
            event.set(&quot;&quot;)
        }
    }
    ringBuffer.publishEvent(translator)
    ringBuffer.publishEvent((event,seq, &quot;&quot;) -&gt; event.set(l), &quot;&quot;)
等待策略
    BlockingWaitStrategy                # 阻塞直到再次唤醒
    BusySpinWaitStrategy                # 自旋等待
    SleepingWaitStrategy                # sleep等待
    LiteBlockingWaitStrategy            # 同BlockingWaitStrategy减少加锁次数                
    LiteTimeoutBlockingWaitStrategy     # 同LiteBlockingWaitStrategy加超时            
    PhasedBackoffWaitStrategy
    TimeoutBlockingWaitStrategy         # 同BlockingWaitStrategy加超时                
    YieldingWaitStrategy                # 尝试100然后Thread.yield()
</code></pre>
<h1 id="源码分析">
  源码分析
  <a class="anchor" href="#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90">#</a>
</h1>
<h2 id="threadpoolexecutor">
  ThreadPoolExecutor
  <a class="anchor" href="#threadpoolexecutor">#</a>
</h2>
<pre><code>new ThreadPoolExecutor()                    
    int corePoolSize                    # 核心线程数, 永远存活。可设置参与回收
    int maximumPoolSize                 # 最大线程数
    long keepAliveTime                  # 生存时间
    TimeUnit
    BlockingQueue&lt;Runnable&gt;             # 任务队列
    ThreadFactory                       # 线程工厂, 设线程名
    RejectedExecutionHandler            # 拒绝策略
        Abort                           # 抛异常
        Discard                         # 忽略掉
        DiscardOldest                   # 忽略掉排除最久的
        CallerRuns                      # 调用者线程执行, 再多就阻塞
AtomicInteger ctl
    # 高3位线程池状态，低29位线程数量
void execute()
    判断添加核心线程
    放入队列成功
        拒绝或添加非核心线程
    添加非核心线程失败
        拒绝
boolean addWorker(Runable, boolean)
    线程数量加1
    添加Worker
        加锁
        加线程
        启动
class Worker extends AbstractQueuedSynchronizer implements Runnable
    # 本身是AQS锁, 被多任务(线程)访问
    Tread thread
</code></pre>
<h2 id="forkjoinpool">
  ForkJoinPool
  <a class="anchor" href="#forkjoinpool">#</a>
</h2>
<pre><code>abstract class ForkJoinTask
    ForkJoinTask&lt;V&gt; fork()
    V join()
    abstract class RecursiveAction          # 无返回值
        void compute()
    abstract class RecursiveTask            # 有返回值
例子
    class MyTask extends RecursiveTask&lt;Long&gt; {
        int start;
        int end;
        @Override
        Long compute() {
            if (end - start &lt;= MAX_NUM) {
                return sum
            }
            subTask1 = new MyTask(start, mid)
            subTask2 = new MyTask(mid, end)
            subTask1.fork()
            subTask2.fork()
            return subTask1.join() + subTask2.join();
        }
    }
    fjp = new ForkJoinPool()
    task = new MyTask(0, nums.length)
    fjp .execute(task)
    result = task.join()</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/commit/1bb58a2a578f674675d9eb7e3d272d9330ca1ccd" title='Last modified by 申文庆 | Jun 18, 2021' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>Jun 18, 2021</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/tree/master/content/content/docs/pl/java/juc.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a>
      <ul>
        <li><a href="#cpu">CPU</a>
          <ul>
            <li><a href="#cpu缓存一致性协议">CPU缓存一致性协议</a></li>
          </ul>
        </li>
        <li><a href="#os">OS</a></li>
        <li><a href="#jvm">JVM</a>
          <ul>
            <li><a href="#内存屏障">内存屏障</a></li>
            <li><a href="#乱序执行指令重排序">乱序执行(指令重排序)</a></li>
          </ul>
        </li>
        <li><a href="#unsafe类">Unsafe类</a></li>
      </ul>
    </li>
    <li><a href="#修饰符与锁">修饰符与锁</a>
      <ul>
        <li><a href="#概念">概念</a></li>
        <li><a href="#synchronized">synchronized</a></li>
        <li><a href="#volatile">volatile</a></li>
        <li><a href="#cas">CAS</a></li>
        <li><a href="#锁">锁</a>
          <ul>
            <li><a href="#aqs">AQS</a></li>
            <li><a href="#reentrantlock">ReentrantLock</a></li>
            <li><a href="#countdownlatch">CountDownLatch</a></li>
            <li><a href="#cyclicbarrier">CyclicBarrier</a></li>
            <li><a href="#phaser">Phaser</a></li>
            <li><a href="#readwritelock">ReadWriteLock</a></li>
            <li><a href="#stampedlock">StampedLock</a></li>
            <li><a href="#semaphore">Semaphore</a></li>
            <li><a href="#exchanger">Exchanger</a></li>
            <li><a href="#locksupport">LockSupport</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#线程及线程池">线程及线程池</a>
      <ul>
        <li><a href="#使用注意">使用注意</a></li>
        <li><a href="#类">类</a></li>
        <li><a href="#创建线程">创建线程</a></li>
        <li><a href="#线程状态">线程状态</a></li>
        <li><a href="#线程打断">线程打断</a></li>
        <li><a href="#线程间通信">线程间通信</a>
          <ul>
            <li><a href="#通知">通知</a></li>
            <li><a href="#生产消费">生产消费</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#协程">协程</a></li>
    <li><a href="#并发api">并发API</a>
      <ul>
        <li><a href="#stream">Stream</a></li>
        <li><a href="#threadlocal">ThreadLocal</a></li>
        <li><a href="#pipedstream">PipedStream</a></li>
        <li><a href="#jmh">JMH</a></li>
        <li><a href="#disruptor">Disruptor</a></li>
      </ul>
    </li>
    <li><a href="#源码分析">源码分析</a>
      <ul>
        <li><a href="#threadpoolexecutor">ThreadPoolExecutor</a></li>
        <li><a href="#forkjoinpool">ForkJoinPool</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












