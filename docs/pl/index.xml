<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程序语言 on outrun的笔记</title>
    <link>https://example.com/docs/pl/</link>
    <description>Recent content in 程序语言 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://example.com/docs/pl/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Haskell</title>
      <link>https://example.com/docs/pl/haskell/</link>
      <pubDate>Tue, 09 Oct 2018 16:54:16 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/haskell/</guid>
      <description>介绍 源于ML 标准化的、纯函数式编程语言 非限定性语义和强静态类型 作为其他语言设计新功能时的样板，如Python的lambda标记语句  工具 检索函数用http://www.Haskell.org/hoogle  单词 polymorphism # 多态 monomorphic # 单态  风格 point free style sum&#39; xs = foldl (+) 0 xs sum&#39; = foldl (+) 0  注意 使用缩进代替括号，但也可用括号  文件扩展名 # 文件中不用let定义变量, # 变量赋值两次会报错, 这意味着代码顺序不重要 hs  内置变量 pi  模块 :m Data.Char Data.Map # 加载模块 chr # chr :: Int -&amp;gt; Char ord # ord :: Char -&amp;gt; Int toUpper toLower import Data.</description>
    </item>
    
    <item>
      <title>Css</title>
      <link>https://example.com/docs/pl/css/</link>
      <pubDate>Tue, 09 Oct 2018 16:27:24 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/css/</guid>
      <description>介绍 cascading style sheet  层叠 # 浏览器对每个元素定义了默认的样式表 不同级 1. style属性 2. style标签 3. link标签 4. 浏览器中用户自定义样式表 5. 浏览器默认样式 !important color: black !important 同级 # 评估得出最特殊的样式 ## a-b-c值依次排序，a如id个数, b如其他属性个数, c如元素名个数 # 评分相同时，使用最后的 id值的数目 其它属性和伪类的数目 元素名和伪元素的数目  继承 部分元素继承父元素样式 元素外观继承 布局不继承 inherit # 指明使用父元素样式 border: inherit  css样式一共三种用法: 内联式 &amp;lt;div style=&amp;quot;color:#000;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 嵌入式 &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt; div {color:#000;} &amp;lt;/style&amp;gt; 引用式 &amp;lt;link href=&amp;quot;css.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt; @ @charset &amp;quot;UTF-8&amp;quot; # 默认UTF-8, 在import前 @import &amp;quot;styles.</description>
    </item>
    
    <item>
      <title>Elixir</title>
      <link>https://example.com/docs/pl/elixir/</link>
      <pubDate>Tue, 09 Oct 2018 16:24:04 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/elixir/</guid>
      <description>介绍 跑在erlang虚拟机上 与erlang相同，actor称作进程, 是比线程更轻量的概念  使用 o-&amp;gt; 元组 {:foo, &amp;quot;this&amp;quot;, 42} # 三元组 o-&amp;gt; actor defmodule Talker do def loop do receive do {:greet, name, age} -&amp;gt; IO.puts(&amp;quot;Hello #{name}&amp;quot;) {:shutdown} -&amp;gt; exit(:normal) end loop end end pid = spawn(&amp;amp;Talker.loop/0) send(pid, {:greet, &amp;quot;Huey&amp;quot;, 16}) sleep(1000) Process.flag(:trap_exit, true) pid = spawn_link(&amp;amp;Takler.loop/0) send(pid, {:shutdown}) receive do {:EXIT, ^pid, reason} -&amp;gt; IO.puts(&amp;quot;Talker has exited (#{reason})&amp;quot;) end o-&amp;gt; 有状态的actor # 递归 defmodule Counter do def start(count) do spawn(__MODULE__, :loop, [count]) # 伪变量__MODULE__, 是当前模块的名字 end def next(counter) do send(counter, {:next}) end def loop(count) do receive do {:next} -&amp;gt; IO.</description>
    </item>
    
    <item>
      <title>Go</title>
      <link>https://example.com/docs/pl/go/</link>
      <pubDate>Tue, 09 Oct 2018 16:10:44 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/go/</guid>
      <description>基础 特点 易工程化 简单性而不方便性，避免工程复杂性乘法增长 没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储 类型系统，无类型风格 集合直接持有元素 # 自然方式 标准库避免配置和解释 # 自带电池 项目结构简单 编译为本地机器码 编译快 强静态类型 有gc 大厂支持 并发编程特点 语言层面关键字 csp并发模型 channel为一等公民 高效调度模型(调度器，资源占用小) O(1)的调度 一进程可支撑上百万例程,5kib/goroutine的开销, 变长栈存goroutine 编译 CGO_ENABLED=0 # 静态链接，不跨平台 配置 GOROOT # go安装目录 GOPATH # 包目录 # 默认要有go的bin目录 GOBIN # 当前bin目录 GO15VENDOREXPERIMENT # 依赖目录 例程原理 流程控制: csp 通信方式: promise-future, channel, event  命令 godoc -http=:6060 # 运行本地帮助网站 go build # 编译代码包 install # 编译安装 get # 下载依赖 # 默认目录是GOPATH下的pkg -u # update -v # 查看进度 clean # 清理build产生的文件 -c # 清理.</description>
    </item>
    
    <item>
      <title>Python</title>
      <link>https://example.com/docs/pl/python/</link>
      <pubDate>Tue, 09 Oct 2018 16:05:05 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/python/</guid>
      <description>介绍 虚拟机语言 虽然是脚本语言，可以预编译成pyc文件来执行  shell #! /usr/bin/python # -*- coding: utf8 -*-  语法 规范 pep8  内置函数 o-&amp;gt; input(&amp;quot;&amp;quot;) # x = int(input(&amp;quot;Please enter an integer:&amp;quot;)) print(&amp;quot;%s&amp;quot;, % s1) ## %.3s % (&amp;quot;abcdef&amp;quot;)取3字符 ## %.* s % (2, &amp;quot;abcd&amp;quot;)取2字符) # %r repr()显示字符串 # %c 单个字符 # %b 二进制整数 # %x 十六进制整数 # %d 十进制整数 # %i 十进制整数 # %o 八进制整数 # %e %E 指数(基底分别为e E) # %-10.3f %-10.3F 浮点数 ## 10位宽, 小数精确3位, 右对齐 # %g %G 指数(e E)或浮点数(根据显示长度决定) # %% 字符% print(&amp;quot;c is %s, e is %i&amp;quot; % (c, e) str(1) int(&amp;quot;1&amp;quot;) range(1, 10) # range(-2, -11, -3) exec(&#39;&#39;) # 执行字符串中的代码 execfile(r&#39;a.</description>
    </item>
    
    <item>
      <title>Clojure</title>
      <link>https://example.com/docs/pl/clojure/</link>
      <pubDate>Tue, 09 Oct 2018 16:00:21 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/clojure/</guid>
      <description>介绍  是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程 操作符知道自己的特征值(identity value), 如+是0, *是1 数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃 集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能 # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的 没有尾递归优化，不常用递归，要用loop.recur  语法  s-expressions (max 3 5) (+ 1 (* 2 3)) (def meaning-of-life 42) (if (&amp;lt; meaning-of-life 0) &amp;quot;negative&amp;quot; &amp;quot;non-negative&amp;quot;) (def droids [&amp;quot;Huey&amp;quot; &amp;quot;Dewey&amp;quot; &amp;quot;Louie&amp;quot;]) (count droids) (droids 0) (def me {:name &amp;quot;Paul&amp;quot; :age 45 :sex :male}) (:age me) (defn percentage [x p] (* x (/ p 100.0))) (percentage 200 10)  并发 o-&amp;gt; 原子变量 # 对一个值进行同步更新 (def my-atom (atom 42)) (deref my-atom) @my-atom (swap!</description>
    </item>
    
    <item>
      <title>JS</title>
      <link>https://example.com/docs/pl/js/</link>
      <pubDate>Tue, 09 Oct 2018 10:31:30 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/js/</guid>
      <description>基础 特性 面向对象 动态语言(已超出脚本语言的范畴) first-class function的思想来自Scheme语言 prototype-based的思想来自Self语言 机制 弱类型，变量都是var 解释器有自己的内存管理机制(garbage collection) 自由数据类型转换 # 产生了==, ===的判断相等的不同定义 commonJs规范下的javascript node.js mongoDB ringojs v8引擎 直接生成机器码 分代式GC java jvm工程师参数了优化  词法 js是unicode字符集编写的 # unicode转义如, &#39;café&#39;表示为 &#39;caf\u00e9&#39; ## &#39;é&#39; 也可以表示为&#39;e\u0301&#39;, e后面跟一个语调符 区分大小写 # html中不区分大小写, 其要调用的函数在js中一律小写 注释如//, /**/ 标识符和保留字 要求 开头以字母、下划线、dollar符。 后续可以加数字 可以出现unicode字符集中的Mn类、Mc类、Pc类，如 # Mn表示非间距字符，Mc表示影响基字符标志位的间距字符, Pc是连接两个字符的连接符或标点符号。 é, π, 保留字 break, delete, function, return, typeof, case, do, if, switch, var, catch, else, in, this, void, continue, false, instanceof, throw, while, debugger, finally, new, true, with, default, for, null, try 未被使用的名保留字 class, const, enum, export, extends, import, super 严格模式下的保留字 implements, let, private, public, yield, interface, package, protected, static 严格模式下不能用做变量名 arguments, eval es6新增保留字 await ECMAScript3将所有java关键字列为保留字 全局属性和对象和函数 自定义全局对象和函数列表  直接量 直接量(numeric literal) 1 1.</description>
    </item>
    
    <item>
      <title>Java</title>
      <link>https://example.com/docs/pl/java/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/pl/java/</guid>
      <description>命令与工具 bin目录 javac # 编译器 java # 解释器 javadoc # 生成HTML格式的帮助文档 javadoc -d docs -sourcepath src/ -subpackages com.ryx -author jdb # java调试器 javah # 反编译成c头文件 javap # 反编译成java文件 jar # 打包工具 打包标签 把包目录和class类放到jnb目录 jnb/META-INF/tld文件添加&amp;lt;uri&amp;gt;http:# www.xxx.com&amp;lt;/uri&amp;gt; jar cvf jnb.jar * jar cvfm ul.jar manifest.mf com native2ascii # 转换为unicode编码 serialver # 返回指定类的序列化号serialverUID appletviewer # 小程序浏览器，执行HTML文件上java小程序类 htmlconverter # 转换applet tags成java plug-in javap # 反编译 jad # 反编译 jad -o -a d.java Xxx.class jmap # 查看堆内存情况, 产生dump文件 工具 MAT (Memory Analyzer) # eclipse MAT插件分析dump文件  语法 基础 面向对象 继承 封装 多态 overload 编译时多态 override 运行时多态 抽象 对象关系 has-a # 关联 use-a # 依赖 is-a # 继承 类型 基本类型 # 作为面向对象语言，为了方便引入了基本类型 boolean 1或4字节 # 没有定义类型的字节码，跟据jvm实现有时用int代替 # 据说[]boolean是1个，boolean直接用int类型是4个 byte 1个字节 short 2个字节 char 2个字节 # gbk, gb2312这种2字节编码，一个汉字存一个char。utf-8一个字用3字节 int 4个字节 long 8个字节 float 4个字节 double 8个字节 包装类型 # 不可变(immutable)类 Boolean, Byte, Short, Character, Integer, Long, Float, Double 享元 Integer i1 = 120, i2 = 120, i3 = 130, i4 = 130; i1 == i2; i3 !</description>
    </item>
    
  </channel>
</rss>