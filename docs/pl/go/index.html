<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Go
  
 | outrun的笔记</title>



<link rel="stylesheet" href="/book.min.1a0250256273fabf0f848ed9a3c50aae344d758339cad9725e656ac71546e6f5.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://example.com/">outrun的笔记</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fpl\2fgo\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/algorithm"><strong>算法</strong></a>

<ul>
<li><a href="/docs/algorithm/math">数学</a></li>
<li><a href="/docs/algorithm/thought">思想</a></li>
<li><a href="/docs/algorithm/data_structure">数据结构</a></li>
</ul></li>
<li><a href="/docs/design"><strong>设计</strong></a>

<ul>
<li><a href="/docs/design/code">代码</a></li>
<li><a href="/docs/design/project">项目</a></li>
</ul></li>
<li><a href="/docs/pl"><strong>程序语言</strong></a>

<ul>
<li><a href="/docs/pl/go">go</a></li>
<li><a href="/docs/pl/js">js</a></li>
<li><a href="/docs/pl/java">java</a></li>
<li><a href="/docs/pl/python">python</a></li>
<li><a href="/docs/pl/haskell">haskell</a></li>
<li><a href="/docs/pl/clojure">clojure</a></li>
<li><a href="/docs/pl/css">css</a></li>
<li><a href="/docs/pl/markup_language"><strong><em>标记语言</em></strong></a>

<ul>
<li><a href="/docs/pl/markup_language/html">html</a></li>
</ul></li>
</ul></li>
<li><a href="/docs/architecture"><strong>架构</strong></a>

<ul>
<li><a href="/docs/architecture/principle">原理</a></li>
<li><a href="/docs/architecture/performance">性能</a></li>
<li><a href="/docs/architecture/solution">方案</a></li>
<li><a href="/docs/architecture/nodejs">nodejs</a></li>
</ul></li>
<li><a href="/docs/backend"><strong>后端</strong></a>

<ul>
<li><a href="/docs/backend/principle">原理</a></li>
<li><a href="/docs/backend/elasticsearch">elasticsearch</a></li>
<li><a href="/docs/backend/javaweb">javaweb</a></li>
<li><a href="/docs/backend/spring">spring</a></li>
<li><a href="/docs/backend/hibernate">hibernate</a></li>
</ul></li>
<li><a href="/docs/db"><strong>数据库</strong></a>

<ul>
<li><a href="/docs/db/mongodb">mongodb</a></li>
<li><a href="/docs/db/mysql">mysql</a></li>
<li><a href="/docs/db/oracle">oracle</a></li>
<li><a href="/docs/db/postgre_sql">pgsql</a></li>
<li><a href="/docs/db/redis">redis</a></li>
</ul></li>
<li><a href="/docs/frontend"><strong>前端</strong></a>

<ul>
<li><a href="/docs/frontend/jquery">jquery</a></li>
<li><a href="/docs/frontend/bootstrap">bootstrap</a></li>
<li><a href="/docs/frontend/angular">angular</a></li>
<li><a href="/docs/frontend/react">react</a></li>
<li><a href="/docs/frontend/threejs">three.js</a></li>
</ul></li>
<li><a href="/docs/ops"><strong>运维</strong></a>

<ul>
<li><a href="/docs/ops/linux">linux</a></li>
<li><a href="/docs/ops/linux_tool">linux工具</a></li>
<li><a href="/docs/ops/docker">docker</a></li>
</ul></li>
<li><a href="/docs/test"><strong>测试</strong></a></li>
<li><a href="/docs/tool"><strong>图形工具</strong></a>

<ul>
<li><a href="/docs/tool/vim">vim</a></li>
<li><a href="/docs/tool/eclipse">eclipse</a></li>
</ul></li>
<li><a href="/docs/management">管理</a></li>
<li><a href="/docs/media">媒体</a></li>
<li><a href="/docs/english">英语</a></li>
<li><a href="/docs/interview">题目</a></li>
<li><a href="/docs/infomation">信息</a></li>
<li><a href="/posts"><strong>博客</strong></a></li>
<li><a href="/about_me">关于我</a></li>
<li><a href="/register">&ldquo;寄存器&rdquo;</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Go
  
</strong>
</header>

      
<article class="markdown">

<h1 id="基础">基础</h1>

<pre><code>特点
    易工程化
        简单性而不方便性，避免工程复杂性乘法增长
            没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储
        类型系统，无类型风格
        集合直接持有元素    # 自然方式
        标准库避免配置和解释     # 自带电池
        项目结构简单
    编译为本地机器码
        编译快
    强静态类型
    有gc
    大厂支持
并发编程特点
    语言层面关键字
    csp并发模型
        channel为一等公民
    高效调度模型(调度器，资源占用小)
        O(1)的调度
        一进程可支撑上百万例程,5kib/goroutine的开销,
            变长栈存goroutine
编译
    CGO_ENABLED=0
        # 静态链接，不跨平台
配置
    GOROOT
        # go安装目录
    GOPATH
        # 包目录
        # 默认要有go的bin目录
    GOBIN
        # 当前bin目录
    GO15VENDOREXPERIMENT
        # 依赖目录
例程原理
    流程控制: csp
    通信方式: promise-future, channel, event
</code></pre>

<h1 id="命令">命令</h1>

<pre><code>godoc
    -http=:6060
        # 运行本地帮助网站
go
    build
        # 编译代码包
    install
        # 编译安装
    get
        # 下载依赖
        # 默认目录是GOPATH下的pkg
        -u
            # update
        -v
            # 查看进度
    clean
        # 清理build产生的文件
        -c
            # 清理.test文件
        -i
            # 清理生成的可执行文件
        -r
            # 包括依赖包的结果文件
    run
        # 编译并运行
    list
        # 列出指定代码包的信息
    fix
        # 升级旧代码成新版本代码
    vet
        # 检查静态错误
    test
        # go test -cover -args -config config_it.toml -test.run &quot;TestA&quot;
        # 执行当前目录下所有_test.go结尾的文件
        -file
            # 可省略，测试单个文件, 如go test test_a.go a.go a.pb.go
            ## 测试单个文件需要引入原文件
        -args
            # 运行时参数
        -run TestFoo
            # 测单个方法，名字正则匹配，如^TestFoo
        -test.run &quot;TestCreate&quot;
            # 同上
        -v
            # 也显示非错误信息
        -bench=&quot;.*&quot;
            # 指定运行的用例
        --cpuprofile=cpu.prof
            # 生成cpu分析文件
        --memprofile=mem.prof
            # 生成内存分析文件
        -c
            # 生成可执行的二进制文件，名为x.test，它用来生成状态图
        -cover
            # 显示覆盖率
    tool
        pprof
            # 交互式访问概要文件
            module1.test cpu.prof
                # 用性能测试生成cpu状态图
        fix
            # 同go fix
        vet
            # 同go vet
        cgo
            # 生成能够调用c语言代码的go源码文件
    doc
    env
        # 打印go环境信息
</code></pre>

<h1 id="语法">语法</h1>

<pre><code>min, max := 0, 100
    # 自动引申变量类型
var s string
</code></pre>

<h2 id="内置关键字">内置关键字</h2>

<pre><code>defer fn
go fn
</code></pre>

<h2 id="包函数">包函数</h2>

<pre><code>init
main
</code></pre>

<h2 id="内置">内置</h2>

<pre><code>常量
    true
    false
函数
    append
    cap
    close
        # channel中用
    complex
    copy
    delete
    imag
    len
    make
    new
    panic
    real
    recover
类型
    ComplexType
    FloatType
    IntegerType
    Type
    Type1
    bool
    byte
    complex128
    complex64
    error
    float32
    float64
    int
    int16
    int32
    int64
    int8
    rune
        # int32别名
    string
    uint
    uint16
    uint32
    uint64
    uint8
    uintptr
</code></pre>

<h2 id="异常">异常</h2>

<pre><code>func Try(fn func(), handler func(interface{})) {
    defer func() {
        if err := recover(); err != nil {
            handler(err)
        }
    }()
    fn()
}

func main() {
    Try(func() {
        panic(&quot;a&quot;)
    }, func(e interface{}) {
        print(e)
    })
}
</code></pre>

<h1 id="包">包</h1>

<pre><code>fmt
bytes
net
    http
    poolServer(epoll/kqueue/iocp)
        # 支持多核大量并发连接fd
time
template
regexp
gob
json
errors
    New
flag
testing
log
reflect
encoding/gob
</code></pre>

<h1 id="测试">测试</h1>

<pre><code>规则
    文件名以_test.go结尾
    函数以Test开头
    benchmark测试函数以Benchmark开头
</code></pre>

<h1 id="并发编程">并发编程</h1>

<pre><code>同步
    func
    channel
        缓冲区
            c := make(chan struct{})
            c1 := make(chan struct{}, 1)
            c ← struct{}{}  # 阻塞
            ← c             # 阻塞

            c1 ← struct{}{}     # 不阻塞
            c1 ← struct{}{}     # 阻塞
            ← c1                # 不阻塞
            ← c1                # 阻塞
        方向
            var c chan struct{}         # in和out
            var cin chan&lt;- struct{}     # in
            var cout &lt;-chan struct{}    # out

            cin = c
            cout = c
            c = cin                     # 编译错误
            c = cout                    # 编译错误
        nil
            var c chan struct{}
            c &lt;- struct{}{}         # 阻塞
        关闭
            c := make(chan struct{})
            close(c)
            c ← struct{}{}          # panic
            o, ok := ← c            # o得到零值, ok是false
    for range
        c := make(chan struct{})
        ...
        for x := range c {}         # close(c)时break
    select
        # channel用select, 值用switch
        # select中不能用fallthrough
        c := make(chan struct{},2)
        label1:
        for {
            select {
                case c&lt;- struct{}{}:
                    fmt.Println(1)
                case &lt;-c:
                    fmt.Println(2)
                    break         # 无标签break跳出当前select块
                        # break label
                        # goto label2
                        # return
                default:
                    fmt.Println(3)
            }
        }
        label2:
        ...
    sync包
        Mutex
        RWMutex
        Once
        WaitGroup
        Cond
            Wait()      # 计数加1, 进入阻塞
            Signal()    # 解除一个阻塞，计数减1
            Broadcast() # 解除所有阻塞
        Map
        Pool
    sync/atomic包


    o-&gt; 并发三个业务, 一起结束
    cond := sync.NewCond(new(sync.Mutex))
    wg := sync.WaitGroup{}
    wg.Add(3)
    wg1 := sync.WaitGroup{}
    wg1.Add(3)
    for i := 0; i &lt; 3; i++ {
        go func(i int) {
            defer wg1.Done()
            cond.L.Lock()
            fmt.Println(&quot;wait&quot;, i)      # 业务预处理
            wg.Done()
            cond.Wait()                 # 阻塞
            fmt.Println(&quot;done&quot;, i)      # 业务后续处理(要求所有业务预处理过)
            cond.L.Unlock()
        }(i)
    }
    wg.Wait()           # 业务预处理完成

    cond.L.Lock()
    cond.Broadcast()    # 处理业务后续
    cond.L.Unlock()
    wg1.Wait()          # goroutine完成
异步
    deadlock    # 指没有可调度的goroutine
        所有goroutine阻塞
        没有goroutine
    goroutine
        无id
        不能中断
        无返回值
    runtime
        Gosched         # 让出执行权
        Goexit          # 终止当前goroutine, 会执行defer
        LockOSThread    # 绑定协程到当前线程
        UnlockOSThread
        GOMAXPROCS      # 并发线程数
        NumGoroutine    # 限制goroutine数
    context
        # 线程安全, 树形结构
        context
            Cancel
            Deadline(Timeout)
            Value
            TODO

            o-&gt; ctx.Done()
            func f(ctx context.Context) (error) {
                errc := make(chan error, 1)

                go func() {
                    defer close(errc)
                    time.Sleep(2 * time.Second)
                    errc &lt;- nil
                }()

                select {
                    case &lt;-ctx.Done():
                        &lt;-errc
                        return ctx.Err()
                    case err := &lt;-errc:
                        return err
                }
            }

            o-&gt; WithTimeout
            ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)     # 调cancel提前结束
            defer cancel()
            return f(ctx)
    time
        After()
        AfterFunc()
        NewTicker()
并发模式
    # 避免goroutine泄漏，保证通信顺序
    done/quit
        o-&gt; done控制goroutine退出
        func f(done &lt;-chan struct{}) {
            select {
                case &lt;-done:
                    return
            }
        }

        done := make(chan struct{})
        defer close(done)
        f(done)
    channels of channels
        o-&gt; 循环处理请求
        func handle(reqs chan chan interface{}) {
            for req := range reqs {
                req &lt;- 0
            }
        }
        func server(req chan interface{}) {
            reqs := make(chan chan interface{})
            defer close(reqs)
            go handle(reqs)
            reqs &lt;- req
        }
        func client() interface{} {
            req := make(chan interface{})
            defer close(req)
            go server(req)
            return &lt;-req
        }
        fmt.Println(client())

        o-&gt; 循环异常退出
        type S struct {
            closing chan chan error
        }
        func (s *S) close() error {
            errc := make(chan error)
            s.closing &lt;- errc
            return &lt;-errc
        }
        func (s *S) loop() {
            for {
                select {
                    case errc := &lt;-s.closing:
                        errc &lt;- nil
                        return
                }
            }
        }
    pipeline(fan-in, fan-out)   # 传入传出channel来处理
        o-&gt;
        func gen(done &lt;-chan struct{}, nums ...int) &lt;-chan int {
            out := make(chan int)
            go func() {
                defer close(out)
                for _, n := range nums {
                    select {
                        case out &lt;- n:
                        case &lt;-done:
                            return
                    }
                }
            }()
            return out
        }
        func sq(done &lt;-chan struct{}, in &lt;-chan int) &lt;-chan int {
            out := make(chan int)
            go func() {
                defer close(out)
                for n := range in {
                    select {
                        case out &lt;- n * n:
                        case &lt;-done:
                            return
                    }
                }
            }()
            return out
        }
        func merge(done &lt;-chan struct{}, cs ...&lt;-chan int) &lt;-chan int {
            # wg等cs数目个协程合并数据到out后，关闭out
            var wg sync.WaitGroup
            out := make(chan int)

            output := func(c &lt;-chan int) {
                for n := range c {
                    select {
                        case out &lt;- n:
                        case &lt;-done:
                    }
                }
                wg.Done()
            }

            wg.Add(len(cs))
            for _, c := range cs {
                go output(c)
            }

            go func() {
                wg.Wait()
                close(out)
            }()
            return out
        }

        func main() {
            done := make(chan struct{})
            defer close(done)

            for n := range sq(done, sq(done, gen(done, 2, 3))) {
                # gen产生维护数字chan, sq产生维护平方chan。三个chan
                # 三个goroutine done()时return, chan return时close()
                fmt.Println(n)
            }

            // 扇出
            in := gen(done, 2, 3)
            c1 := sq(done, in)
            c2 := sq(done, in)
            // 扇进
            for n := range merge(done, c1, c2) {
                fmt.Println(n)
            }
        }
    timeout
        select {
            case &lt;-ch:
                ...
            case &lt;-time.After(time.Second)
                return
        }
常用
    中断
        # os.Exit()程序返回错误码

        done := make(chan struct{})
        go func() {
            defer close(done)
            c := make(chan os.Signal, 1)
            defer close(c)
            signal.Notify(c, os.Interrupt, os.Kill)
            defer signal.Stop(c)
            &lt;-c
        }()
    并发压测
        func concurrent(done chan struct{}, fn func(), num int, ccu int, qps int) {     # num总数，ccu并行数，qps并发数
            interval := time.Duration(1e9/qps) * time.Nanosecond
            don := make(chan struct{}, 2)
            go func() {
                &lt;-done
                for i := 0; i &lt; ccu; i++ {
                    don &lt;- struct{}{}
                }
            }()

            //
            tasks := make(chan struct{})
            go func() {
                var wg sync.WaitGroup
                wg.Add(num)
                for i := 0; i &lt; num; i++ {
                    tasks &lt;- struct{}{}
                    wg.Done()
                    time.Sleep(interval)
                }
                wg.Wait()
                close(tasks)
            }()

            //
            var wg sync.WaitGroup
            wg.Add(ccu)
            for i := 0; i &lt; ccu; i++ {
                go func() {
                    defer wg.Done()
                    for range tasks {
                        select {
                        case &lt;-don:
                            return
                        default:
                            fn()
                        }
                    }
                }()
            }
            wg.Wait()
        }
        m := sync.Mutex{}
        count := 0
        do := func(){
            m.Lock()
            count++
            m.Unlock()
        }
        concurrent(done, do, 999, 100, 1e3)
</code></pre>

<h1 id="工具">工具</h1>

<h2 id="glide">glide</h2>

<pre><code>介绍
    包管理
目录
    glide.yaml
    glide.lock
    main.go
    subpackages
    vendor
命令
    glide
        init
            # 扫描代码目录，创建glide.yaml文件，记录所有依赖
            删除glide.yaml中自己项目本身
        get
            # 安装并更新glide.yaml
            --all-dependencies -s -v github.com/go-redis/redis#5.0.0
                # --all-dependencies会更新subpackages
        update
            # 下载和更新glide.yaml中的所有依赖，放到vendor下
            # 递归更新
        install
            # 依据glide.lock与glide.yaml文件安装特定版本
            # glide.lock与glide.yaml不同步时，发出警告
        up
            # 更新依赖树，重建glide.lock文件
        name
            # 查看glide.yaml中依赖名称
        list
            # 依赖列表
        help
        --version
glide.yaml
    package: .
    import:
    - package: github.com/go-redis/redis
    version: 5.0.0
    repo:git@github.com:go-redis/redis
常见问题
    vcs
        glide mirror set a a --vcs git
            # 改~/.glide/mirrors.yaml文件
</code></pre>

<h2 id="govendor">govendor</h2>

<pre><code>介绍
    包管理
使用
    go get -u -v github.com/kardianos/govendor
</code></pre>

<h2 id="godev">godev</h2>

<pre><code># 依赖管理
</code></pre>

<h2 id="gv">gv</h2>

<pre><code># 依赖管理
</code></pre>

<h2 id="gvt">gvt</h2>

<pre><code># 依赖管理
</code></pre>

<h2 id="gvm">gvm</h2>

<pre><code># 版本管理
命令
    gvm
        install go1.5
        use go1.5
        list
        listall
        implode
            # 删除所有go版本和gvm本身
</code></pre>

<h2 id="gore">gore</h2>

<pre><code># repl
</code></pre>

<h2 id="go-torch">go-torch</h2>

<pre><code># 性能火焰图
go-torch -b cpu.prof
</code></pre>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/outrunJ/hugo-blog/commit/45078a10fae17d9ddee23ac09de803192f25f295" title='Last modified Jul 25, 2019 by shenwenqing' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" alt="Changed" /> Jul 25, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/outrunJ/hugo-blog/tree/master/content/docs/pl/go.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#基础">基础</a></li>
<li><a href="#命令">命令</a></li>
<li><a href="#语法">语法</a>
<ul>
<li><a href="#内置关键字">内置关键字</a></li>
<li><a href="#包函数">包函数</a></li>
<li><a href="#内置">内置</a></li>
<li><a href="#异常">异常</a></li>
</ul></li>
<li><a href="#包">包</a></li>
<li><a href="#测试">测试</a></li>
<li><a href="#并发编程">并发编程</a></li>
<li><a href="#工具">工具</a>
<ul>
<li><a href="#glide">glide</a></li>
<li><a href="#govendor">govendor</a></li>
<li><a href="#godev">godev</a></li>
<li><a href="#gv">gv</a></li>
<li><a href="#gvt">gvt</a></li>
<li><a href="#gvm">gvm</a></li>
<li><a href="#gore">gore</a></li>
<li><a href="#go-torch">go-torch</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
