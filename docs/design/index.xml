<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计 on outrun的笔记</title>
    <link>https://example.com/docs/design/</link>
    <description>Recent content in 设计 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/docs/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>人员</title>
      <link>https://example.com/docs/design/people/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/people/</guid>
      <description>人, 事, 团队 #  人 业内口碑 成分 技能，素质，精神 行动 感性，理性，惯性 发展 上限 下限 成本 低成本召回 事 知原理 是什么，为什么，怎么样，拆解 事与团队 事造就团队，好团队不一定出好成果 团队 存在合理性 有目标，成员能力认可，成员感性认可 小精英团队，才能解决问题 分配事 因特质分配，如稳定，峰值，沟通 成果评价 产出判断 分配利益和荣耀 时间和代码量评价不了程序员的工作, 可以匿名互评(口碑) 团队提升 培训无意义，自觉成长 成员 项目经理 设计 开发 测试人员 运维 系统工程师 设计、实现产品 数据分析师 技术总监 架构师 权衡, 出方案  职工 #  态度 把握分寸 靠谱(事事有交代) 负责(顾全局) 主动 超出预期 负责态度, 提高团队效率，而非自己效率 # 严肃判断 沟通 及早沟通、同步 文档 &amp;gt; 邮件 &amp;gt; im &amp;gt; 电话 # 即时性相反 留响应时间, 同组 -&amp;gt; 跨组 -&amp;gt; 跨部门 -&amp;gt; 跨公司 明确通知人时, 邮件, im特殊指定 文档 周报 文档简单有计划，为节省向别人解释的时间 建设性意见(提选择题) 只交“产品”: 背景清晰, 扼要, 完整, 引入独有经验  工程师 #  本质 解决问题 普遍问题 技能: 工具使用(写工具), 表面学习, 笨办法, 不会读文档, 只会知识迁移 设计: 不知经典设计, 不知设计哲学, 不知目的, 无法反应需求, 没有品位, 读不懂设计 知识更新: 学不动, 基础差(用二手资料), 无认知体系(认为都是新东西), 重复学习无用知识 沟通: 不专业(不用专业名词), 不主动, 不沟通对方, 不抓重点, 思路不连贯, 阅历不足(不会写文档), 不问为什么 能力 特点 知识、经验、技能、协作 # (1+天赋)x知识x工程习惯 犯错(多做多错) 方法 抽象 # 设计就是从升维中拆分和简化 沉淀 # 没有沉淀的学习不好回顾修改, 像没有测试的代码 品位 优点，缺点 # 找潜质, 并非此长彼短，是两个维度,有一定抑制作用 创造力，纪律 勤奋，聪明 稳定，峰值 深度，速度 细节，大局 开发 考虑工作的复用性 加入项目，需要可对所有代码修改 善用工具 自己的事主动跟进 owner 自我负责, 自我驱动, 持续改进 能部署, 能手工排查问题，手工修复数据, 开发调试工具, 数据修复工具 模块职责单一, 明白当前负责和极限性能 能降级, 知道下游调用和降级影响。了解上游依赖和上游降级影响 配好log、监控、告警, 告警及时响应  架构师 #  场景/用例/问题 -&amp;gt; 方案/方案权衡 -&amp;gt; 落地路径 分级 初级 代码 命名：精确性、简单性、一致性、区别性、业务性 逻辑: 缩进、换行 代码体积: 行、方法、类 抽象能力 边界 中级 流量、并发等 高级 理解业务核心价值、业务实现方式 业务技术支撑方式 业务趋势  艺术家 #  岗位 #  项目经理(pm, project manager) 技术经理(tm, technical manager) 产品设计经理(pdm, product design manager) 运营经理(pom) 测试经理(qam) 客服经理(csm, customer success manager) 开发组长(tl, team leader) 架构师(pa) 开发工程师(de, development engineer) 数据库管理员(dba, database administrator) 系统管理员(sa) 界面设计师(ui, user interface) 用户体验设计师(ue, user experience) 产品运营师(po, product operator) 产品设计师(pd, product designer) 测试工程师(qa, quality assurance) 配置管理员(pcm) 发布员(pb) 软件过程专员(sqa, software quality assurance) 运维工程师(sre, site reliability engineer)  招聘 #  双向选择 精确率&amp;amp;召回率 方面 沟通 喜欢技术，逻辑能力, 编码能力, 设计能力 基本概念, 边界考虑充足, 进阶答案, 衍生问题的解决 是否有自己思考，对自己负责  </description>
    </item>
    
    <item>
      <title>组织</title>
      <link>https://example.com/docs/design/organize/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/organize/</guid>
      <description>组织 #  系统划分与组织划分 康威定律 系统架构是公司组织架构的反映 按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本 沟通出现问题，考虑调整组织架构 在该拆分时拆分 为了简单 开发和运维分离 业务和基础架构分离 无状态和有状态分离 业务间乘法(正交)而非加法 # 升维的特点, 正交叠加 多层抽象, 不断隐去底层(约定大于配置) # 升维的特点, 抽象观察  管理 #  提供 问题: 定义, 分解, 什么是问题, 前人如何处理 # 工程为解决问题 思考: 方向, 为了解决问题, 找到关键, 找到应学知识 # 创造性工作要思考 体系: 领域的体系, 领域体系形成原因, 为了高效思考和学习, 有体系的做事 参考: 参考书籍, 如何筛选, 如何搜索, 社区 不提供 知识点, 答案, 规定, 代码 分任务 出问题，写相关文档 砸需求，看弹性 任务列表: 难度, 优先级, 排期, 地平线目标, 现状, wishlist nice to have给新人  项目管理 #  目标 完成不动点需求 正交、简单(要求想清楚、灵活) 维护概念完整性、一致性(纯洁) 术语不变、不矛盾、不重叠 考虑上下游 问题 开发碎片化(重复的代码、由于不知道或怕改错) review 持续集成(*lint, CI/CD) 早合并 自动构建、测试 效率 沟通 设计 开发 方案 需求池 优先级、排期、checklist、周update confluence jira: 空间, 优先级, 追踪, assign, 评论 史诗(epic)、故事(story)、任务、子任务、冲刺 敏捷: 周冲刺, hackson 集体review block by 组织 负责人 小组长 owner 产出 评价程序员 时间，代码量不合适, 口碑、解决问题。加班是能力问题，效率第一 总会犯错，多做多错 估期不准，赶期质量不行，不怕delay owner, 鼓励设计、技术自由(开发人员诉求技术，厌倦业务) 良心，内驱力 产品 需求磨砺核心业务资产 事情成就精英团队，而非精英团队成就事  工程模型 #  历史 程序设计阶段1946-1955 节省空间 软件设计阶段1956-1970 硬件发展，软件危机 软件工程阶段1970-今 组件化  瀑布模型 #  # 每一次执行工作流的深度不同 可行性分析 实现会不会复杂，尽量简单 需求分析 分类 生存点 痒点 兴奋点 # 不会按时交付（只完成主要，然后延期，用户测试） 客户沟通，同类产品比较，行业标准 功能 正确, 可行, 必要, 有序, 明确, 一致 性能 完善, 简短 设计 先出成果再优化 任务分配(进度条) 命名标准 文档 可移植、可维护易扩展 排期 实现 测试 运维  螺旋模型 #  # 边分析边开发边交付（一环一环向目标实现） 敏捷开发 项目面临的问题 人员流动 代码维护 种类 极限编程(xp) 特点 简易、交流、回馈 方法 解耦低速设备，提高响应速度 迭代 迭代周期 一个迭代周期中不新添加需求 一个迭代周期中包含多次迭代 一个阶段的结束称之为里程碑 初始化阶段增量 项目启动 建立业务模型 定义业务问题域 找出主要风险因素 定义项目需求的外延 创建业务问题域的相关说明文档 细代阶段增量 高层的分析与设计 建立项目的基础框架 监督主要的风险因素 制订达成项目目标的创建计划 构建阶段增量 代码及功能的实现 移交阶段增量 向用户发布产品 beta测试(alpha测试是内部测试， beta测试是用户测试) 执行性能调优，用户培训和接收测试  转型 #  流程 (2-4)周实地调研痛点 确定目标 要求: 领先、高效、高品质 列出实际问题 评估 cmmi(敏捷成熟度模型): 代码、架构、工具 实施变化 战略 试点团队(灰部应用于组织): 完成产品指标  工程工具 #  控制面板 项目 分配给我 活动日志 人员 团队 权限 项目 配置 事务 类型 布局 # 列表项，详细项 时间追踪 配置链接关系 优先级 解决方案 工作流 # 对不同项目和事务类型, 配置状态转换图 页面方案 # 对不同项目和事务类型，不同状态转换时，配置字段布局 自定义字段 # 对不同页面 权限 权限 角色、应用程序、组、用户、项目负责人、当前经办人、自定义字段值等 事务(issue) 状态 todo, 正在进行, done 打开, 已重新打开, 已解决, 已关闭 backlog, in review, selected for development, building, build broken waiting for support, respond to customer, escalate, cancel, canceled, done waiting for approval, work in progress [工作流状态] 类别 待办 正在进行 完成 无类别 名称 长篇故事(史诗) 故事 分类: 需求, 设计 验收条件 任务, 子任务, 缺陷, 新增功能, 改进 服务请求, 服务请求审批, 问题, 事件(系统中断) 订单 全局顺序 属性 经办人，报告人 优先级 highest, hign, medium, low, lowest 链接 clones is cloned by duplicates is duplicated by blocks is blocked by causes is caused by relates to csv导入 筛选器 未清, 我发起, 已完成, 最近 活动 评论, 历史, 工作日志 冲刺(sprint) 状态 待办, 进行, 完成 发布 版本 报告(report) 敏捷 燃耗图, 燃尽图, 版本报告, 长篇故事报告, 控制图，长篇故事燃尽图, 发布燃尽图 冲刺报告, 速率表 累积流程图 事务 饼图, 单次分组, 解决时间, 平均周期, 事务持续时间, 已创建已解决对比, 最新创建 预测 版本工作量, 人员工作量, 时间跟踪 其它 工作负荷 服务台(itsm) 分类 对内 对外 途径 邮件, 帮助中心, 小程序 队列 分类 状态workflow 经办人 客户 报告 系统 审计日志  开发模型 #  TDD(test-driven development) 先单元测试 BDD(behavior-driven development) TDD的变种, 重点描述行为 面向需求 组织上小而全 开发全栈减少沟通 设计上面向领域 </description>
    </item>
    
    <item>
      <title>行业</title>
      <link>https://example.com/docs/design/biz/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/biz/</guid>
      <description>云 #  本质 批发转零售 帮助别人成功而成功 产品型转服务型 优势 轻，方便 全 可计算 现象 外包被淘汰 行业 OS of business 功能 产品功能，样板 开发体验，文档 组件收费，容量收费，节省的成本收费 数据直接做决策 分类 service # 基础服务 plugins # 基础服务组合 app # plugins组合  产业互联网 #  供应链 #  为什么 大厂核心 各节点(库存)周转 是什么 资源 -&amp;gt; 渠道 -&amp;gt; 用户 反馈用户真实需求 上游关注制造业 下游关注erp 批量(精), 个性化(敏) 物流, 资金流(现金流), 信息流 库存管理 应对变化(保质期) 求零库存 供应商 评级 物流, 成本 难点 打通 怎么样 成本、利用率 可靠性, 反应力, 柔性(补错) 感知、预测 赋能 重点 按时制造 难点 协调(协议) 步骤 单品上下游延伸  AI #  优化、预测 拟合函数, 高阶微积分, 梯度下降  媒体 #  场景控制 3CAD character camera control art direction 特效 会场散射光束（博物馆） 雾中焦点的竖光（saber的剑） 画线的光点（最终幻想） 密集的星星，远近缩放，光圈(tree.</description>
    </item>
    
    <item>
      <title>身体</title>
      <link>https://example.com/docs/design/body/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/body/</guid>
      <description>造型期 #  体态 高低肩 骨盆前倾 体能 心肺 变速有氧：4、6、8各2min， 30min以上 力量 核心训练  健身计划 #  目标 指导 FITT Frequency: 一周3-5次 Intensity: 有氧 心率: 123-142 无氧 动作 间歇 个数 重量 Time: 60min力量 + 30min有氧 Type: 热身 抗阻力训练 拉伸 阶段 适应期(1-2月) 心肺功能: 功率 核心力量 保护腰：呼吸 + 静态 内脂 力量训练 动作规范 蹲、推、拉、举、旋转 进阶期(2-3月) 消耗 &amp;gt; 摄入 七大肌肉群：胸、肩、背、腹、腿、臀、手臂 三分化、四分化 爆发力  </description>
    </item>
    
    <item>
      <title>驱动</title>
      <link>https://example.com/docs/design/drive/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      
      <guid>https://example.com/docs/design/drive/</guid>
      <description>学习 #  计划 为什么 有全局, 有方向 平时活动与目标联系起来 轻重有序 磨炼意志(适应变化, 抗干扰) 养成习惯(抗干扰不费意志) 怎么样 全面(考虑娱乐和休息) 简单明确、具体、适当、突出重点 时间科学, 遵守作息时间 及时调整 预习 为什么 上课时：扫除知识障碍、针对性解决问题、笔记有针对性 提高自学能力 改变被动局面，成为良性循环 是什么 初步理解 关联旧知识 找不理解 做笔记和习题 怎么样 先粗读, 再反复细读 先读最困惑点 问为什么 请教别人 实践 笔记 重点、结构、摘要 分类 问题 查阅资料 理解思路 逐步提高 由点到面，由浅入深 学习 怎么样 集中注意 获取知识主动权 作者思路，比较思维方法 方法 分析综合法、归纳演绎法、比较分类法 规律 同一律、矛盾律、排中律 # 形式逻辑学 对立统一、量变到质变、否定之否定 # 辩证逻辑学 学科特点 理科: 逻辑性，抽象思维 文科: 知识有独立性，形象思维 教师特点 保持连续性，不中断钻牛角尖 笔记 思维方法、过程、结果 完整简洁 当堂掌握 领会、巩固、运用 重点是认知过程而非结论 复习 贵在及时 怎么样 尝试回忆 读原文 整理笔记 参考资料 系统复习 为什么 牢固、完整 系统、实用 怎么样 之前之后回忆 有重点阅读 熟记 整理笔记 练习 记忆能力 有记忆意识 理解后记忆 艾宾浩斯曲线 过度学习来记忆 分散记忆好于集中记忆 先整体理解, 后分段记忆, 最后综合复习 多感官 思维能力 积极思维状态 基本思维方法 分类、抽象概括 系统化, 使用时具体化 思维形式 整体思维 相似思维 逆向思维 创造思维  读源码 #  目标 了解思路 难点 理解非自己的思路 了解数据结构、设计模式 原则 跑不起来不读 带目的性读，解决问题就好 一条线索到底 无关细节略过 画类图、类调用泳道图  高效模型 #  人 #  组织 简单，分离 管理 无为 沟通 在线文档 &amp;gt; 邮件 &amp;gt; im &amp;gt; 口头/电话 多方口头时，要维护自有重点 谈判 抛回对方问题，使其思考，后做到已方稍强  事 #  计划 把握纲领，不能变 先核心再扩展 # 稳定隔离 第一性原理 做重要不紧急 边界分割 # 正交 拆分并只安排步骤 思考框架：现状、目标、实现路径 意义(目标导向)。通常是解决问题  拆分到最细节的方案, 分配到人、工作量、联调提测时间 迷雾即瓶颈 曼陀罗思考法 实行 原型 风险点 # 技术 只输出产品，电梯演讲(简单, 清晰, 轻松, 主线, 一套) 输入时保持输出 把控变化，提供适应方案 内部有 &amp;gt; 外部有 &amp;gt; 半成品 &amp;gt; 自实现 解耦低速设备 update全员参与, 或文档 灰度替换 总结 向流程和工具找问题</description>
    </item>
    
    <item>
      <title>代码</title>
      <link>https://example.com/docs/design/code/</link>
      <pubDate>Wed, 10 Oct 2018 17:40:53 +0800</pubDate>
      
      <guid>https://example.com/docs/design/code/</guid>
      <description>认知 #  原理 模拟执行 负担 概念量 封装粒度大 多态、运行时多态、静态多态 临时状态 用工作流, 而非队列 日志(event)搜索/集中/回放 抽出权限层 非轻量级 胶水层厚 无稳定方案, 复用困难 流程长度 最好 单线程 # 不插入行为 上下文集中 this.scene.commit()集中状态转移时间线 单一方式  原则 #  观念 KISS(keep it simple stupid) YAGNI(You Ain’t Gonna Need It) 取好名字占设计一半 约定大于配置 并发的世界，并发的软件 分布式的世界，分布式的软件 不可预测的世界，容错性强的软件 复杂的世界，简单的软件 代码即数据 物体上绑定行为数据 传递代码数据(函数一等公民) 防御性编程 接口前validator 启动时自检断言 异常处理 不可过度 设计 solid原则 单一职则(single responsibility) 一个类负责一个功能 开闭(open/closed) 对扩展开放，对修改关闭，如接口, 如数组扩展结构体状态 里氏替换原则(liskov substitution) 子类继承超类的所有 接口分离(interface segregation) 最小功能隔离 依赖反转(dependency inversion) 低层依赖高层, 具体依赖抽象 非侵入 # non-intrusion 将功能推入代码，而非代码拿到功能 代码实现接口，而非继承类 拆分 边界 正交 unix rules 模块化(modularity) # 模块由精心设计的接口连接 清晰化(clarity) # 可读性、可维护性 组合(composition) 分离(separation) 简单(simplicity) 节俭(parsimony) # 越小越好 透明(transparency) # log, tracing 鲁棒(robustness) 可展示(representation) # 逻辑简单，数据复杂 最小惊吓(least surprise) # 少打破用户预期 安静(silence) 修复(repair) # 产生足够报错 经济(economy) # 减少开发时间 生成(generation) # 避免手写, 用高阶抽象生成代码 优化(optimization) # 优化和收益平衡 分化(diversity) # 一开始设计不限制、优雅开放灵活 扩展(extensibility) # 协议可扩展 优化 需要时再优化，设计时考虑扩展性 dry(don&#39;t repeat yourself), 不可过度 找瓶颈 产出 设计清晰 选型简单 代码精炼 抽象优雅  设计 #  创建 factory, abstract factory # 工厂 builder # 构建者 prototype # 原型复制来产生对象 singleton # 单例 结构 adapter # 适配器 bridge # 抽象与实现分离 composite # 抽取公共行为 decorator # 装饰 facade # 外观。提供子类的默认视图 flyweight # 享元 proxy # 代理 行为 interpreter # 解释器 template method # 模板方法、泛型 chain of responsibility # 责任链 command # 命令 iterator # 迭代器 mediator # 消息传递中介 memento # 保存、恢复状态 observer # 观察者 state # 不同状态定义不同行为 strategy # 同行为的不同算法、替换算法 visitor # 访问者。抽象行为本身，不同访问对象不同行为 元素模式 抽象各模式成元素，简化表示 actor # 消息通信 reactor # 事件轮循，注册回调，如libevent proactor # 注册事件回调，os通知触发回调 惰性求值 链式定义(配方)，后自动触发(js tick调度)终止操作 dsl测试(如jasmine.</description>
    </item>
    
    <item>
      <title>工程</title>
      <link>https://example.com/docs/design/project/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      
      <guid>https://example.com/docs/design/project/</guid>
      <description>产品 #  愿景 定义产品的目的和原因，将到达的地点 ux 微交互 # 细节决定成败  RoadMap #  介绍 到达愿景的策略路径，提供一系列与产品战略相一致的战术步骤 为什么 简单、清晰的通讯文档 少的多的会议 健康的团队辩论：交付成果与目标联系起来 做出每个人都理解的产品决定，不再打击创意 高维度的概述 动态演变 要素 时间周期 时间区间，只定时间范围 big-view(product) 全局理解产品的未来, 交付顺序 统一视野(vision), 范围(scope)，时间期限(time line) pre-view(release) release中的产品功能, 和前几个迭代从backlog中要交付的工作项(item) now-view(iteration) 团队在一次迭代中要交付的需求(requirements) 优先级，留空间适应变化 项目事件 完成产品总体计划必要的工作项, 详尽且切合目的 分解目的，制定步骤 路标 关键工作项完成的时间节点(里程碑) 结果反馈：审视是否偏离，试验中改进 确定在每个时间范围内实现可衡量的结果。定义为目标关键结果(OKR)、关键性能指标(KPI) 种类 基于目标 current near term future 基于功能 5000新用户 步骤 确定目标 分解目标，穷尽事项，组织，优先级排序 使用优化框架 effort / impact impact / goal 卡洛斯模型? 注意 定义战略主题(名词)，抓住核心用户行为的本质、产品能力、竞争优势、技术改进 保持路线图战略，避免战术 每个计划阶段都考虑优先级, 每个目标、动作、发布、特性的价值可见性 始终在试验(ABE), 为了正确定义目标和后续特征 先做出有根据的猜测 测试 基于反馈迭代  业务 #  目标 降低人才素质需求 减少开发时间 分类 创造虚拟空间 自动化 辅助决策 思路 逻辑: 因果(演绎), 时间, 空间, 优先 方法: 5w2h(who, when, where, why, what, how, how much) 建模: 中心 # 调整抽象领域和层次(视问题决定) 自上而下 # 问题明确，展开 自下而上 # 内容分类、剪枝、归纳 分解 MECE(mutually exclusive collectively exhaustive) 正交 穷尽 经验 优秀的产品都有全局把控感(confluence, jira) 设计思想多源自: 操作系统、编译器、函数式 深入一线(面对客户) 思考全面, 全局 考虑需求本质，考虑上下游全局 想清楚再行动 过程 发掘(discovery) 价值定位(价值驱动) 客户体验梳理和设计 愿景 干系人 电梯演讲收敛 定义(define) 用户旅程，业务流程 事件风暴 -&amp;gt; 映射技术 -&amp;gt; 架构 设计(design) 总体 识别问题域, 归纳服务, 上下游关系 架构图, api, 技术栈 提升方向, 改进 迭代 价值/成本分布图 milestone演进 业务技术/需求拆解全景图(白板贴标) mvp(minimum viable product最小可行计划)迭代计划 开发(develop) 度量, 质量指标 工具选择, 规范 架构守护，治理 实施策略 交付 产品生命周期管理 目标, 资本 机会点-&amp;gt;需求 角度决定设计 找到不动点 如对cache的设计 业务角度 选择简单易用的缓存框架 有人会用，学习成本别太高 关注数据模型结构设计 缓存更新真麻烦 paas角度 声明式使用，配置文件设置 缓存对比，选择强大且稳定的 存取接口设计，方便易用 数据变动监听，自动刷新缓存 平台角度 缓存服务器集群方式 存储空间监控 命中率监控 避免缓存集中失效引起雪崩 不过度设计 # 不超出需求，不用复杂方式实现 # 少就是多，应一减再减。简单才能强大，也会提高性能和扩展性 范围减少 # 28原则，最小可行产品 设计减少 # 易理解，低成本，可扩展 实施减少 # 找开源-&amp;gt;找内部已实现-&amp;gt;找方案描述-&amp;gt;自己解决 二八定律 墨菲定律 事情不是表面看起来那么简单 事情都会比预计时间长 可能出错总会出错 如果你担心发生，它更可能发生 维护 设计时考虑扩展性 DID(design, implement, deploy)(设计20倍, 实现3-20倍, 部署1.</description>
    </item>
    
    <item>
      <title>Java设计模式</title>
      <link>https://example.com/docs/design/design_mode/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      
      <guid>https://example.com/docs/design/design_mode/</guid>
      <description>六个原则 #  单一职责原则(SRP, Single Responsibility Principle) 一个类只做一件事，应该只有一个引起它修改的原因 开闭原则(OCP, Open-Close Principle) 对修改封闭，对扩展开放 里氏替换原则(LSP, the Liskov Substitution Principle) 子类可以完全替换父类。也就是继承只扩展新功能 依赖倒置原则(DIP, the Dependency Inversion Principle) 细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定 接口隔离原则(ISP, the Interface Segregation Principle) 客户端不依赖它不需要的接口。冗余依赖应该将接口拆分 迪米特法则（最少知道原则）(LoD, Law of Demeter) 一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话  构建型 #  工厂方法(Factory Method) #  # 简单工厂, 根据参数创建不同的类 # 静态工厂，单例工厂 public interface Sender{ public void Send(); } public class MySender implements Sender{ @Override public void Send(){} } public SenderFactory { public static Sender produceStatic() { return new MySender(); } public Sender produce(){ return new MySender(); } public Sender produce(int i){ return new MySender(); } } # 工厂子类继承工厂接口, 不同产品对应不同工厂 public interface AbstractFactory { public MySender produce(); } public class MyFactory implements AbstractFactory { @Override public MySender produce(){ return new MySender(); } }  抽象工厂(Abstract Factory) #  # 生产抽象产品 public interface AbstractFactory { public Sender produce(); } public class MyFactory implements AbstractFactory { @Override public Sender produce(){ return new MySender(); } }  单例(Singleton) #  确保只有一个实例 # 大多有资源管理器的功能 # 反射机制会使所有单例失效：私有构造方法可以被访问 应用 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 o-&amp;gt; 饿汉 public class Singleton { public static Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } o-&amp;gt; 懒汉式 public class Singleton { private static Singleton single=null; private Singleton() {} public synchronized static Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; } } o-&amp;gt; 懒汉，双重检测(DCL) # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。 # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized public class Singleton { private static volatile Singleton singleton = null; # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。 private Singleton(){} public static Singleton getInstance(){ if (singleton == null) { // t1,t2并发进入 synchronized (Singleton.</description>
    </item>
    
  </channel>
</rss>
