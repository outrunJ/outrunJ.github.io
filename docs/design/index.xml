<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计 on outrun的笔记</title>
    <link>https://example.com/docs/design/</link>
    <description>Recent content in 设计 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://example.com/docs/design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计-代码</title>
      <link>https://example.com/docs/design/code/</link>
      <pubDate>Wed, 10 Oct 2018 17:40:53 +0800</pubDate>
      
      <guid>https://example.com/docs/design/code/</guid>
      <description>思想 原则 替换 子类继承超类的所有 单一职则 一个类负责一个功能 开闭 对扩展开放，对修改关闭，如接口 最小功能隔离 顺序依赖 低层依赖高层，具体依赖抽象 非侵入 # non-intrusion 将功能推入代码，而非代码拿到功能 代码实现接口，而非继承类 创建 factory, abstract factory # 工厂 builder # 构建者 prototype # 原型复制来产生对象 singleton # 单例 结构 adapter # 适配器 bridge # 抽象与实现分离 composite # 抽取公共行为 decorator # 装饰 facade # 外观。提供子类的默认视图 flyweight # 享元 proxy # 代理 行为 interpreter # 解释器 template method # 模板方法、泛型 chain of responsibility # 责任链 command # 命令 iterator # 迭代器 mediator # 消息传递中介 memento # 保存、恢复状态 observer # 观察者 state # 不同状态定义不同行为 strategy # 同行为的不同算法、替换算法 visitor # 访问者。抽象行为本身，不同访问对象不同行为  面向对向 # Object Oriented 接口 一定要实现所有方法 接口可以实现多重继承 抽象类 抽象类可以有私有方法或私有变量 可以只实现部分方法 ooad # Object Oriented Analysis and Design ooa # analysis 建立针对业务问题域的清晰视图 列出核心任务 针对问题域建立公共词汇表 列出针对问题域的最佳解决方案 ood # design 细化类关系，明确可见性 增加属性 分配职责(方法) 消息驱动系统中消息传递方式 局部应用设计模式 类图时序图 oop # program 抽象: abstract 封装: encapsulation # 数据和方法绑定 继承: inheritance 多态: polymorphism overload为编译时 override为运行时 关联: association # has a 双向关联 两个类互相知道对方公共属性和操作 单向关联（大多数） 一个类知道另一个类的公共属性和操作 聚合: aggregation a包含b, b可以不在a创建时创建 组合: composition 比聚合强，a包含b, b在a创建时创建 内聚与耦合: cohesion &amp;amp; coupling # 高内聚低耦合 依赖: dependency # use a 泛化: generalization # is a  单例 单例模式 单例模式确保某个类只有一个实例，自行实例化并向整个系统提供这个实例。 # 大多有资源管理器的功能 # java反射机制会使所有单例失效：私有构造方法可以被访问 如 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 例子 public class Singleton{ private static Singleton uniqueInstance = null; private Singleton(){} public static Singleton getInstance(){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 几种单例 o-&amp;gt; 饿汉式，类初始化时实例化 public class Singleton1 { // 私有的默认构造子 private Singleton1() {} // 已经自行实例化 ，final private static final Singleton1 single = new Singleton1(); // 静态工厂方法 public static Singleton1 getInstance() { return single; } } o-&amp;gt; 懒汉式，第一次调用时实例化 public class Singleton2 { // 私有的默认构造子 private Singleton2() {} // 注意，这里没有final private static Singleton2 single=null; // 静态工厂方法 public synchronized static Singleton2 getInstance() { if (single == null) { single = new Singleton2(); } return single; } } o-&amp;gt; 双重锁,解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug # 避免bug就直接创建static属性，或get方法修饰synchronized public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ // 两线程并行到此，一个block synchronized(Singleton.</description>
    </item>
    
    <item>
      <title>设计-工程</title>
      <link>https://example.com/docs/design/project/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      
      <guid>https://example.com/docs/design/project/</guid>
      <description> 评价 必要分析 tracing log, 监控, 告警 极限性能，当前负载情况 降级方案 下游依赖 数据修复脚本 集成性 integration, 整体各部分间有机协调工作，发挥集体效益 信息系统的集成性 系统之间相互通信和相互协作的能力 扩展性以集成性为前提 可复用性 可提高可扩展性 扩展性 评估 方便添加新功能 扩展后，新旧功能集成性 扩展后，满足性能: 及时性、可靠性 安全 低成本 方式 应用分离 正确管理依赖项 类型 自动代码生成 动态编译 元模型 自描述文件 语言互用性 自定义属性(元数据) 基于元模型的反射 可扩展标记语言(xml) 插件 # 设计得当的一个软件几乎全部可以利用插件来完成 组件开发 功能固定 考虑兼容性、可重用性 难点 接口设计 可成长性 组成成分可不断增加 可扩展性是可成长性的基础 可代谢性 组成部分可以更新  工程 软件发展的阶段 程序设计阶段1946-1955 节省空间 软件设计阶段1956-1970 硬件发展，软件危机 软件工程阶段1970-今 组件化 迭代开发 迭代周期 一个迭代周期中不新添加需求 一个迭代周期中包含多次迭代 一个阶段的结束称之为里程碑 初始化阶段增量 项目启动 建立业务模型 定义业务问题域 找出主要风险因素 定义项目需求的外延 创建业务问题域的相关说明文档 细代阶段增量 高层的分析与设计 建立项目的基础框架 监督主要的风险因素 制订达成项目目标的创建计划 构建阶段增量 代码及功能的实现 移交阶段增量 向用户发布产品 beta测试(alpha测试是内部测试， beta测试是用户测试) 执行性能调优，用户培训和接收测试 瀑布模型 #每一次执行工作流的深度不同 # 80/20原则 可行性分析 实现会不会复杂，尽量简单 需求分析 分类 生存点 痒点 兴奋点 # 不会按时交付（只完成主要，然后延期，用户测试） 客户沟通，同类产品比较，行业标准 功能 正确, 可行, 必要, 有序, 明确, 一致 性能 完善, 简短 分析 设计 先出成果再优化 任务分配(进度条) 命名标准 文档 可移植、可维护易扩展 排期 实现 测试 运维 螺旋模型（模块化） # 边分析边开发边交付（一环一环向目标实现） 团队 运维 设计 开发 测试人员 分析师 技术总监 架构师（软件 数据库） 项目经理（技术、人员【人员离职问题】、软件） 公司问题 人员流动 代码维护  设计 角度决定设计 如对cache的设计 业务角度 选择简单易用的缓存框架 有人会用，学习成本别太高 关注数据模型结构设计 缓存更新真麻烦 paas角度 声明式使用，配置文件设置 缓存对比，选择强大且稳定的 存取接口设计，方便易用 数据变动监听，自动刷新缓存 平台角度 缓存服务器集群方式 存储空间监控 命中率监控 避免缓存集中失效引起雪崩  uml Unified Modeling Languag 静态模型 用例图(需求分析):客户看 # 项级图(突出重点)，一级图，二级图，三级图 参与者(泛化) (关联) 用例(包含，扩展【继承】) # 是动词，表示功能模块 注释 类图：类结构、类关系（可以自动生成java类） 继承 实现 关联（全局变量）【导航性：一对多关系等】【聚合(所有引用)，组合（生命周期相同，如int类型属性）】 # spring 中的依赖注入是关联 依赖（局部变量） 实体关系图ER 动态模型 时序图：可以根据时序图写代码 #　rose工具中时序图中加入参与者：用例图中创建参与者，拖入时序图中  微服务 数据 租户 用户 micro service 每个service监控 每个service不单点 单功能拆分，边界明确 service间只依赖sdk(好莱坞法则)，通过服务总线发现 servcie无状态接入 分类 内部服务 internal # 内外服务用互相转化 文件上传 图像处理 数据挖掘 报表 外部服务 external # 流控、质量监控、多链路备用、降级方案 邮件 短信 推送 cti 企业信息校验 业务服务 transaction 审批流 工作流 登录 海 核心服务 core 租户id服务 检索服务 报表服务 监控服务 k8s 服务总线 支持服务 supportive 文档 测试环境 沙盒同步 插件服务 plugin 集成服务 integration 事务服务 finance CPQ ERP saas基础 计费 用户管理 联动 导入企业数据 调用aws或aliyun，提供webhook 服务的sdk 多语言sdk 降级 ha apm 服务监控 # 用于发现问题、追查事故、评估缩容或扩容、评估降级 日志 接口 # 调用服务提供的监控接口 系统 # 容器提供 apm # 客户端采样 可达性 # 由通用监控完成 工程 打包docker镜像 服务升级 灰度发布与AB test 提供api版本接口供客户端查询 服务总线 管理服务状态、位置  PaaS # platform as a service，介于IaaS和SaaS中间 将软件研发的平台做为服务，以SaaS的模式交付 组件化支撑和驱动 # 组件的发展决定paas广度，组件的聚合决定paas深度 # 对内固守组件边界，对外暴露标准接口 分层 平台组件 基础业务 # 不可见，影响全局，通用业务逻辑，对性能很敏感 业务 组件 设计 # 自描述的，这样就在设计和开发上解耦 确定边界 定义标准接口 确定核心功能 规范异常处理 开发 # 像开发dsl一样,来评判核心逻辑和接口，抽象度高 技术评审 定义接口 # 面向接口开发，也称为BDD dubbo、grpc等 restful 接口设计 标准化 说明 服务路由 版本管理 授权管理 核心理念 # 体现在 服务、工具、模型、规范 开放 而非 封闭 合作 而非 限制 共享 而非 替代 重点关注 基础业务 组织架构和用户组 审批流 权限 通用模型 透明分布式缓存模型 分布式存储模型 分布式事务模型 效率工具 数据迁移工具 缓存配置工具  工作流 分层 kernel # engine adapter # services  </description>
    </item>
    
  </channel>
</rss>