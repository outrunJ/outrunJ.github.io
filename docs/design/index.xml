<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计 on outrun的笔记</title>
    <link>https://example.com/docs/design/</link>
    <description>Recent content in 设计 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://example.com/docs/design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计-代码</title>
      <link>https://example.com/docs/design/code/</link>
      <pubDate>Wed, 10 Oct 2018 17:40:53 +0800</pubDate>
      
      <guid>https://example.com/docs/design/code/</guid>
      <description> 思想 原则 替换 子类继承超类的所有 单一职则 一个类负责一个功能 开闭 对扩展开放，对修改关闭，如接口 最小功能隔离 顺序依赖 低层依赖高层，具体依赖抽象 非侵入 # non-intrusion 将功能推入代码，而非代码拿到功能 代码实现接口，而非继承类 创建 factory, abstract factory # 工厂 builder # 构建者 prototype # 原型复制来产生对象 singleton # 单例 结构 adapter # 适配器 bridge # 抽象与实现分离 composite # 抽取公共行为 decorator # 装饰 facade # 外观。提供子类的默认视图 flyweight # 享元 proxy # 代理 行为 interpreter # 解释器 template method # 模板方法、泛型 chain of responsibility # 责任链 command # 命令 iterator # 迭代器 mediator # 消息传递中介 memento # 保存、恢复状态 observer # 观察者 state # 不同状态定义不同行为 strategy # 同行为的不同算法、替换算法 visitor # 访问者。抽象行为本身，不同访问对象不同行为 并发的世界，并发的软件 分布式的世界，分布式的软件 不可预测的世界，容错性强的软件 复杂的世界，简单的软件  面向对象(Object Oriented) 接口 无实现 可多重继承 抽象类 可以有私有方法变量 实现部分方法 ooad # Object Oriented Analysis and Design ooa # analysis 建立针对业务问题域的清晰视图 列出核心任务 针对问题域建立公共词汇表 列出针对问题域的最佳解决方案 ood # design 细化类关系，明确可见性 增加属性 分配职责(方法) 消息驱动系统中消息传递方式 局部应用设计模式 类图时序图 oop # program 抽象: abstract 封装: encapsulation # 数据和方法绑定 继承: inheritance 多态: polymorphism overload为编译时 override为运行时 关联: association # has a 双向关联 两个类互相知道对方公共属性和操作 单向关联（大多数） 一个类知道另一个类的公共属性和操作 聚合: aggregation a包含b, b可以不在a创建时创建 组合: composition 比聚合强，a包含b, b在a创建时创建 内聚与耦合: cohesion &amp;amp; coupling # 高内聚低耦合 依赖: dependency # use a 泛化: generalization # is a  风格 命名 包名类名为名词, 方法名为动词 参数、方法名称在上下文语义中合理 , 像写文章一样 横向代码单屏内分行 性能 避免嵌套循环，特别是数据库操作 结构 # 高内聚，低耦合 抽取方法 业务逻辑分层 框架无侵入性 技巧 注释驱动写复杂业务  质量 代码 功能、结构、资源 非遗留代码 写了测试 改代码 bug 重构 # 只改结构 确定修改点 找出测试点 解依赖 伪/仿对象 接缝 全局函数 提取重写方法 宏预处理 替换连接的代码 对象 # 耦合对象不好初始化 子类化重写方法 接口提取 创建简化接口 创建简化类与对象，引用原对象 暴露静态方法 对象提取公共方法，只测公共方法 传方法参数 写测试 优化 # 只改资源  </description>
    </item>
    
    <item>
      <title>设计-工程</title>
      <link>https://example.com/docs/design/project/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      
      <guid>https://example.com/docs/design/project/</guid>
      <description>思想 设计 墨菲定律 事情不是表面看起来那么简单 事情都会比预计时间长 可能出错总会出错 如果你担心发生，它更可能发生 二八定律 系统划分与组织划分 康威定律 系统架构是公司组织架构的反映 按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本 沟通出现问题，考虑调整组织架构 在该拆分时拆分 角度决定设计 如对cache的设计 业务角度 选择简单易用的缓存框架 有人会用，学习成本别太高 关注数据模型结构设计 缓存更新真麻烦 paas角度 声明式使用，配置文件设置 缓存对比，选择强大且稳定的 存取接口设计，方便易用 数据变动监听，自动刷新缓存 平台角度 缓存服务器集群方式 存储空间监控 命中率监控 避免缓存集中失效引起雪崩 考虑因素 高并发、高可用、高可靠 容量规划(流量、容量) SLA(service level agreement)制定(吞吐量、响应时间、可用性、降级方案) 压测方案(线下、线上) 监控报警(机器负载、响应时间、可用率) tracing 应急预案(容灾、降级、限流、隔离、切流量、可回滚)  业务设计 不过度设计 # 不超出需求，不用复杂方式实现 # 少就是多，应一减再减。简单才能强大，也会提高性能和扩展性 范围减少 # 28原则，最小可行产品 设计减少 # 易理解，低成本，可扩展 实施减少 # 找开源-&amp;gt;找内部已实现-&amp;gt;找方案描述-&amp;gt;自己解决 维护 设计时考虑扩展性 DID(design, implement, deploy)(设计20倍, 实现3-20倍, 部署1.5-3倍) 设计能够监控的应用 版本升降 # 代码仓库 业务 防重 # 重复提交，重复扣减，重复支付(异构系统无法防重，用退款处理) 防重key, 防重表 幂等 # 消息处理，第三方支付回调 流程要抽象 # 如工作流 状态与状态机 订单系统 # 状态多时用状态机驱动 正向状态(待付款、待发货、已发货、完成) 逆向状态(取消、退款) 状态轨迹 # 跟踪和记日志，可回溯 并发修改，状态变更有序，状态变更消息有序 前端 减少dns查找 # dns可能查多个域 减少对象 # 页面布局少，图片合并。对象不要过大，减少到浏览器并发连接数 后台系统操作可反馈 # 便于确认效果 文档和注释 设计架构 设计思想 数据字典/业务流程 现有问题  高并发原则 无状态 # 应用无状态，配置有状态 尽可能浏览器端维护会话 分布式缓存放状态 拆分 # 加法组合，乘法功能 # 项目死于1到10，或10到100，因为解耦不够，无法重构 业务拆分 功能细分 读写 # 读缓存，写分库分表，聚合数据 AOP # 如CDN 模块 # 代码特征，如基础模块分库分表，数据库连接池 扩展 服务化发展 进程内服务 单机远程服务 集群手动注册服务(nginx负载多实例) 自动注册和发现服务(zookeeper) 服务分组/隔离/路由 服务治理(限流/黑白名单) AKF扩展立方 x轴 横向复制 # 复制服务或db, 瓶颈：内存缓存、特有数据 y轴 面向功能、服务、资源拆分 # 微服务 动词拆分 # 登录、搜索、推荐等 名词拆分 # 目录、库存、账户等 z轴 拆相近东西 # 数据分片(大小客户、地区、新旧等) 横向扩展 # 复制服务或数据分散负载，纵向扩展是升级设备 使用经济型系统 扩展数据中心 # 三实时站点备份: a(0.</description>
    </item>
    
  </channel>
</rss>