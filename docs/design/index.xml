<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计 on outrun的笔记</title>
    <link>https://example.com/docs/design/</link>
    <description>Recent content in 设计 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://example.com/docs/design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计-代码</title>
      <link>https://example.com/docs/design/code/</link>
      <pubDate>Wed, 10 Oct 2018 17:40:53 +0800</pubDate>
      
      <guid>https://example.com/docs/design/code/</guid>
      <description>思想 原则 替换 子类继承超类的所有 单一职则 一个类负责一个功能 开闭 对扩展开放，对修改关闭，如接口 最小功能隔离 顺序依赖 低层依赖高层，具体依赖抽象 非侵入 # non-intrusion 将功能推入代码，而非代码拿到功能 代码实现接口，而非继承类 创建 factory, abstract factory # 工厂 builder # 构建者 prototype # 原型复制来产生对象 singleton # 单例 结构 adapter # 适配器 bridge # 抽象与实现分离 composite # 抽取公共行为 decorator # 装饰 facade # 外观。提供子类的默认视图 flyweight # 享元 proxy # 代理 行为 interpreter # 解释器 template method # 模板方法、泛型 chain of responsibility # 责任链 command # 命令 iterator # 迭代器 mediator # 消息传递中介 memento # 保存、恢复状态 observer # 观察者 state # 不同状态定义不同行为 strategy # 同行为的不同算法、替换算法 visitor # 访问者。抽象行为本身，不同访问对象不同行为 并发的世界，并发的软件 分布式的世界，分布式的软件 不可预测的世界，容错性强的软件 复杂的世界，简单的软件  面向对向 # Object Oriented 接口 一定要实现所有方法 接口可以实现多重继承 抽象类 抽象类可以有私有方法或私有变量 可以只实现部分方法 ooad # Object Oriented Analysis and Design ooa # analysis 建立针对业务问题域的清晰视图 列出核心任务 针对问题域建立公共词汇表 列出针对问题域的最佳解决方案 ood # design 细化类关系，明确可见性 增加属性 分配职责(方法) 消息驱动系统中消息传递方式 局部应用设计模式 类图时序图 oop # program 抽象: abstract 封装: encapsulation # 数据和方法绑定 继承: inheritance 多态: polymorphism overload为编译时 override为运行时 关联: association # has a 双向关联 两个类互相知道对方公共属性和操作 单向关联（大多数） 一个类知道另一个类的公共属性和操作 聚合: aggregation a包含b, b可以不在a创建时创建 组合: composition 比聚合强，a包含b, b在a创建时创建 内聚与耦合: cohesion &amp;amp; coupling # 高内聚低耦合 依赖: dependency # use a 泛化: generalization # is a  单例 单例模式 单例模式确保某个类只有一个实例，自行实例化并向整个系统提供这个实例。 # 大多有资源管理器的功能 # java反射机制会使所有单例失效：私有构造方法可以被访问 如 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 例子 public class Singleton{ private static Singleton uniqueInstance = null; private Singleton(){} public static Singleton getInstance(){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 几种单例 o-&amp;gt; 饿汉式，类初始化时实例化 public class Singleton1 { // 私有的默认构造子 private Singleton1() {} // 已经自行实例化 ，final private static final Singleton1 single = new Singleton1(); // 静态工厂方法 public static Singleton1 getInstance() { return single; } } o-&amp;gt; 懒汉式，第一次调用时实例化 public class Singleton2 { // 私有的默认构造子 private Singleton2() {} // 注意，这里没有final private static Singleton2 single=null; // 静态工厂方法 public synchronized static Singleton2 getInstance() { if (single == null) { single = new Singleton2(); } return single; } } o-&amp;gt; 双重锁,解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug # 避免bug就直接创建static属性，或get方法修饰synchronized public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ // 两线程并行到此，一个block synchronized(Singleton.</description>
    </item>
    
    <item>
      <title>设计-工程</title>
      <link>https://example.com/docs/design/project/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      
      <guid>https://example.com/docs/design/project/</guid>
      <description>思想 设计 墨菲定律 事情不是表面看起来那么简单 事情都会比预计时间长 可能出错总会出错 如果你担心发生，它更可能发生 二八定律 系统划分与组织划分 康威定律 系统架构是公司组织架构的反映 按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本 沟通出现问题，考虑调整组织架构 在该拆分时拆分 角度决定设计 如对cache的设计 业务角度 选择简单易用的缓存框架 有人会用，学习成本别太高 关注数据模型结构设计 缓存更新真麻烦 paas角度 声明式使用，配置文件设置 缓存对比，选择强大且稳定的 存取接口设计，方便易用 数据变动监听，自动刷新缓存 平台角度 缓存服务器集群方式 存储空间监控 命中率监控 避免缓存集中失效引起雪崩 考虑因素 高并发、高可用、高可靠 容量规划(流量、容量) SLA制定(吞吐量、响应时间、可用性、降级方案) 压测方案(线下、线上) 监控报警(机器负载、响应时间、可用率) tracing 应急预案(容灾、降级、限流、隔离、切流量、可回滚)  业务设计 不过度设计 # 不超出需求，不用复杂方式实现 # 少就是多，应一减再减。简单才能强大，也会提高性能和扩展性 范围减少 # 28原则，最小可行产品 设计减少 # 易理解，低成本，可扩展 实施减少 # 找开源-&amp;gt;找内部已实现-&amp;gt;找方案描述-&amp;gt;自己解决 维护 设计时考虑扩展性 DID(设计20倍, 实现3-20倍, 部署1.5-3倍) 设计能够监控的应用 版本升降 # 代码仓库 业务 防重 # 重复提交，重复扣减，重复支付(异构系统无法防重，用退款处理) 防重key, 防重表 幂等 # 消息处理，第三方支付回调 流程要抽象 # 如工作流 状态与状态机 订单系统 # 状态多时用状态机驱动 正向状态(待付款、待发货、已发货、完成) 逆向状态(取消、退款) 状态轨迹 # 跟踪和记日志，可回溯 并发修改，状态变更有序，状态变更消息有序 前端 减少dns查找 # dns可能查多个域 减少对象 # 页面布局少，图片合并。对象不要过大，减少到浏览器并发连接数 后台系统操作可反馈 # 便于确认效果 文档和注释 设计架构 设计思想 数据字典/业务流程 现有问题  高并发原则 无状态 # 应用无状态，配置有状态 尽可能浏览器端维护会话 分布式缓存放状态 拆分 # 加法组合，乘法功能 # 项目死于1到10，或10到100，因为解耦不够，无法重构 业务拆分 功能细分 读写 # 读缓存，写分库分表，聚合数据 AOP # 如CDN 模块 # 代码特征，如基础模块分库分表，数据库连接池 扩展 服务化发展 进程内服务 单机远程服务 集群手动注册服务(nginx负载多实例) 自动注册和发现服务(zookeeper) 服务分组/隔离/路由 服务治理(限流/黑白名单) AKF扩展立方 x轴 横向复制 # 复制服务或db, 瓶颈：内存缓存、特有数据 y轴 面向功能、服务、资源拆分 # 微服务 动词拆分 # 登录、搜索、推荐等 名词拆分 # 目录、库存、账户等 z轴 拆相近东西 # 数据分片(大小客户、地区、新旧等) 横向扩展 # 复制服务或数据分散负载，纵向扩展是升级设备 使用经济型系统 扩展数据中心 # 三实时站点备份: a(0.</description>
    </item>
    
  </channel>
</rss>