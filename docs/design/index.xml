<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计 on outrun的笔记</title>
    <link>https://example.com/docs/design/</link>
    <description>Recent content in 设计 on outrun的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://example.com/docs/design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计-代码</title>
      <link>https://example.com/docs/design/code/</link>
      <pubDate>Wed, 10 Oct 2018 17:40:53 +0800</pubDate>
      
      <guid>https://example.com/docs/design/code/</guid>
      <description>思想 原则 替换 子类继承超类的所有 单一职则 一个类负责一个功能 开闭 对扩展开放，对修改关闭，如接口 最小功能隔离 顺序依赖 低层依赖高层，具体依赖抽象 非侵入 # non-intrusion 将功能推入代码，而非代码拿到功能 代码实现接口，而非继承类 创建 factory, abstract factory # 工厂 builder # 构建者 prototype # 原型复制来产生对象 singleton # 单例 结构 adapter # 适配器 bridge # 抽象与实现分离 composite # 抽取公共行为 decorator # 装饰 facade # 外观。提供子类的默认视图 flyweight # 享元 proxy # 代理 行为 interpreter # 解释器 template method # 模板方法、泛型 chain of responsibility # 责任链 command # 命令 iterator # 迭代器 mediator # 消息传递中介 memento # 保存、恢复状态 observer # 观察者 state # 不同状态定义不同行为 strategy # 同行为的不同算法、替换算法 visitor # 访问者。抽象行为本身，不同访问对象不同行为 并发的世界，并发的软件 分布式的世界，分布式的软件 不可预测的世界，容错性强的软件 复杂的世界，简单的软件  面向对向 # Object Oriented 接口 一定要实现所有方法 接口可以实现多重继承 抽象类 抽象类可以有私有方法或私有变量 可以只实现部分方法 ooad # Object Oriented Analysis and Design ooa # analysis 建立针对业务问题域的清晰视图 列出核心任务 针对问题域建立公共词汇表 列出针对问题域的最佳解决方案 ood # design 细化类关系，明确可见性 增加属性 分配职责(方法) 消息驱动系统中消息传递方式 局部应用设计模式 类图时序图 oop # program 抽象: abstract 封装: encapsulation # 数据和方法绑定 继承: inheritance 多态: polymorphism overload为编译时 override为运行时 关联: association # has a 双向关联 两个类互相知道对方公共属性和操作 单向关联（大多数） 一个类知道另一个类的公共属性和操作 聚合: aggregation a包含b, b可以不在a创建时创建 组合: composition 比聚合强，a包含b, b在a创建时创建 内聚与耦合: cohesion &amp;amp; coupling # 高内聚低耦合 依赖: dependency # use a 泛化: generalization # is a  单例 单例模式 单例模式确保某个类只有一个实例，自行实例化并向整个系统提供这个实例。 # 大多有资源管理器的功能 # java反射机制会使所有单例失效：私有构造方法可以被访问 如 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 例子 public class Singleton{ private static Singleton uniqueInstance = null; private Singleton(){} public static Singleton getInstance(){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 几种单例 o-&amp;gt; 饿汉式，类初始化时实例化 public class Singleton1 { // 私有的默认构造子 private Singleton1() {} // 已经自行实例化 ，final private static final Singleton1 single = new Singleton1(); // 静态工厂方法 public static Singleton1 getInstance() { return single; } } o-&amp;gt; 懒汉式，第一次调用时实例化 public class Singleton2 { // 私有的默认构造子 private Singleton2() {} // 注意，这里没有final private static Singleton2 single=null; // 静态工厂方法 public synchronized static Singleton2 getInstance() { if (single == null) { single = new Singleton2(); } return single; } } o-&amp;gt; 双重锁,解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug # 避免bug就直接创建static属性，或get方法修饰synchronized public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance(){ if(instance == null){ // 两线程并行到此，一个block synchronized(Singleton.</description>
    </item>
    
    <item>
      <title>设计-工程</title>
      <link>https://example.com/docs/design/project/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      
      <guid>https://example.com/docs/design/project/</guid>
      <description> 设计 思想 设计 墨菲定律 事情不是表面看起来那么简单 事情都会比预计时间长 可能出错总会出错 如果你担心发生，它更可能发生 二八定律 系统划分与组织划分 康威定律 系统架构是公司组织架构的反映 按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本 沟通出现问题，考虑调整组织架构 在该拆分时拆分 角度决定设计 如对cache的设计 业务角度 选择简单易用的缓存框架 有人会用，学习成本别太高 关注数据模型结构设计 缓存更新真麻烦 paas角度 声明式使用，配置文件设置 缓存对比，选择强大且稳定的 存取接口设计，方便易用 数据变动监听，自动刷新缓存 平台角度 缓存服务器集群方式 存储空间监控 命中率监控 避免缓存集中失效引起雪崩 因素 高并发、高可用、高可靠 容量规划(流量、容量) SLA制定(吞吐量、响应时间、可用性、降级方案) 压测方案(线下、线上) 监控报警(机器负载、响应时间、可用率) tracing 应急预案(容灾、降级、限流、隔离、切流量、可回滚) 高并发原则 无状态 # 应用无状态，配置有状态 拆分 业务拆分 功能细分 读写 # 读缓存，写分库分表，聚合数据 AOP # 如CDN 模块 # 代码特征，如基础模块分库分表，数据库连接池 服务化发展 进程内服务 单机远程服务 集群手动注册服务(nginx负载多实例) 自动注册和发现服务(zookeeper) 服务分组/隔离/路由 服务治理(限流/黑白名单) 消息队列 作用 服务解耦 异步处理 流量削峰/缓冲 # 如促销期 问题 丢失/失败 # 持久化，日志，报警, 数据校对修正(worker扫库) 重复 # 业务上防重 例子 redis扣库存-&amp;gt;记录日志-&amp;gt;同步worker-&amp;gt;DB 数据异构 例子 聚合数据表(一般KV存储) # 数据闭环(不依赖其它服务) 历史归档 缓存 客户端 浏览器缓存 # Expires, Cache-control app缓存 # 大促时更新静态资源, 地图 客户端网络 # 代理服务器缓存 广域网 代理服务器(如CDN) 推送 或 拉取(回源) 镜像服务器 P2P 源站 接入层缓存 # redis url重写 一致性哈希 proxy_cache # 内存/SSD缓存内容 proxy_cache_lock # 一段时间的回源合并成一个 shared_dict # lua, 重启缓存不丢失 应用层缓存 堆内缓存 堆外缓存 # local redis cache 分布式缓存(接入层后) redis集群 # 异步化写入, lua-resty-lock(非阻塞锁) 静态化, 伪静态化 服务器操作系统缓存 并发化 高可用原则 降级 开关集中化管理, 推送开关配置 开关前置 # nginx层做开关 可降级读服务 # 只读本地缓存、只读分布式缓存、只读默认数据 业务降级 # 部分业务异步，处理高优先级，分配流量保障系统可用 限流 思路 恶意请求流量只访问cache 穿透到应用的流量用nginx limit 恶意ip nginx deny 切流量 # 某服务器挂了 DNS切换 httpDNS # app配置，绕过运营商localDNS lvs/haproxy # 切换故障的nginx nginx # 切换故障应用 可回滚 事务 代码库 部署版本 数据版本 静态资源版本 业务设计 防重 # 重复提交，重复扣减，重复支付(异构系统无法防重，用退款处理) 防重key, 防重表 幂等 # 消息处理，第三方支付回调 流程可定义 # 工作流 状态与状态机 订单系统 # 状态多时用状态机驱动 正向状态(待付款、待发货、已发货、完成) 逆向状态(取消、退款) 状态轨迹 # 跟踪和记日志，可回溯 并发修改，状态变更有序，状态变更消息有序 后台系统操作可反馈 # 便于确认效果 文档和注释 # 设计架构、设计思想、数据字典/业务流程、现有问题 备份 # 代码仓库  </description>
    </item>
    
  </channel>
</rss>