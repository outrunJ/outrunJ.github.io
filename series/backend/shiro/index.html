<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>Shiro - outrunJ笔记</title>
  <meta property="og:title" content="Shiro - outrunJ笔记" />
  <meta name="twitter:title" content="Shiro - outrunJ笔记" />
  <meta name="description" content="功能 Authenticator # SecurityManager继承Authenticator public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException; permission 概念 subject resource permission role 隐式角色 显示角色 配置 shiro.ini [users] zhang=123, role1, role2 # 用户名=密码, 角色1, 角色2 判断角色 o-&gt; subject.hasRole(&quot;admin&quot;); o-&gt; @RequiresRoles(&quot;admin&quot;) @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND) # 表示当前Subject需要角色admin和user。 o-&gt; &lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;/shiro:hasRole&gt; 权限注解 @RequiresAuthentication # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。 @RequiresUser # 表示当前Subject已经身份验证或者通过记住我登录的。 @RequiresGuest # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。 @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR) # 表示当前Subject需要权限user:a或user:b。 credential 散列 String str = &quot;hello&quot;; String salt = &quot;123&quot;; //内部使用MessageDigest String simpleHash 密码生成工具 //输入明文密码得到密文密码 String encryptPassword(Object plaintextPassword) throws IllegalArgumentException; //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密） boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info); filter NameableFilter ＃根据名字找到相应的拦截器实例 OncePerRequestFilter # 控制开启、关闭拦截器实例 ShiroFilter # 安全控制 AdviceFilter # aop preHandle # 前置增强 postHandle # 后置增强 afterCompletion # 后置最终增强(异常也执行，相当于finally的概念) PathMatchingFilter # 匹配请求路径 AccessControlFilter # 允许或拒绝访问，拒绝时如何处理 jsp标签 &lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.">
  <meta property="og:description" content="功能 Authenticator # SecurityManager继承Authenticator public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException; permission 概念 subject resource permission role 隐式角色 显示角色 配置 shiro.ini [users] zhang=123, role1, role2 # 用户名=密码, 角色1, 角色2 判断角色 o-&gt; subject.hasRole(&quot;admin&quot;); o-&gt; @RequiresRoles(&quot;admin&quot;) @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND) # 表示当前Subject需要角色admin和user。 o-&gt; &lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;/shiro:hasRole&gt; 权限注解 @RequiresAuthentication # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。 @RequiresUser # 表示当前Subject已经身份验证或者通过记住我登录的。 @RequiresGuest # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。 @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR) # 表示当前Subject需要权限user:a或user:b。 credential 散列 String str = &quot;hello&quot;; String salt = &quot;123&quot;; //内部使用MessageDigest String simpleHash 密码生成工具 //输入明文密码得到密文密码 String encryptPassword(Object plaintextPassword) throws IllegalArgumentException; //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密） boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info); filter NameableFilter ＃根据名字找到相应的拦截器实例 OncePerRequestFilter # 控制开启、关闭拦截器实例 ShiroFilter # 安全控制 AdviceFilter # aop preHandle # 前置增强 postHandle # 后置增强 afterCompletion # 后置最终增强(异常也执行，相当于finally的概念) PathMatchingFilter # 匹配请求路径 AccessControlFilter # 允许或拒绝访问，拒绝时如何处理 jsp标签 &lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.">
  <meta name="twitter:description" content="功能 Authenticator # SecurityManager继承Authenticator public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException; permission 概念 subject resource …">
  <meta name="author" content="outrunJ"/>
  <meta property="og:site_name" content="outrunJ笔记" />
  <meta property="og:url" content="http://shenwenqing.com/series/backend/shiro/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.49-DEV" />
  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />
  <script src="/js/jquery-3.3.1.min.js"></script>
  <script defer src="/js/fontawesome.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">outrunJ笔记</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-categories"><a href="/categories/" title="Categories">Categories</a></li>
      <li class="site-navi-item-tags"><a href="/tags/" title="Tags">Tags</a></li>
      <li class="site-navi-item-archives"><a href="/archives/" title="Archives">Archives</a></li>
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">Shiro</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>October 11, 2018</time></li>
      </ul>
      
      

<h1 id="功能">功能</h1>

<pre><code>Authenticator                        # SecurityManager继承Authenticator
        public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  throws AuthenticationException;   
permission
    概念
            subject
            resource
            permission
            role
                    隐式角色
                    显示角色
    配置
            shiro.ini
                    [users]
                    zhang=123, role1, role2                # 用户名=密码, 角色1, 角色2
    判断角色
            o-&gt;
                    subject.hasRole(&quot;admin&quot;);
            o-&gt;
                    @RequiresRoles(&quot;admin&quot;)
                    @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)  
                            # 表示当前Subject需要角色admin和user。
            o-&gt;
                    &lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;/shiro:hasRole&gt;
    权限注解
            @RequiresAuthentication  
                    # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。
            @RequiresUser  
                    # 表示当前Subject已经身份验证或者通过记住我登录的。
            @RequiresGuest  
                    # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。 
            @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)  
                    # 表示当前Subject需要权限user:a或user:b。
credential
    散列
            String str = &quot;hello&quot;;  
            String salt = &quot;123&quot;;  
            //内部使用MessageDigest  
            String simpleHash 
    密码生成工具
            //输入明文密码得到密文密码
            String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;  
            //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）  
            boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);  
filter
    NameableFilter                        ＃根据名字找到相应的拦截器实例
    OncePerRequestFilter                # 控制开启、关闭拦截器实例
    ShiroFilter                        # 安全控制
    AdviceFilter                        # aop
            preHandle                        # 前置增强
            postHandle                        # 后置增强
            afterCompletion                # 后置最终增强(异常也执行，相当于finally的概念)
    PathMatchingFilter                # 匹配请求路径
    AccessControlFilter                # 允许或拒绝访问，拒绝时如何处理
jsp标签
    &lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;

    &lt;shiro:guest&gt;  
    欢迎游客访问，&lt;a href=&quot;${pageContext.request.contextPath}/login.jsp&quot;&gt;登录&lt;/a&gt;  
    &lt;/shiro:guest&gt;   

    &lt;shiro:user&gt;  
    欢迎[&lt;shiro:principal/&gt;]登录，&lt;a href=&quot;${pageContext.request.contextPath}/logout&quot;&gt;退出&lt;/a&gt;  
    &lt;/shiro:user&gt; 
                    # 用户已经身份验证/记住我登录后显示相应的信息。

    &lt;shiro:authenticated&gt;  
        用户[&lt;shiro:principal/&gt;]已身份验证通过  
    &lt;/shiro:authenticated&gt; 
                    # 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。

    &lt;shiro:notAuthenticated&gt;
        未身份验证（包括记住我）
    &lt;/shiro:notAuthenticated&gt; 
                    # 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证。

    &lt;shiro: principal/&gt;
                    # 显示用户身份信息，默认调用Subject.getPrincipal()获取
            &lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;
            &lt;shiro:principal property=&quot;username&quot;/&gt;  

    &lt;shiro:hasRole name=&quot;admin&quot;&gt;  
        用户[&lt;shiro:principal/&gt;]拥有角色admin&lt;br/&gt;  
    &lt;/shiro:hasRole&gt; 

    &lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;  
        用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt;  
    &lt;/shiro:hasAnyRoles&gt;   

    &lt;shiro:lacksRole name=&quot;abc&quot;&gt;  
        用户[&lt;shiro:principal/&gt;]没有角色abc&lt;br/&gt;  
    &lt;/shiro:lacksRole&gt; 
                    # 如果当前Subject没有角色将显示body体内容。

    &lt;shiro:hasPermission name=&quot;user:create&quot;&gt;  
        用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt;  
    &lt;/shiro:hasPermission&gt;

    &lt;shiro:lacksPermission name=&quot;org:create&quot;&gt;  
        用户[&lt;shiro:principal/&gt;]没有权限org:create&lt;br/&gt;  
    &lt;/shiro:lacksPermission&gt;  
session
    得到会话
            login(&quot;classpath:shiro.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);  
            Subject subject = SecurityUtils.getSubject();  
            Session session = subject.getSession(); 
    api
            Session
                    getId()                        
                    getHost()                # 调用HostAuthenticationToken.getHost(), 得到主机地址
                    getTimeout()
                    setTimeout(1000)
                    getStartTimestamp()
                    setLastAccessTime()
                    touch()                        # 更新会话最后访问时间
                    stop()                        # 销毁会话, Subject.logout()与HttpSession.invalidate()会自动调用该api
                    setAttribute(&quot;key&quot;, &quot;123&quot;)
                    getAttribute(&quot;key&quot;)
                    removeAttribute(&quot;key&quot;)
            SecurityManager
                    Session start(SessionContext context)
                    Session getSession(SessionKey key) throws SessionException
            WebSessionManager
                    boolean isServletContainerSessions();                # 是否使用Servlet容器的会话
            ValidatingSessionManager
                    void validateSessions();                                # 验证所有会话是否过期 
cache
    接口
            Cach&lt;K, V&gt;
            CacheManager
            CacheManagerAware
    ini配置
            userRealm.cachingEnabled                        # 启用缓存，默认false
            userRealm.authenticationCachingEnabled        # 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false
            userRealm.authenticationCacheName                # 缓存AuthenticationInfo信息的缓存名称
            userRealm. authorizationCachingEnabled        # 启用授权缓存，即缓存AuthorizationInfo信息，默认false
            userRealm. authorizationCacheName                # 缓存AuthorizationInfo信息的缓存名称
            securityManager.realms=$userRealm  

            cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager  
            cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml  
            securityManager.cacheManager=$cacheManager 

            sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager  
            securityManager.sessionManager=$sessionManager 
rememberme
ssl
    o-&gt; keytool -genkey -keystore &quot;D:\localhost.keystore&quot; -alias localhost -keyalg RSA
            # jdk自带的生成证书工具(包含证书/公钥/私钥）
    o-&gt; 设置tomcat server.xml
            &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;  
            maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;  
            clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;   
            keystoreFile=&quot;D:\localhost.keystore&quot; keystorePass=&quot;123456&quot;/&gt; 
    o-&gt; 
jasig cas
</code></pre>

<h1 id="api">api</h1>

<pre><code>Subject: 主体, 如用户
SecurityManager: 安全管理器, 管理subject
Realm: 权限数据域

授权
        对象流程
                Subject.isPermitted -&gt; SecurityManager -&gt; Authorizer
        对象
                ModularRealmAuthorizer        # 多realm授权
                PermissionResolver                # 解析权限字符串到Permission实例
                RolePermissionResolver                # 从角色得到权限集合
</code></pre>

<h1 id="配置">配置</h1>

<h2 id="参数">参数</h2>

<pre><code>filterChainDefinitions
        rest：比如/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user：method] ,其中method为post，get，delete等。

        port：比如/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal：//serverName：8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。

        perms：比如/admins/user/**=perms[user：add：*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，比如/admins/user/**=perms[&quot;user：add：*,user：modify：*&quot;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。

        roles：比如/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，比如/admins/user/**=roles[&quot;admin,guest&quot;],每个参数通过才算通过，相当于hasAllRoles()方法。

        anon：比如/admins/**=anon 没有参数，表示可以匿名使用。

        authc：比如/admins/user/**=authc表示需要认证才能使用，没有参数

        authcBasic：比如/admins/user/**=authcBasic没有参数表示httpBasic认证

        ssl：比如/admins/user/**=ssl没有参数，表示安全的url请求，协议为https

        user：比如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查
                # remember me可登录
</code></pre>

    </article>

    
<ul class="article-share">
  <li>
    <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </li>
  <li>
    <div class="fb-share-button" data-href="http://shenwenqing.com/series/backend/shiro/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="true"></div>
    <div id="fb-root"></div>
    <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.10";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>
  </li>
  <li>
    <script src="https://apis.google.com/js/platform.js" async defer></script>
    <g:plus action="share"></g:plus>
  </li>
  <li>
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
  <li>
    <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
    <script>!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
  </li>
</ul>


    <ul class="pager article-pager">
      <li class="pager-newer">
          <a href="/series/backend/jbpm/" data-toggle="tooltip" data-placement="top" title="Jbpm">&lt; Newer</a>
      </li>
      <li class="pager-older">
        <a href="/series/backend/mybatis/" data-toggle="tooltip" data-placement="top" title="Mybatis">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright">&copy; Copyright 2017 outrunJ</div>
  <ul class="site-footer-items">
    <li class="site-footer-item-about"><a href="/about/" title="About">About</a></li>
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>
<script src="/js/script.js"></script>
<script src="/js/custom.js"></script>


</body>
</html>
