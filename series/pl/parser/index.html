<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>编译 - outrunJ笔记</title>
  <meta property="og:title" content="编译 - outrunJ笔记" />
  <meta name="twitter:title" content="编译 - outrunJ笔记" />
  <meta name="description" content=" 流程  词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成，表格管理，错误处理 语义分析 -&gt; 类型检查/推导 -&gt; 代码优化 -&gt; 机器码生成 # 中间数据结构, 比如AST 预处理，连接程序，装入程序，调试程序  文法  G = (Vn, Vt, S, P) # 终极符号, 非终级符号, 一个特殊非终级符号，产生式 类型 短语(0), 对应图灵机(TM) 上下文相关(1), 对应线性有界自动机(LBA) 上下文无关(2), 对应下推自动机(PDA) 线性文法、正则文法、正规文法，对应有限自动机(FA) # 无法控制自返数  状态机(FA)  确定状态机(DFA) 非确定状态机(NFA) # 同状态可多种转移 DFA与NFA互相转换  词法分析  状态转换矩阵法  语法分析  自顶向下 # 最左推导建立语法树 # first集，follow集，predict集 不回溯方法 递归下降 LL(1) # 从左输入符号、产生左推导、每次读一个字符。LL(k)特例 自底向上 # 从左读, 从右向前归约 简单优先关系 # 运算符优先关系矩阵 LR(k) # 从左输入，最右推导 LR(0) # 只看栈顶状态，有分析动作冲突 SLR(1) # LR(0)加向前看展望符，不能分析所有文法 LR(1) # LR(0)的每个推导加一个向前搜索符，状态太多 LALR(1) # LR(1)中同向前搜索符的状态合并  语义分析  抽象语法树 符号表 # 动态规划记录变量的综合信息 局部化处理 # 压栈变量作用域  中间代码生成  后缀式(逆波兰式) 三地址 # 操作符两变量地址，结果地址 四元式操作符 # 地址加，赋值，过程调用，类型转换，算术、逻辑、关系运算的存储 语法制导 # 中间代码产生式后拼上语义程序，在语法分析中遇到动作马上处理 类型检查 下标变量 # 如数组下标，同上全用四元式表示  中间代码优化  常量表达式 a = 1, b = 2, c = a &#43; b, 则只记c = 3 公共表达式 a = b * c, d = b * c, 则只记a 循环不变式外提 while k &lt; 0 do b * c, 则b * c外提只计算一次 基本块 # 一块语句要么全执行，要么全不执行 消减运算强度 如加法代替乘法 复写传播 a = b, 后a, b不再变值，用a替代b 无用代码消除 数学优化（恒等变换） 如a &#43; 0 = a, a * 1 = a, a ^ 2 = a * a, a / 1 = a, 0 / a = 0 窥孔优化 对目标代码中短指令序列局部改进，如删除重复，控制流优化，代数化简，使用特殊指令等 全局优化 对整个程序控制流和数据分析再优化，如常量表达式全局优化  运行时时空管理  内存划分 存储 引用的库的代码 目标代码 静态变量 栈区 # 函数调用，中断现场 堆区 存储策略 静态分配 #编译时分配固定存储单元 动态分配 栈 堆 活动记录 保存局部变量，中间结果，临时变量，过程调用，控制信息等 专用寄存器 调用链 # 保存下一个调用的起始地址 动态链 # 保存前一个调用的起始地址 访问环境 # 记录闭包起始地址 display表 # 过程需要的所有非局部数据所在的过程活动记录的起始地址 全局display表 静态链 # 指向外层过程的活动记录的地址地址  目标代码生成  生成的语言 机器语言 可重定位的机器语言 # 由连接器装配后生成机器语言 # 多数用这种，如c语言 汇编语言 指令选择 虚拟机 寄存器分配 四元式翻译  ">
  <meta property="og:description" content=" 流程  词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成，表格管理，错误处理 语义分析 -&gt; 类型检查/推导 -&gt; 代码优化 -&gt; 机器码生成 # 中间数据结构, 比如AST 预处理，连接程序，装入程序，调试程序  文法  G = (Vn, Vt, S, P) # 终极符号, 非终级符号, 一个特殊非终级符号，产生式 类型 短语(0), 对应图灵机(TM) 上下文相关(1), 对应线性有界自动机(LBA) 上下文无关(2), 对应下推自动机(PDA) 线性文法、正则文法、正规文法，对应有限自动机(FA) # 无法控制自返数  状态机(FA)  确定状态机(DFA) 非确定状态机(NFA) # 同状态可多种转移 DFA与NFA互相转换  词法分析  状态转换矩阵法  语法分析  自顶向下 # 最左推导建立语法树 # first集，follow集，predict集 不回溯方法 递归下降 LL(1) # 从左输入符号、产生左推导、每次读一个字符。LL(k)特例 自底向上 # 从左读, 从右向前归约 简单优先关系 # 运算符优先关系矩阵 LR(k) # 从左输入，最右推导 LR(0) # 只看栈顶状态，有分析动作冲突 SLR(1) # LR(0)加向前看展望符，不能分析所有文法 LR(1) # LR(0)的每个推导加一个向前搜索符，状态太多 LALR(1) # LR(1)中同向前搜索符的状态合并  语义分析  抽象语法树 符号表 # 动态规划记录变量的综合信息 局部化处理 # 压栈变量作用域  中间代码生成  后缀式(逆波兰式) 三地址 # 操作符两变量地址，结果地址 四元式操作符 # 地址加，赋值，过程调用，类型转换，算术、逻辑、关系运算的存储 语法制导 # 中间代码产生式后拼上语义程序，在语法分析中遇到动作马上处理 类型检查 下标变量 # 如数组下标，同上全用四元式表示  中间代码优化  常量表达式 a = 1, b = 2, c = a &#43; b, 则只记c = 3 公共表达式 a = b * c, d = b * c, 则只记a 循环不变式外提 while k &lt; 0 do b * c, 则b * c外提只计算一次 基本块 # 一块语句要么全执行，要么全不执行 消减运算强度 如加法代替乘法 复写传播 a = b, 后a, b不再变值，用a替代b 无用代码消除 数学优化（恒等变换） 如a &#43; 0 = a, a * 1 = a, a ^ 2 = a * a, a / 1 = a, 0 / a = 0 窥孔优化 对目标代码中短指令序列局部改进，如删除重复，控制流优化，代数化简，使用特殊指令等 全局优化 对整个程序控制流和数据分析再优化，如常量表达式全局优化  运行时时空管理  内存划分 存储 引用的库的代码 目标代码 静态变量 栈区 # 函数调用，中断现场 堆区 存储策略 静态分配 #编译时分配固定存储单元 动态分配 栈 堆 活动记录 保存局部变量，中间结果，临时变量，过程调用，控制信息等 专用寄存器 调用链 # 保存下一个调用的起始地址 动态链 # 保存前一个调用的起始地址 访问环境 # 记录闭包起始地址 display表 # 过程需要的所有非局部数据所在的过程活动记录的起始地址 全局display表 静态链 # 指向外层过程的活动记录的地址地址  目标代码生成  生成的语言 机器语言 可重定位的机器语言 # 由连接器装配后生成机器语言 # 多数用这种，如c语言 汇编语言 指令选择 虚拟机 寄存器分配 四元式翻译  ">
  <meta name="twitter:description" content=" 流程  词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成，表格管理，错误处理 语义分析 -&gt; 类型检查/推导 -&gt; 代码优化 -&gt; 机器码生成 # 中间数据结构, 比如AST 预处理，连接程序，装入程序，调试程序  文法  G = (Vn, Vt, S, P) # 终极符号, 非终级符号, 一个特殊非终级符号，产生式 类型 短语(0), 对应图灵机(TM) …">
  <meta name="author" content="outrunJ"/>
  <meta property="og:site_name" content="outrunJ笔记" />
  <meta property="og:url" content="http://shenwenqing.com/series/pl/parser/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.49-DEV" />
  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />
  <script src="/js/jquery-3.3.1.min.js"></script>
  <script defer src="/js/fontawesome.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">outrunJ笔记</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-categories"><a href="/categories/" title="Categories">Categories</a></li>
      <li class="site-navi-item-tags"><a href="/tags/" title="Tags">Tags</a></li>
      <li class="site-navi-item-archives"><a href="/archives/" title="Archives">Archives</a></li>
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">编译</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>October 8, 2018</time></li>
      </ul>
      
      

<h1 id="流程">流程</h1>

<pre><code>    词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成，表格管理，错误处理
    语义分析 -&gt; 类型检查/推导 -&gt; 代码优化 -&gt; 机器码生成
            # 中间数据结构, 比如AST
    预处理，连接程序，装入程序，调试程序
</code></pre>

<h1 id="文法">文法</h1>

<pre><code>    G = (Vn, Vt, S, P)
            # 终极符号, 非终级符号, 一个特殊非终级符号，产生式
    类型
            短语(0), 对应图灵机(TM)
            上下文相关(1), 对应线性有界自动机(LBA)
            上下文无关(2), 对应下推自动机(PDA)
            线性文法、正则文法、正规文法，对应有限自动机(FA)
                    # 无法控制自返数
</code></pre>

<h1 id="状态机-fa">状态机(FA)</h1>

<pre><code>    确定状态机(DFA)
    非确定状态机(NFA)
            # 同状态可多种转移
    DFA与NFA互相转换
</code></pre>

<h1 id="词法分析">词法分析</h1>

<pre><code>    状态转换矩阵法
</code></pre>

<h1 id="语法分析">语法分析</h1>

<pre><code>    自顶向下
            # 最左推导建立语法树
            # first集，follow集，predict集
            不回溯方法
            递归下降
            LL(1)
                    # 从左输入符号、产生左推导、每次读一个字符。LL(k)特例
    自底向上
            # 从左读, 从右向前归约
            简单优先关系
                    # 运算符优先关系矩阵
            LR(k)
                    # 从左输入，最右推导
                    LR(0)
                            # 只看栈顶状态，有分析动作冲突
                    SLR(1)
                            # LR(0)加向前看展望符，不能分析所有文法
                    LR(1)
                            # LR(0)的每个推导加一个向前搜索符，状态太多
                    LALR(1)
                            # LR(1)中同向前搜索符的状态合并
</code></pre>

<h1 id="语义分析">语义分析</h1>

<pre><code>    抽象语法树
    符号表
            # 动态规划记录变量的综合信息
    局部化处理
            # 压栈变量作用域
</code></pre>

<h1 id="中间代码生成">中间代码生成</h1>

<pre><code>    后缀式(逆波兰式)
    三地址
            # 操作符两变量地址，结果地址
    四元式操作符
            # 地址加，赋值，过程调用，类型转换，算术、逻辑、关系运算的存储
    语法制导
            # 中间代码产生式后拼上语义程序，在语法分析中遇到动作马上处理
    类型检查
    下标变量
            # 如数组下标，同上全用四元式表示
</code></pre>

<h1 id="中间代码优化">中间代码优化</h1>

<pre><code>    常量表达式
            a = 1, b = 2, c = a + b, 则只记c = 3
    公共表达式
            a = b * c, d = b * c, 则只记a
    循环不变式外提
            while k &lt; 0 do b * c, 则b * c外提只计算一次
    基本块
            # 一块语句要么全执行，要么全不执行
    消减运算强度
            如加法代替乘法
    复写传播
            a = b, 后a, b不再变值，用a替代b
    无用代码消除
    数学优化（恒等变换）
            如a + 0 = a, a * 1 = a, a ^ 2 = a * a, a / 1 = a, 0 / a = 0
    窥孔优化
            对目标代码中短指令序列局部改进，如删除重复，控制流优化，代数化简，使用特殊指令等
    全局优化
            对整个程序控制流和数据分析再优化，如常量表达式全局优化
</code></pre>

<h1 id="运行时时空管理">运行时时空管理</h1>

<pre><code>    内存划分
            存储
                    引用的库的代码
                    目标代码
                    静态变量
                    栈区
                            # 函数调用，中断现场
                    堆区
            存储策略
                    静态分配
                            #编译时分配固定存储单元
                    动态分配
                            栈
                            堆
            活动记录
                    保存局部变量，中间结果，临时变量，过程调用，控制信息等
                    专用寄存器
                    调用链
                            # 保存下一个调用的起始地址
                    动态链
                            # 保存前一个调用的起始地址
            访问环境
                    # 记录闭包起始地址
                    display表
                            # 过程需要的所有非局部数据所在的过程活动记录的起始地址
                    全局display表
                    静态链
                            # 指向外层过程的活动记录的地址地址
</code></pre>

<h1 id="目标代码生成">目标代码生成</h1>

<pre><code>    生成的语言
            机器语言
            可重定位的机器语言
                    # 由连接器装配后生成机器语言
                    # 多数用这种，如c语言
            汇编语言
    指令选择
    虚拟机
    寄存器分配
    四元式翻译
</code></pre>

    </article>

    
<ul class="article-share">
  <li>
    <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </li>
  <li>
    <div class="fb-share-button" data-href="http://shenwenqing.com/series/pl/parser/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="true"></div>
    <div id="fb-root"></div>
    <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.10";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>
  </li>
  <li>
    <script src="https://apis.google.com/js/platform.js" async defer></script>
    <g:plus action="share"></g:plus>
  </li>
  <li>
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
  <li>
    <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
    <script>!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
  </li>
</ul>


    <ul class="pager article-pager">
      <li class="pager-newer">
          <a href="/series/pl/language/" data-toggle="tooltip" data-placement="top" title="pl语言">&lt; Newer</a>
      </li>
      <li class="pager-older">
        <a href="/series/pl/principle/" data-toggle="tooltip" data-placement="top" title="pl原理">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright">&copy; Copyright 2017 outrunJ</div>
  <ul class="site-footer-items">
    <li class="site-footer-item-about"><a href="/about/" title="About">About</a></li>
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>
<script src="/js/script.js"></script>
<script src="/js/custom.js"></script>


</body>
</html>
